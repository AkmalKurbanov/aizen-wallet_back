!function () { var e = { 755: function (e, t) { var i; !function (t, i) { "use strict"; "object" == typeof e.exports ? e.exports = t.document ? i(t, !0) : function (e) { if (!e.document) throw new Error("jQuery requires a window with a document"); return i(e) } : i(t) }("undefined" != typeof window ? window : this, (function (n, s) { "use strict"; var a = [], o = Object.getPrototypeOf, r = a.slice, l = a.flat ? function (e) { return a.flat.call(e) } : function (e) { return a.concat.apply([], e) }, c = a.push, d = a.indexOf, h = {}, u = h.toString, p = h.hasOwnProperty, f = p.toString, m = f.call(Object), g = {}, v = function (e) { return "function" == typeof e && "number" != typeof e.nodeType && "function" != typeof e.item }, y = function (e) { return null != e && e === e.window }, b = n.document, x = { type: !0, src: !0, nonce: !0, noModule: !0 }; function w(e, t, i) { var n, s, a = (i = i || b).createElement("script"); if (a.text = e, t) for (n in x) (s = t[n] || t.getAttribute && t.getAttribute(n)) && a.setAttribute(n, s); i.head.appendChild(a).parentNode.removeChild(a) } function C(e) { return null == e ? e + "" : "object" == typeof e || "function" == typeof e ? h[u.call(e)] || "object" : typeof e } var E = "3.6.3", T = function (e, t) { return new T.fn.init(e, t) }; function S(e) { var t = !!e && "length" in e && e.length, i = C(e); return !v(e) && !y(e) && ("array" === i || 0 === t || "number" == typeof t && t > 0 && t - 1 in e) } T.fn = T.prototype = { jquery: E, constructor: T, length: 0, toArray: function () { return r.call(this) }, get: function (e) { return null == e ? r.call(this) : e < 0 ? this[e + this.length] : this[e] }, pushStack: function (e) { var t = T.merge(this.constructor(), e); return t.prevObject = this, t }, each: function (e) { return T.each(this, e) }, map: function (e) { return this.pushStack(T.map(this, (function (t, i) { return e.call(t, i, t) }))) }, slice: function () { return this.pushStack(r.apply(this, arguments)) }, first: function () { return this.eq(0) }, last: function () { return this.eq(-1) }, even: function () { return this.pushStack(T.grep(this, (function (e, t) { return (t + 1) % 2 }))) }, odd: function () { return this.pushStack(T.grep(this, (function (e, t) { return t % 2 }))) }, eq: function (e) { var t = this.length, i = +e + (e < 0 ? t : 0); return this.pushStack(i >= 0 && i < t ? [this[i]] : []) }, end: function () { return this.prevObject || this.constructor() }, push: c, sort: a.sort, splice: a.splice }, T.extend = T.fn.extend = function () { var e, t, i, n, s, a, o = arguments[0] || {}, r = 1, l = arguments.length, c = !1; for ("boolean" == typeof o && (c = o, o = arguments[r] || {}, r++), "object" == typeof o || v(o) || (o = {}), r === l && (o = this, r--); r < l; r++)if (null != (e = arguments[r])) for (t in e) n = e[t], "__proto__" !== t && o !== n && (c && n && (T.isPlainObject(n) || (s = Array.isArray(n))) ? (i = o[t], a = s && !Array.isArray(i) ? [] : s || T.isPlainObject(i) ? i : {}, s = !1, o[t] = T.extend(c, a, n)) : void 0 !== n && (o[t] = n)); return o }, T.extend({ expando: "jQuery" + (E + Math.random()).replace(/\D/g, ""), isReady: !0, error: function (e) { throw new Error(e) }, noop: function () { }, isPlainObject: function (e) { var t, i; return !(!e || "[object Object]" !== u.call(e)) && (!(t = o(e)) || "function" == typeof (i = p.call(t, "constructor") && t.constructor) && f.call(i) === m) }, isEmptyObject: function (e) { var t; for (t in e) return !1; return !0 }, globalEval: function (e, t, i) { w(e, { nonce: t && t.nonce }, i) }, each: function (e, t) { var i, n = 0; if (S(e)) for (i = e.length; n < i && !1 !== t.call(e[n], n, e[n]); n++); else for (n in e) if (!1 === t.call(e[n], n, e[n])) break; return e }, makeArray: function (e, t) { var i = t || []; return null != e && (S(Object(e)) ? T.merge(i, "string" == typeof e ? [e] : e) : c.call(i, e)), i }, inArray: function (e, t, i) { return null == t ? -1 : d.call(t, e, i) }, merge: function (e, t) { for (var i = +t.length, n = 0, s = e.length; n < i; n++)e[s++] = t[n]; return e.length = s, e }, grep: function (e, t, i) { for (var n = [], s = 0, a = e.length, o = !i; s < a; s++)!t(e[s], s) !== o && n.push(e[s]); return n }, map: function (e, t, i) { var n, s, a = 0, o = []; if (S(e)) for (n = e.length; a < n; a++)null != (s = t(e[a], a, i)) && o.push(s); else for (a in e) null != (s = t(e[a], a, i)) && o.push(s); return l(o) }, guid: 1, support: g }), "function" == typeof Symbol && (T.fn[Symbol.iterator] = a[Symbol.iterator]), T.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), (function (e, t) { h["[object " + t + "]"] = t.toLowerCase() })); var $ = function (e) { var t, i, n, s, a, o, r, l, c, d, h, u, p, f, m, g, v, y, b, x = "sizzle" + 1 * new Date, w = e.document, C = 0, E = 0, T = le(), S = le(), $ = le(), M = le(), P = function (e, t) { return e === t && (h = !0), 0 }, k = {}.hasOwnProperty, L = [], A = L.pop, z = L.push, O = L.push, I = L.slice, D = function (e, t) { for (var i = 0, n = e.length; i < n; i++)if (e[i] === t) return i; return -1 }, _ = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", N = "[\\x20\\t\\r\\n\\f]", R = "(?:\\\\[\\da-fA-F]{1,6}" + N + "?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+", H = "\\[" + N + "*(" + R + ")(?:" + N + "*([*^$|!~]?=)" + N + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + R + "))|)" + N + "*\\]", j = ":(" + R + ")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|" + H + ")*)|.*)\\)|)", F = new RegExp(N + "+", "g"), q = new RegExp("^" + N + "+|((?:^|[^\\\\])(?:\\\\.)*)" + N + "+$", "g"), B = new RegExp("^" + N + "*," + N + "*"), W = new RegExp("^" + N + "*([>+~]|" + N + ")" + N + "*"), X = new RegExp(N + "|>"), Y = new RegExp(j), G = new RegExp("^" + R + "$"), V = { ID: new RegExp("^#(" + R + ")"), CLASS: new RegExp("^\\.(" + R + ")"), TAG: new RegExp("^(" + R + "|[*])"), ATTR: new RegExp("^" + H), PSEUDO: new RegExp("^" + j), CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + N + "*(even|odd|(([+-]|)(\\d*)n|)" + N + "*(?:([+-]|)" + N + "*(\\d+)|))" + N + "*\\)|)", "i"), bool: new RegExp("^(?:" + _ + ")$", "i"), needsContext: new RegExp("^" + N + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + N + "*((?:-\\d)?\\d*)" + N + "*\\)|)(?=[^-]|$)", "i") }, U = /HTML$/i, Z = /^(?:input|select|textarea|button)$/i, K = /^h\d$/i, J = /^[^{]+\{\s*\[native \w/, Q = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, ee = /[+~]/, te = new RegExp("\\\\[\\da-fA-F]{1,6}" + N + "?|\\\\([^\\r\\n\\f])", "g"), ie = function (e, t) { var i = "0x" + e.slice(1) - 65536; return t || (i < 0 ? String.fromCharCode(i + 65536) : String.fromCharCode(i >> 10 | 55296, 1023 & i | 56320)) }, ne = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g, se = function (e, t) { return t ? "\0" === e ? "ï¿½" : e.slice(0, -1) + "\\" + e.charCodeAt(e.length - 1).toString(16) + " " : "\\" + e }, ae = function () { u() }, oe = xe((function (e) { return !0 === e.disabled && "fieldset" === e.nodeName.toLowerCase() }), { dir: "parentNode", next: "legend" }); try { O.apply(L = I.call(w.childNodes), w.childNodes), L[w.childNodes.length].nodeType } catch (e) { O = { apply: L.length ? function (e, t) { z.apply(e, I.call(t)) } : function (e, t) { for (var i = e.length, n = 0; e[i++] = t[n++];); e.length = i - 1 } } } function re(e, t, n, s) { var a, r, c, d, h, f, v, y = t && t.ownerDocument, w = t ? t.nodeType : 9; if (n = n || [], "string" != typeof e || !e || 1 !== w && 9 !== w && 11 !== w) return n; if (!s && (u(t), t = t || p, m)) { if (11 !== w && (h = Q.exec(e))) if (a = h[1]) { if (9 === w) { if (!(c = t.getElementById(a))) return n; if (c.id === a) return n.push(c), n } else if (y && (c = y.getElementById(a)) && b(t, c) && c.id === a) return n.push(c), n } else { if (h[2]) return O.apply(n, t.getElementsByTagName(e)), n; if ((a = h[3]) && i.getElementsByClassName && t.getElementsByClassName) return O.apply(n, t.getElementsByClassName(a)), n } if (i.qsa && !M[e + " "] && (!g || !g.test(e)) && (1 !== w || "object" !== t.nodeName.toLowerCase())) { if (v = e, y = t, 1 === w && (X.test(e) || W.test(e))) { for ((y = ee.test(e) && ve(t.parentNode) || t) === t && i.scope || ((d = t.getAttribute("id")) ? d = d.replace(ne, se) : t.setAttribute("id", d = x)), r = (f = o(e)).length; r--;)f[r] = (d ? "#" + d : ":scope") + " " + be(f[r]); v = f.join(",") } try { if (i.cssSupportsSelector && !CSS.supports("selector(:is(" + v + "))")) throw new Error; return O.apply(n, y.querySelectorAll(v)), n } catch (t) { M(e, !0) } finally { d === x && t.removeAttribute("id") } } } return l(e.replace(q, "$1"), t, n, s) } function le() { var e = []; return function t(i, s) { return e.push(i + " ") > n.cacheLength && delete t[e.shift()], t[i + " "] = s } } function ce(e) { return e[x] = !0, e } function de(e) { var t = p.createElement("fieldset"); try { return !!e(t) } catch (e) { return !1 } finally { t.parentNode && t.parentNode.removeChild(t), t = null } } function he(e, t) { for (var i = e.split("|"), s = i.length; s--;)n.attrHandle[i[s]] = t } function ue(e, t) { var i = t && e, n = i && 1 === e.nodeType && 1 === t.nodeType && e.sourceIndex - t.sourceIndex; if (n) return n; if (i) for (; i = i.nextSibling;)if (i === t) return -1; return e ? 1 : -1 } function pe(e) { return function (t) { return "input" === t.nodeName.toLowerCase() && t.type === e } } function fe(e) { return function (t) { var i = t.nodeName.toLowerCase(); return ("input" === i || "button" === i) && t.type === e } } function me(e) { return function (t) { return "form" in t ? t.parentNode && !1 === t.disabled ? "label" in t ? "label" in t.parentNode ? t.parentNode.disabled === e : t.disabled === e : t.isDisabled === e || t.isDisabled !== !e && oe(t) === e : t.disabled === e : "label" in t && t.disabled === e } } function ge(e) { return ce((function (t) { return t = +t, ce((function (i, n) { for (var s, a = e([], i.length, t), o = a.length; o--;)i[s = a[o]] && (i[s] = !(n[s] = i[s])) })) })) } function ve(e) { return e && void 0 !== e.getElementsByTagName && e } for (t in i = re.support = {}, a = re.isXML = function (e) { var t = e && e.namespaceURI, i = e && (e.ownerDocument || e).documentElement; return !U.test(t || i && i.nodeName || "HTML") }, u = re.setDocument = function (e) { var t, s, o = e ? e.ownerDocument || e : w; return o != p && 9 === o.nodeType && o.documentElement ? (f = (p = o).documentElement, m = !a(p), w != p && (s = p.defaultView) && s.top !== s && (s.addEventListener ? s.addEventListener("unload", ae, !1) : s.attachEvent && s.attachEvent("onunload", ae)), i.scope = de((function (e) { return f.appendChild(e).appendChild(p.createElement("div")), void 0 !== e.querySelectorAll && !e.querySelectorAll(":scope fieldset div").length })), i.cssSupportsSelector = de((function () { return CSS.supports("selector(*)") && p.querySelectorAll(":is(:jqfake)") && !CSS.supports("selector(:is(*,:jqfake))") })), i.attributes = de((function (e) { return e.className = "i", !e.getAttribute("className") })), i.getElementsByTagName = de((function (e) { return e.appendChild(p.createComment("")), !e.getElementsByTagName("*").length })), i.getElementsByClassName = J.test(p.getElementsByClassName), i.getById = de((function (e) { return f.appendChild(e).id = x, !p.getElementsByName || !p.getElementsByName(x).length })), i.getById ? (n.filter.ID = function (e) { var t = e.replace(te, ie); return function (e) { return e.getAttribute("id") === t } }, n.find.ID = function (e, t) { if (void 0 !== t.getElementById && m) { var i = t.getElementById(e); return i ? [i] : [] } }) : (n.filter.ID = function (e) { var t = e.replace(te, ie); return function (e) { var i = void 0 !== e.getAttributeNode && e.getAttributeNode("id"); return i && i.value === t } }, n.find.ID = function (e, t) { if (void 0 !== t.getElementById && m) { var i, n, s, a = t.getElementById(e); if (a) { if ((i = a.getAttributeNode("id")) && i.value === e) return [a]; for (s = t.getElementsByName(e), n = 0; a = s[n++];)if ((i = a.getAttributeNode("id")) && i.value === e) return [a] } return [] } }), n.find.TAG = i.getElementsByTagName ? function (e, t) { return void 0 !== t.getElementsByTagName ? t.getElementsByTagName(e) : i.qsa ? t.querySelectorAll(e) : void 0 } : function (e, t) { var i, n = [], s = 0, a = t.getElementsByTagName(e); if ("*" === e) { for (; i = a[s++];)1 === i.nodeType && n.push(i); return n } return a }, n.find.CLASS = i.getElementsByClassName && function (e, t) { if (void 0 !== t.getElementsByClassName && m) return t.getElementsByClassName(e) }, v = [], g = [], (i.qsa = J.test(p.querySelectorAll)) && (de((function (e) { var t; f.appendChild(e).innerHTML = "<a id='" + x + "'></a><select id='" + x + "-\r\\' msallowcapture=''><option selected=''></option></select>", e.querySelectorAll("[msallowcapture^='']").length && g.push("[*^$]=" + N + "*(?:''|\"\")"), e.querySelectorAll("[selected]").length || g.push("\\[" + N + "*(?:value|" + _ + ")"), e.querySelectorAll("[id~=" + x + "-]").length || g.push("~="), (t = p.createElement("input")).setAttribute("name", ""), e.appendChild(t), e.querySelectorAll("[name='']").length || g.push("\\[" + N + "*name" + N + "*=" + N + "*(?:''|\"\")"), e.querySelectorAll(":checked").length || g.push(":checked"), e.querySelectorAll("a#" + x + "+*").length || g.push(".#.+[+~]"), e.querySelectorAll("\\\f"), g.push("[\\r\\n\\f]") })), de((function (e) { e.innerHTML = "<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>"; var t = p.createElement("input"); t.setAttribute("type", "hidden"), e.appendChild(t).setAttribute("name", "D"), e.querySelectorAll("[name=d]").length && g.push("name" + N + "*[*^$|!~]?="), 2 !== e.querySelectorAll(":enabled").length && g.push(":enabled", ":disabled"), f.appendChild(e).disabled = !0, 2 !== e.querySelectorAll(":disabled").length && g.push(":enabled", ":disabled"), e.querySelectorAll("*,:x"), g.push(",.*:") }))), (i.matchesSelector = J.test(y = f.matches || f.webkitMatchesSelector || f.mozMatchesSelector || f.oMatchesSelector || f.msMatchesSelector)) && de((function (e) { i.disconnectedMatch = y.call(e, "*"), y.call(e, "[s!='']:x"), v.push("!=", j) })), i.cssSupportsSelector || g.push(":has"), g = g.length && new RegExp(g.join("|")), v = v.length && new RegExp(v.join("|")), t = J.test(f.compareDocumentPosition), b = t || J.test(f.contains) ? function (e, t) { var i = 9 === e.nodeType && e.documentElement || e, n = t && t.parentNode; return e === n || !(!n || 1 !== n.nodeType || !(i.contains ? i.contains(n) : e.compareDocumentPosition && 16 & e.compareDocumentPosition(n))) } : function (e, t) { if (t) for (; t = t.parentNode;)if (t === e) return !0; return !1 }, P = t ? function (e, t) { if (e === t) return h = !0, 0; var n = !e.compareDocumentPosition - !t.compareDocumentPosition; return n || (1 & (n = (e.ownerDocument || e) == (t.ownerDocument || t) ? e.compareDocumentPosition(t) : 1) || !i.sortDetached && t.compareDocumentPosition(e) === n ? e == p || e.ownerDocument == w && b(w, e) ? -1 : t == p || t.ownerDocument == w && b(w, t) ? 1 : d ? D(d, e) - D(d, t) : 0 : 4 & n ? -1 : 1) } : function (e, t) { if (e === t) return h = !0, 0; var i, n = 0, s = e.parentNode, a = t.parentNode, o = [e], r = [t]; if (!s || !a) return e == p ? -1 : t == p ? 1 : s ? -1 : a ? 1 : d ? D(d, e) - D(d, t) : 0; if (s === a) return ue(e, t); for (i = e; i = i.parentNode;)o.unshift(i); for (i = t; i = i.parentNode;)r.unshift(i); for (; o[n] === r[n];)n++; return n ? ue(o[n], r[n]) : o[n] == w ? -1 : r[n] == w ? 1 : 0 }, p) : p }, re.matches = function (e, t) { return re(e, null, null, t) }, re.matchesSelector = function (e, t) { if (u(e), i.matchesSelector && m && !M[t + " "] && (!v || !v.test(t)) && (!g || !g.test(t))) try { var n = y.call(e, t); if (n || i.disconnectedMatch || e.document && 11 !== e.document.nodeType) return n } catch (e) { M(t, !0) } return re(t, p, null, [e]).length > 0 }, re.contains = function (e, t) { return (e.ownerDocument || e) != p && u(e), b(e, t) }, re.attr = function (e, t) { (e.ownerDocument || e) != p && u(e); var s = n.attrHandle[t.toLowerCase()], a = s && k.call(n.attrHandle, t.toLowerCase()) ? s(e, t, !m) : void 0; return void 0 !== a ? a : i.attributes || !m ? e.getAttribute(t) : (a = e.getAttributeNode(t)) && a.specified ? a.value : null }, re.escape = function (e) { return (e + "").replace(ne, se) }, re.error = function (e) { throw new Error("Syntax error, unrecognized expression: " + e) }, re.uniqueSort = function (e) { var t, n = [], s = 0, a = 0; if (h = !i.detectDuplicates, d = !i.sortStable && e.slice(0), e.sort(P), h) { for (; t = e[a++];)t === e[a] && (s = n.push(a)); for (; s--;)e.splice(n[s], 1) } return d = null, e }, s = re.getText = function (e) { var t, i = "", n = 0, a = e.nodeType; if (a) { if (1 === a || 9 === a || 11 === a) { if ("string" == typeof e.textContent) return e.textContent; for (e = e.firstChild; e; e = e.nextSibling)i += s(e) } else if (3 === a || 4 === a) return e.nodeValue } else for (; t = e[n++];)i += s(t); return i }, n = re.selectors = { cacheLength: 50, createPseudo: ce, match: V, attrHandle: {}, find: {}, relative: { ">": { dir: "parentNode", first: !0 }, " ": { dir: "parentNode" }, "+": { dir: "previousSibling", first: !0 }, "~": { dir: "previousSibling" } }, preFilter: { ATTR: function (e) { return e[1] = e[1].replace(te, ie), e[3] = (e[3] || e[4] || e[5] || "").replace(te, ie), "~=" === e[2] && (e[3] = " " + e[3] + " "), e.slice(0, 4) }, CHILD: function (e) { return e[1] = e[1].toLowerCase(), "nth" === e[1].slice(0, 3) ? (e[3] || re.error(e[0]), e[4] = +(e[4] ? e[5] + (e[6] || 1) : 2 * ("even" === e[3] || "odd" === e[3])), e[5] = +(e[7] + e[8] || "odd" === e[3])) : e[3] && re.error(e[0]), e }, PSEUDO: function (e) { var t, i = !e[6] && e[2]; return V.CHILD.test(e[0]) ? null : (e[3] ? e[2] = e[4] || e[5] || "" : i && Y.test(i) && (t = o(i, !0)) && (t = i.indexOf(")", i.length - t) - i.length) && (e[0] = e[0].slice(0, t), e[2] = i.slice(0, t)), e.slice(0, 3)) } }, filter: { TAG: function (e) { var t = e.replace(te, ie).toLowerCase(); return "*" === e ? function () { return !0 } : function (e) { return e.nodeName && e.nodeName.toLowerCase() === t } }, CLASS: function (e) { var t = T[e + " "]; return t || (t = new RegExp("(^|" + N + ")" + e + "(" + N + "|$)")) && T(e, (function (e) { return t.test("string" == typeof e.className && e.className || void 0 !== e.getAttribute && e.getAttribute("class") || "") })) }, ATTR: function (e, t, i) { return function (n) { var s = re.attr(n, e); return null == s ? "!=" === t : !t || (s += "", "=" === t ? s === i : "!=" === t ? s !== i : "^=" === t ? i && 0 === s.indexOf(i) : "*=" === t ? i && s.indexOf(i) > -1 : "$=" === t ? i && s.slice(-i.length) === i : "~=" === t ? (" " + s.replace(F, " ") + " ").indexOf(i) > -1 : "|=" === t && (s === i || s.slice(0, i.length + 1) === i + "-")) } }, CHILD: function (e, t, i, n, s) { var a = "nth" !== e.slice(0, 3), o = "last" !== e.slice(-4), r = "of-type" === t; return 1 === n && 0 === s ? function (e) { return !!e.parentNode } : function (t, i, l) { var c, d, h, u, p, f, m = a !== o ? "nextSibling" : "previousSibling", g = t.parentNode, v = r && t.nodeName.toLowerCase(), y = !l && !r, b = !1; if (g) { if (a) { for (; m;) { for (u = t; u = u[m];)if (r ? u.nodeName.toLowerCase() === v : 1 === u.nodeType) return !1; f = m = "only" === e && !f && "nextSibling" } return !0 } if (f = [o ? g.firstChild : g.lastChild], o && y) { for (b = (p = (c = (d = (h = (u = g)[x] || (u[x] = {}))[u.uniqueID] || (h[u.uniqueID] = {}))[e] || [])[0] === C && c[1]) && c[2], u = p && g.childNodes[p]; u = ++p && u && u[m] || (b = p = 0) || f.pop();)if (1 === u.nodeType && ++b && u === t) { d[e] = [C, p, b]; break } } else if (y && (b = p = (c = (d = (h = (u = t)[x] || (u[x] = {}))[u.uniqueID] || (h[u.uniqueID] = {}))[e] || [])[0] === C && c[1]), !1 === b) for (; (u = ++p && u && u[m] || (b = p = 0) || f.pop()) && ((r ? u.nodeName.toLowerCase() !== v : 1 !== u.nodeType) || !++b || (y && ((d = (h = u[x] || (u[x] = {}))[u.uniqueID] || (h[u.uniqueID] = {}))[e] = [C, b]), u !== t));); return (b -= s) === n || b % n == 0 && b / n >= 0 } } }, PSEUDO: function (e, t) { var i, s = n.pseudos[e] || n.setFilters[e.toLowerCase()] || re.error("unsupported pseudo: " + e); return s[x] ? s(t) : s.length > 1 ? (i = [e, e, "", t], n.setFilters.hasOwnProperty(e.toLowerCase()) ? ce((function (e, i) { for (var n, a = s(e, t), o = a.length; o--;)e[n = D(e, a[o])] = !(i[n] = a[o]) })) : function (e) { return s(e, 0, i) }) : s } }, pseudos: { not: ce((function (e) { var t = [], i = [], n = r(e.replace(q, "$1")); return n[x] ? ce((function (e, t, i, s) { for (var a, o = n(e, null, s, []), r = e.length; r--;)(a = o[r]) && (e[r] = !(t[r] = a)) })) : function (e, s, a) { return t[0] = e, n(t, null, a, i), t[0] = null, !i.pop() } })), has: ce((function (e) { return function (t) { return re(e, t).length > 0 } })), contains: ce((function (e) { return e = e.replace(te, ie), function (t) { return (t.textContent || s(t)).indexOf(e) > -1 } })), lang: ce((function (e) { return G.test(e || "") || re.error("unsupported lang: " + e), e = e.replace(te, ie).toLowerCase(), function (t) { var i; do { if (i = m ? t.lang : t.getAttribute("xml:lang") || t.getAttribute("lang")) return (i = i.toLowerCase()) === e || 0 === i.indexOf(e + "-") } while ((t = t.parentNode) && 1 === t.nodeType); return !1 } })), target: function (t) { var i = e.location && e.location.hash; return i && i.slice(1) === t.id }, root: function (e) { return e === f }, focus: function (e) { return e === p.activeElement && (!p.hasFocus || p.hasFocus()) && !!(e.type || e.href || ~e.tabIndex) }, enabled: me(!1), disabled: me(!0), checked: function (e) { var t = e.nodeName.toLowerCase(); return "input" === t && !!e.checked || "option" === t && !!e.selected }, selected: function (e) { return e.parentNode && e.parentNode.selectedIndex, !0 === e.selected }, empty: function (e) { for (e = e.firstChild; e; e = e.nextSibling)if (e.nodeType < 6) return !1; return !0 }, parent: function (e) { return !n.pseudos.empty(e) }, header: function (e) { return K.test(e.nodeName) }, input: function (e) { return Z.test(e.nodeName) }, button: function (e) { var t = e.nodeName.toLowerCase(); return "input" === t && "button" === e.type || "button" === t }, text: function (e) { var t; return "input" === e.nodeName.toLowerCase() && "text" === e.type && (null == (t = e.getAttribute("type")) || "text" === t.toLowerCase()) }, first: ge((function () { return [0] })), last: ge((function (e, t) { return [t - 1] })), eq: ge((function (e, t, i) { return [i < 0 ? i + t : i] })), even: ge((function (e, t) { for (var i = 0; i < t; i += 2)e.push(i); return e })), odd: ge((function (e, t) { for (var i = 1; i < t; i += 2)e.push(i); return e })), lt: ge((function (e, t, i) { for (var n = i < 0 ? i + t : i > t ? t : i; --n >= 0;)e.push(n); return e })), gt: ge((function (e, t, i) { for (var n = i < 0 ? i + t : i; ++n < t;)e.push(n); return e })) } }, n.pseudos.nth = n.pseudos.eq, { radio: !0, checkbox: !0, file: !0, password: !0, image: !0 }) n.pseudos[t] = pe(t); for (t in { submit: !0, reset: !0 }) n.pseudos[t] = fe(t); function ye() { } function be(e) { for (var t = 0, i = e.length, n = ""; t < i; t++)n += e[t].value; return n } function xe(e, t, i) { var n = t.dir, s = t.next, a = s || n, o = i && "parentNode" === a, r = E++; return t.first ? function (t, i, s) { for (; t = t[n];)if (1 === t.nodeType || o) return e(t, i, s); return !1 } : function (t, i, l) { var c, d, h, u = [C, r]; if (l) { for (; t = t[n];)if ((1 === t.nodeType || o) && e(t, i, l)) return !0 } else for (; t = t[n];)if (1 === t.nodeType || o) if (d = (h = t[x] || (t[x] = {}))[t.uniqueID] || (h[t.uniqueID] = {}), s && s === t.nodeName.toLowerCase()) t = t[n] || t; else { if ((c = d[a]) && c[0] === C && c[1] === r) return u[2] = c[2]; if (d[a] = u, u[2] = e(t, i, l)) return !0 } return !1 } } function we(e) { return e.length > 1 ? function (t, i, n) { for (var s = e.length; s--;)if (!e[s](t, i, n)) return !1; return !0 } : e[0] } function Ce(e, t, i, n, s) { for (var a, o = [], r = 0, l = e.length, c = null != t; r < l; r++)(a = e[r]) && (i && !i(a, n, s) || (o.push(a), c && t.push(r))); return o } function Ee(e, t, i, n, s, a) { return n && !n[x] && (n = Ee(n)), s && !s[x] && (s = Ee(s, a)), ce((function (a, o, r, l) { var c, d, h, u = [], p = [], f = o.length, m = a || function (e, t, i) { for (var n = 0, s = t.length; n < s; n++)re(e, t[n], i); return i }(t || "*", r.nodeType ? [r] : r, []), g = !e || !a && t ? m : Ce(m, u, e, r, l), v = i ? s || (a ? e : f || n) ? [] : o : g; if (i && i(g, v, r, l), n) for (c = Ce(v, p), n(c, [], r, l), d = c.length; d--;)(h = c[d]) && (v[p[d]] = !(g[p[d]] = h)); if (a) { if (s || e) { if (s) { for (c = [], d = v.length; d--;)(h = v[d]) && c.push(g[d] = h); s(null, v = [], c, l) } for (d = v.length; d--;)(h = v[d]) && (c = s ? D(a, h) : u[d]) > -1 && (a[c] = !(o[c] = h)) } } else v = Ce(v === o ? v.splice(f, v.length) : v), s ? s(null, o, v, l) : O.apply(o, v) })) } function Te(e) { for (var t, i, s, a = e.length, o = n.relative[e[0].type], r = o || n.relative[" "], l = o ? 1 : 0, d = xe((function (e) { return e === t }), r, !0), h = xe((function (e) { return D(t, e) > -1 }), r, !0), u = [function (e, i, n) { var s = !o && (n || i !== c) || ((t = i).nodeType ? d(e, i, n) : h(e, i, n)); return t = null, s }]; l < a; l++)if (i = n.relative[e[l].type]) u = [xe(we(u), i)]; else { if ((i = n.filter[e[l].type].apply(null, e[l].matches))[x]) { for (s = ++l; s < a && !n.relative[e[s].type]; s++); return Ee(l > 1 && we(u), l > 1 && be(e.slice(0, l - 1).concat({ value: " " === e[l - 2].type ? "*" : "" })).replace(q, "$1"), i, l < s && Te(e.slice(l, s)), s < a && Te(e = e.slice(s)), s < a && be(e)) } u.push(i) } return we(u) } return ye.prototype = n.filters = n.pseudos, n.setFilters = new ye, o = re.tokenize = function (e, t) { var i, s, a, o, r, l, c, d = S[e + " "]; if (d) return t ? 0 : d.slice(0); for (r = e, l = [], c = n.preFilter; r;) { for (o in i && !(s = B.exec(r)) || (s && (r = r.slice(s[0].length) || r), l.push(a = [])), i = !1, (s = W.exec(r)) && (i = s.shift(), a.push({ value: i, type: s[0].replace(q, " ") }), r = r.slice(i.length)), n.filter) !(s = V[o].exec(r)) || c[o] && !(s = c[o](s)) || (i = s.shift(), a.push({ value: i, type: o, matches: s }), r = r.slice(i.length)); if (!i) break } return t ? r.length : r ? re.error(e) : S(e, l).slice(0) }, r = re.compile = function (e, t) { var i, s = [], a = [], r = $[e + " "]; if (!r) { for (t || (t = o(e)), i = t.length; i--;)(r = Te(t[i]))[x] ? s.push(r) : a.push(r); r = $(e, function (e, t) { var i = t.length > 0, s = e.length > 0, a = function (a, o, r, l, d) { var h, f, g, v = 0, y = "0", b = a && [], x = [], w = c, E = a || s && n.find.TAG("*", d), T = C += null == w ? 1 : Math.random() || .1, S = E.length; for (d && (c = o == p || o || d); y !== S && null != (h = E[y]); y++) { if (s && h) { for (f = 0, o || h.ownerDocument == p || (u(h), r = !m); g = e[f++];)if (g(h, o || p, r)) { l.push(h); break } d && (C = T) } i && ((h = !g && h) && v--, a && b.push(h)) } if (v += y, i && y !== v) { for (f = 0; g = t[f++];)g(b, x, o, r); if (a) { if (v > 0) for (; y--;)b[y] || x[y] || (x[y] = A.call(l)); x = Ce(x) } O.apply(l, x), d && !a && x.length > 0 && v + t.length > 1 && re.uniqueSort(l) } return d && (C = T, c = w), b }; return i ? ce(a) : a }(a, s)), r.selector = e } return r }, l = re.select = function (e, t, i, s) { var a, l, c, d, h, u = "function" == typeof e && e, p = !s && o(e = u.selector || e); if (i = i || [], 1 === p.length) { if ((l = p[0] = p[0].slice(0)).length > 2 && "ID" === (c = l[0]).type && 9 === t.nodeType && m && n.relative[l[1].type]) { if (!(t = (n.find.ID(c.matches[0].replace(te, ie), t) || [])[0])) return i; u && (t = t.parentNode), e = e.slice(l.shift().value.length) } for (a = V.needsContext.test(e) ? 0 : l.length; a-- && (c = l[a], !n.relative[d = c.type]);)if ((h = n.find[d]) && (s = h(c.matches[0].replace(te, ie), ee.test(l[0].type) && ve(t.parentNode) || t))) { if (l.splice(a, 1), !(e = s.length && be(l))) return O.apply(i, s), i; break } } return (u || r(e, p))(s, t, !m, i, !t || ee.test(e) && ve(t.parentNode) || t), i }, i.sortStable = x.split("").sort(P).join("") === x, i.detectDuplicates = !!h, u(), i.sortDetached = de((function (e) { return 1 & e.compareDocumentPosition(p.createElement("fieldset")) })), de((function (e) { return e.innerHTML = "<a href='#'></a>", "#" === e.firstChild.getAttribute("href") })) || he("type|href|height|width", (function (e, t, i) { if (!i) return e.getAttribute(t, "type" === t.toLowerCase() ? 1 : 2) })), i.attributes && de((function (e) { return e.innerHTML = "<input/>", e.firstChild.setAttribute("value", ""), "" === e.firstChild.getAttribute("value") })) || he("value", (function (e, t, i) { if (!i && "input" === e.nodeName.toLowerCase()) return e.defaultValue })), de((function (e) { return null == e.getAttribute("disabled") })) || he(_, (function (e, t, i) { var n; if (!i) return !0 === e[t] ? t.toLowerCase() : (n = e.getAttributeNode(t)) && n.specified ? n.value : null })), re }(n); T.find = $, T.expr = $.selectors, T.expr[":"] = T.expr.pseudos, T.uniqueSort = T.unique = $.uniqueSort, T.text = $.getText, T.isXMLDoc = $.isXML, T.contains = $.contains, T.escapeSelector = $.escape; var M = function (e, t, i) { for (var n = [], s = void 0 !== i; (e = e[t]) && 9 !== e.nodeType;)if (1 === e.nodeType) { if (s && T(e).is(i)) break; n.push(e) } return n }, P = function (e, t) { for (var i = []; e; e = e.nextSibling)1 === e.nodeType && e !== t && i.push(e); return i }, k = T.expr.match.needsContext; function L(e, t) { return e.nodeName && e.nodeName.toLowerCase() === t.toLowerCase() } var A = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i; function z(e, t, i) { return v(t) ? T.grep(e, (function (e, n) { return !!t.call(e, n, e) !== i })) : t.nodeType ? T.grep(e, (function (e) { return e === t !== i })) : "string" != typeof t ? T.grep(e, (function (e) { return d.call(t, e) > -1 !== i })) : T.filter(t, e, i) } T.filter = function (e, t, i) { var n = t[0]; return i && (e = ":not(" + e + ")"), 1 === t.length && 1 === n.nodeType ? T.find.matchesSelector(n, e) ? [n] : [] : T.find.matches(e, T.grep(t, (function (e) { return 1 === e.nodeType }))) }, T.fn.extend({ find: function (e) { var t, i, n = this.length, s = this; if ("string" != typeof e) return this.pushStack(T(e).filter((function () { for (t = 0; t < n; t++)if (T.contains(s[t], this)) return !0 }))); for (i = this.pushStack([]), t = 0; t < n; t++)T.find(e, s[t], i); return n > 1 ? T.uniqueSort(i) : i }, filter: function (e) { return this.pushStack(z(this, e || [], !1)) }, not: function (e) { return this.pushStack(z(this, e || [], !0)) }, is: function (e) { return !!z(this, "string" == typeof e && k.test(e) ? T(e) : e || [], !1).length } }); var O, I = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/; (T.fn.init = function (e, t, i) { var n, s; if (!e) return this; if (i = i || O, "string" == typeof e) { if (!(n = "<" === e[0] && ">" === e[e.length - 1] && e.length >= 3 ? [null, e, null] : I.exec(e)) || !n[1] && t) return !t || t.jquery ? (t || i).find(e) : this.constructor(t).find(e); if (n[1]) { if (t = t instanceof T ? t[0] : t, T.merge(this, T.parseHTML(n[1], t && t.nodeType ? t.ownerDocument || t : b, !0)), A.test(n[1]) && T.isPlainObject(t)) for (n in t) v(this[n]) ? this[n](t[n]) : this.attr(n, t[n]); return this } return (s = b.getElementById(n[2])) && (this[0] = s, this.length = 1), this } return e.nodeType ? (this[0] = e, this.length = 1, this) : v(e) ? void 0 !== i.ready ? i.ready(e) : e(T) : T.makeArray(e, this) }).prototype = T.fn, O = T(b); var D = /^(?:parents|prev(?:Until|All))/, _ = { children: !0, contents: !0, next: !0, prev: !0 }; function N(e, t) { for (; (e = e[t]) && 1 !== e.nodeType;); return e } T.fn.extend({ has: function (e) { var t = T(e, this), i = t.length; return this.filter((function () { for (var e = 0; e < i; e++)if (T.contains(this, t[e])) return !0 })) }, closest: function (e, t) { var i, n = 0, s = this.length, a = [], o = "string" != typeof e && T(e); if (!k.test(e)) for (; n < s; n++)for (i = this[n]; i && i !== t; i = i.parentNode)if (i.nodeType < 11 && (o ? o.index(i) > -1 : 1 === i.nodeType && T.find.matchesSelector(i, e))) { a.push(i); break } return this.pushStack(a.length > 1 ? T.uniqueSort(a) : a) }, index: function (e) { return e ? "string" == typeof e ? d.call(T(e), this[0]) : d.call(this, e.jquery ? e[0] : e) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1 }, add: function (e, t) { return this.pushStack(T.uniqueSort(T.merge(this.get(), T(e, t)))) }, addBack: function (e) { return this.add(null == e ? this.prevObject : this.prevObject.filter(e)) } }), T.each({ parent: function (e) { var t = e.parentNode; return t && 11 !== t.nodeType ? t : null }, parents: function (e) { return M(e, "parentNode") }, parentsUntil: function (e, t, i) { return M(e, "parentNode", i) }, next: function (e) { return N(e, "nextSibling") }, prev: function (e) { return N(e, "previousSibling") }, nextAll: function (e) { return M(e, "nextSibling") }, prevAll: function (e) { return M(e, "previousSibling") }, nextUntil: function (e, t, i) { return M(e, "nextSibling", i) }, prevUntil: function (e, t, i) { return M(e, "previousSibling", i) }, siblings: function (e) { return P((e.parentNode || {}).firstChild, e) }, children: function (e) { return P(e.firstChild) }, contents: function (e) { return null != e.contentDocument && o(e.contentDocument) ? e.contentDocument : (L(e, "template") && (e = e.content || e), T.merge([], e.childNodes)) } }, (function (e, t) { T.fn[e] = function (i, n) { var s = T.map(this, t, i); return "Until" !== e.slice(-5) && (n = i), n && "string" == typeof n && (s = T.filter(n, s)), this.length > 1 && (_[e] || T.uniqueSort(s), D.test(e) && s.reverse()), this.pushStack(s) } })); var R = /[^\x20\t\r\n\f]+/g; function H(e) { return e } function j(e) { throw e } function F(e, t, i, n) { var s; try { e && v(s = e.promise) ? s.call(e).done(t).fail(i) : e && v(s = e.then) ? s.call(e, t, i) : t.apply(void 0, [e].slice(n)) } catch (e) { i.apply(void 0, [e]) } } T.Callbacks = function (e) { e = "string" == typeof e ? function (e) { var t = {}; return T.each(e.match(R) || [], (function (e, i) { t[i] = !0 })), t }(e) : T.extend({}, e); var t, i, n, s, a = [], o = [], r = -1, l = function () { for (s = s || e.once, n = t = !0; o.length; r = -1)for (i = o.shift(); ++r < a.length;)!1 === a[r].apply(i[0], i[1]) && e.stopOnFalse && (r = a.length, i = !1); e.memory || (i = !1), t = !1, s && (a = i ? [] : "") }, c = { add: function () { return a && (i && !t && (r = a.length - 1, o.push(i)), function t(i) { T.each(i, (function (i, n) { v(n) ? e.unique && c.has(n) || a.push(n) : n && n.length && "string" !== C(n) && t(n) })) }(arguments), i && !t && l()), this }, remove: function () { return T.each(arguments, (function (e, t) { for (var i; (i = T.inArray(t, a, i)) > -1;)a.splice(i, 1), i <= r && r-- })), this }, has: function (e) { return e ? T.inArray(e, a) > -1 : a.length > 0 }, empty: function () { return a && (a = []), this }, disable: function () { return s = o = [], a = i = "", this }, disabled: function () { return !a }, lock: function () { return s = o = [], i || t || (a = i = ""), this }, locked: function () { return !!s }, fireWith: function (e, i) { return s || (i = [e, (i = i || []).slice ? i.slice() : i], o.push(i), t || l()), this }, fire: function () { return c.fireWith(this, arguments), this }, fired: function () { return !!n } }; return c }, T.extend({ Deferred: function (e) { var t = [["notify", "progress", T.Callbacks("memory"), T.Callbacks("memory"), 2], ["resolve", "done", T.Callbacks("once memory"), T.Callbacks("once memory"), 0, "resolved"], ["reject", "fail", T.Callbacks("once memory"), T.Callbacks("once memory"), 1, "rejected"]], i = "pending", s = { state: function () { return i }, always: function () { return a.done(arguments).fail(arguments), this }, catch: function (e) { return s.then(null, e) }, pipe: function () { var e = arguments; return T.Deferred((function (i) { T.each(t, (function (t, n) { var s = v(e[n[4]]) && e[n[4]]; a[n[1]]((function () { var e = s && s.apply(this, arguments); e && v(e.promise) ? e.promise().progress(i.notify).done(i.resolve).fail(i.reject) : i[n[0] + "With"](this, s ? [e] : arguments) })) })), e = null })).promise() }, then: function (e, i, s) { var a = 0; function o(e, t, i, s) { return function () { var r = this, l = arguments, c = function () { var n, c; if (!(e < a)) { if ((n = i.apply(r, l)) === t.promise()) throw new TypeError("Thenable self-resolution"); c = n && ("object" == typeof n || "function" == typeof n) && n.then, v(c) ? s ? c.call(n, o(a, t, H, s), o(a, t, j, s)) : (a++, c.call(n, o(a, t, H, s), o(a, t, j, s), o(a, t, H, t.notifyWith))) : (i !== H && (r = void 0, l = [n]), (s || t.resolveWith)(r, l)) } }, d = s ? c : function () { try { c() } catch (n) { T.Deferred.exceptionHook && T.Deferred.exceptionHook(n, d.stackTrace), e + 1 >= a && (i !== j && (r = void 0, l = [n]), t.rejectWith(r, l)) } }; e ? d() : (T.Deferred.getStackHook && (d.stackTrace = T.Deferred.getStackHook()), n.setTimeout(d)) } } return T.Deferred((function (n) { t[0][3].add(o(0, n, v(s) ? s : H, n.notifyWith)), t[1][3].add(o(0, n, v(e) ? e : H)), t[2][3].add(o(0, n, v(i) ? i : j)) })).promise() }, promise: function (e) { return null != e ? T.extend(e, s) : s } }, a = {}; return T.each(t, (function (e, n) { var o = n[2], r = n[5]; s[n[1]] = o.add, r && o.add((function () { i = r }), t[3 - e][2].disable, t[3 - e][3].disable, t[0][2].lock, t[0][3].lock), o.add(n[3].fire), a[n[0]] = function () { return a[n[0] + "With"](this === a ? void 0 : this, arguments), this }, a[n[0] + "With"] = o.fireWith })), s.promise(a), e && e.call(a, a), a }, when: function (e) { var t = arguments.length, i = t, n = Array(i), s = r.call(arguments), a = T.Deferred(), o = function (e) { return function (i) { n[e] = this, s[e] = arguments.length > 1 ? r.call(arguments) : i, --t || a.resolveWith(n, s) } }; if (t <= 1 && (F(e, a.done(o(i)).resolve, a.reject, !t), "pending" === a.state() || v(s[i] && s[i].then))) return a.then(); for (; i--;)F(s[i], o(i), a.reject); return a.promise() } }); var q = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/; T.Deferred.exceptionHook = function (e, t) { n.console && n.console.warn && e && q.test(e.name) && n.console.warn("jQuery.Deferred exception: " + e.message, e.stack, t) }, T.readyException = function (e) { n.setTimeout((function () { throw e })) }; var B = T.Deferred(); function W() { b.removeEventListener("DOMContentLoaded", W), n.removeEventListener("load", W), T.ready() } T.fn.ready = function (e) { return B.then(e).catch((function (e) { T.readyException(e) })), this }, T.extend({ isReady: !1, readyWait: 1, ready: function (e) { (!0 === e ? --T.readyWait : T.isReady) || (T.isReady = !0, !0 !== e && --T.readyWait > 0 || B.resolveWith(b, [T])) } }), T.ready.then = B.then, "complete" === b.readyState || "loading" !== b.readyState && !b.documentElement.doScroll ? n.setTimeout(T.ready) : (b.addEventListener("DOMContentLoaded", W), n.addEventListener("load", W)); var X = function (e, t, i, n, s, a, o) { var r = 0, l = e.length, c = null == i; if ("object" === C(i)) for (r in s = !0, i) X(e, t, r, i[r], !0, a, o); else if (void 0 !== n && (s = !0, v(n) || (o = !0), c && (o ? (t.call(e, n), t = null) : (c = t, t = function (e, t, i) { return c.call(T(e), i) })), t)) for (; r < l; r++)t(e[r], i, o ? n : n.call(e[r], r, t(e[r], i))); return s ? e : c ? t.call(e) : l ? t(e[0], i) : a }, Y = /^-ms-/, G = /-([a-z])/g; function V(e, t) { return t.toUpperCase() } function U(e) { return e.replace(Y, "ms-").replace(G, V) } var Z = function (e) { return 1 === e.nodeType || 9 === e.nodeType || !+e.nodeType }; function K() { this.expando = T.expando + K.uid++ } K.uid = 1, K.prototype = { cache: function (e) { var t = e[this.expando]; return t || (t = {}, Z(e) && (e.nodeType ? e[this.expando] = t : Object.defineProperty(e, this.expando, { value: t, configurable: !0 }))), t }, set: function (e, t, i) { var n, s = this.cache(e); if ("string" == typeof t) s[U(t)] = i; else for (n in t) s[U(n)] = t[n]; return s }, get: function (e, t) { return void 0 === t ? this.cache(e) : e[this.expando] && e[this.expando][U(t)] }, access: function (e, t, i) { return void 0 === t || t && "string" == typeof t && void 0 === i ? this.get(e, t) : (this.set(e, t, i), void 0 !== i ? i : t) }, remove: function (e, t) { var i, n = e[this.expando]; if (void 0 !== n) { if (void 0 !== t) { i = (t = Array.isArray(t) ? t.map(U) : (t = U(t)) in n ? [t] : t.match(R) || []).length; for (; i--;)delete n[t[i]] } (void 0 === t || T.isEmptyObject(n)) && (e.nodeType ? e[this.expando] = void 0 : delete e[this.expando]) } }, hasData: function (e) { var t = e[this.expando]; return void 0 !== t && !T.isEmptyObject(t) } }; var J = new K, Q = new K, ee = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, te = /[A-Z]/g; function ie(e, t, i) { var n; if (void 0 === i && 1 === e.nodeType) if (n = "data-" + t.replace(te, "-$&").toLowerCase(), "string" == typeof (i = e.getAttribute(n))) { try { i = function (e) { return "true" === e || "false" !== e && ("null" === e ? null : e === +e + "" ? +e : ee.test(e) ? JSON.parse(e) : e) }(i) } catch (e) { } Q.set(e, t, i) } else i = void 0; return i } T.extend({ hasData: function (e) { return Q.hasData(e) || J.hasData(e) }, data: function (e, t, i) { return Q.access(e, t, i) }, removeData: function (e, t) { Q.remove(e, t) }, _data: function (e, t, i) { return J.access(e, t, i) }, _removeData: function (e, t) { J.remove(e, t) } }), T.fn.extend({ data: function (e, t) { var i, n, s, a = this[0], o = a && a.attributes; if (void 0 === e) { if (this.length && (s = Q.get(a), 1 === a.nodeType && !J.get(a, "hasDataAttrs"))) { for (i = o.length; i--;)o[i] && 0 === (n = o[i].name).indexOf("data-") && (n = U(n.slice(5)), ie(a, n, s[n])); J.set(a, "hasDataAttrs", !0) } return s } return "object" == typeof e ? this.each((function () { Q.set(this, e) })) : X(this, (function (t) { var i; if (a && void 0 === t) return void 0 !== (i = Q.get(a, e)) || void 0 !== (i = ie(a, e)) ? i : void 0; this.each((function () { Q.set(this, e, t) })) }), null, t, arguments.length > 1, null, !0) }, removeData: function (e) { return this.each((function () { Q.remove(this, e) })) } }), T.extend({ queue: function (e, t, i) { var n; if (e) return t = (t || "fx") + "queue", n = J.get(e, t), i && (!n || Array.isArray(i) ? n = J.access(e, t, T.makeArray(i)) : n.push(i)), n || [] }, dequeue: function (e, t) { t = t || "fx"; var i = T.queue(e, t), n = i.length, s = i.shift(), a = T._queueHooks(e, t); "inprogress" === s && (s = i.shift(), n--), s && ("fx" === t && i.unshift("inprogress"), delete a.stop, s.call(e, (function () { T.dequeue(e, t) }), a)), !n && a && a.empty.fire() }, _queueHooks: function (e, t) { var i = t + "queueHooks"; return J.get(e, i) || J.access(e, i, { empty: T.Callbacks("once memory").add((function () { J.remove(e, [t + "queue", i]) })) }) } }), T.fn.extend({ queue: function (e, t) { var i = 2; return "string" != typeof e && (t = e, e = "fx", i--), arguments.length < i ? T.queue(this[0], e) : void 0 === t ? this : this.each((function () { var i = T.queue(this, e, t); T._queueHooks(this, e), "fx" === e && "inprogress" !== i[0] && T.dequeue(this, e) })) }, dequeue: function (e) { return this.each((function () { T.dequeue(this, e) })) }, clearQueue: function (e) { return this.queue(e || "fx", []) }, promise: function (e, t) { var i, n = 1, s = T.Deferred(), a = this, o = this.length, r = function () { --n || s.resolveWith(a, [a]) }; for ("string" != typeof e && (t = e, e = void 0), e = e || "fx"; o--;)(i = J.get(a[o], e + "queueHooks")) && i.empty && (n++, i.empty.add(r)); return r(), s.promise(t) } }); var ne = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source, se = new RegExp("^(?:([+-])=|)(" + ne + ")([a-z%]*)$", "i"), ae = ["Top", "Right", "Bottom", "Left"], oe = b.documentElement, re = function (e) { return T.contains(e.ownerDocument, e) }, le = { composed: !0 }; oe.getRootNode && (re = function (e) { return T.contains(e.ownerDocument, e) || e.getRootNode(le) === e.ownerDocument }); var ce = function (e, t) { return "none" === (e = t || e).style.display || "" === e.style.display && re(e) && "none" === T.css(e, "display") }; function de(e, t, i, n) { var s, a, o = 20, r = n ? function () { return n.cur() } : function () { return T.css(e, t, "") }, l = r(), c = i && i[3] || (T.cssNumber[t] ? "" : "px"), d = e.nodeType && (T.cssNumber[t] || "px" !== c && +l) && se.exec(T.css(e, t)); if (d && d[3] !== c) { for (l /= 2, c = c || d[3], d = +l || 1; o--;)T.style(e, t, d + c), (1 - a) * (1 - (a = r() / l || .5)) <= 0 && (o = 0), d /= a; d *= 2, T.style(e, t, d + c), i = i || [] } return i && (d = +d || +l || 0, s = i[1] ? d + (i[1] + 1) * i[2] : +i[2], n && (n.unit = c, n.start = d, n.end = s)), s } var he = {}; function ue(e) { var t, i = e.ownerDocument, n = e.nodeName, s = he[n]; return s || (t = i.body.appendChild(i.createElement(n)), s = T.css(t, "display"), t.parentNode.removeChild(t), "none" === s && (s = "block"), he[n] = s, s) } function pe(e, t) { for (var i, n, s = [], a = 0, o = e.length; a < o; a++)(n = e[a]).style && (i = n.style.display, t ? ("none" === i && (s[a] = J.get(n, "display") || null, s[a] || (n.style.display = "")), "" === n.style.display && ce(n) && (s[a] = ue(n))) : "none" !== i && (s[a] = "none", J.set(n, "display", i))); for (a = 0; a < o; a++)null != s[a] && (e[a].style.display = s[a]); return e } T.fn.extend({ show: function () { return pe(this, !0) }, hide: function () { return pe(this) }, toggle: function (e) { return "boolean" == typeof e ? e ? this.show() : this.hide() : this.each((function () { ce(this) ? T(this).show() : T(this).hide() })) } }); var fe, me, ge = /^(?:checkbox|radio)$/i, ve = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i, ye = /^$|^module$|\/(?:java|ecma)script/i; fe = b.createDocumentFragment().appendChild(b.createElement("div")), (me = b.createElement("input")).setAttribute("type", "radio"), me.setAttribute("checked", "checked"), me.setAttribute("name", "t"), fe.appendChild(me), g.checkClone = fe.cloneNode(!0).cloneNode(!0).lastChild.checked, fe.innerHTML = "<textarea>x</textarea>", g.noCloneChecked = !!fe.cloneNode(!0).lastChild.defaultValue, fe.innerHTML = "<option></option>", g.option = !!fe.lastChild; var be = { thead: [1, "<table>", "</table>"], col: [2, "<table><colgroup>", "</colgroup></table>"], tr: [2, "<table><tbody>", "</tbody></table>"], td: [3, "<table><tbody><tr>", "</tr></tbody></table>"], _default: [0, "", ""] }; function xe(e, t) { var i; return i = void 0 !== e.getElementsByTagName ? e.getElementsByTagName(t || "*") : void 0 !== e.querySelectorAll ? e.querySelectorAll(t || "*") : [], void 0 === t || t && L(e, t) ? T.merge([e], i) : i } function we(e, t) { for (var i = 0, n = e.length; i < n; i++)J.set(e[i], "globalEval", !t || J.get(t[i], "globalEval")) } be.tbody = be.tfoot = be.colgroup = be.caption = be.thead, be.th = be.td, g.option || (be.optgroup = be.option = [1, "<select multiple='multiple'>", "</select>"]); var Ce = /<|&#?\w+;/; function Ee(e, t, i, n, s) { for (var a, o, r, l, c, d, h = t.createDocumentFragment(), u = [], p = 0, f = e.length; p < f; p++)if ((a = e[p]) || 0 === a) if ("object" === C(a)) T.merge(u, a.nodeType ? [a] : a); else if (Ce.test(a)) { for (o = o || h.appendChild(t.createElement("div")), r = (ve.exec(a) || ["", ""])[1].toLowerCase(), l = be[r] || be._default, o.innerHTML = l[1] + T.htmlPrefilter(a) + l[2], d = l[0]; d--;)o = o.lastChild; T.merge(u, o.childNodes), (o = h.firstChild).textContent = "" } else u.push(t.createTextNode(a)); for (h.textContent = "", p = 0; a = u[p++];)if (n && T.inArray(a, n) > -1) s && s.push(a); else if (c = re(a), o = xe(h.appendChild(a), "script"), c && we(o), i) for (d = 0; a = o[d++];)ye.test(a.type || "") && i.push(a); return h } var Te = /^([^.]*)(?:\.(.+)|)/; function Se() { return !0 } function $e() { return !1 } function Me(e, t) { return e === function () { try { return b.activeElement } catch (e) { } }() == ("focus" === t) } function Pe(e, t, i, n, s, a) { var o, r; if ("object" == typeof t) { for (r in "string" != typeof i && (n = n || i, i = void 0), t) Pe(e, r, i, n, t[r], a); return e } if (null == n && null == s ? (s = i, n = i = void 0) : null == s && ("string" == typeof i ? (s = n, n = void 0) : (s = n, n = i, i = void 0)), !1 === s) s = $e; else if (!s) return e; return 1 === a && (o = s, s = function (e) { return T().off(e), o.apply(this, arguments) }, s.guid = o.guid || (o.guid = T.guid++)), e.each((function () { T.event.add(this, t, s, n, i) })) } function ke(e, t, i) { i ? (J.set(e, t, !1), T.event.add(e, t, { namespace: !1, handler: function (e) { var n, s, a = J.get(this, t); if (1 & e.isTrigger && this[t]) { if (a.length) (T.event.special[t] || {}).delegateType && e.stopPropagation(); else if (a = r.call(arguments), J.set(this, t, a), n = i(this, t), this[t](), a !== (s = J.get(this, t)) || n ? J.set(this, t, !1) : s = {}, a !== s) return e.stopImmediatePropagation(), e.preventDefault(), s && s.value } else a.length && (J.set(this, t, { value: T.event.trigger(T.extend(a[0], T.Event.prototype), a.slice(1), this) }), e.stopImmediatePropagation()) } })) : void 0 === J.get(e, t) && T.event.add(e, t, Se) } T.event = { global: {}, add: function (e, t, i, n, s) { var a, o, r, l, c, d, h, u, p, f, m, g = J.get(e); if (Z(e)) for (i.handler && (i = (a = i).handler, s = a.selector), s && T.find.matchesSelector(oe, s), i.guid || (i.guid = T.guid++), (l = g.events) || (l = g.events = Object.create(null)), (o = g.handle) || (o = g.handle = function (t) { return void 0 !== T && T.event.triggered !== t.type ? T.event.dispatch.apply(e, arguments) : void 0 }), c = (t = (t || "").match(R) || [""]).length; c--;)p = m = (r = Te.exec(t[c]) || [])[1], f = (r[2] || "").split(".").sort(), p && (h = T.event.special[p] || {}, p = (s ? h.delegateType : h.bindType) || p, h = T.event.special[p] || {}, d = T.extend({ type: p, origType: m, data: n, handler: i, guid: i.guid, selector: s, needsContext: s && T.expr.match.needsContext.test(s), namespace: f.join(".") }, a), (u = l[p]) || ((u = l[p] = []).delegateCount = 0, h.setup && !1 !== h.setup.call(e, n, f, o) || e.addEventListener && e.addEventListener(p, o)), h.add && (h.add.call(e, d), d.handler.guid || (d.handler.guid = i.guid)), s ? u.splice(u.delegateCount++, 0, d) : u.push(d), T.event.global[p] = !0) }, remove: function (e, t, i, n, s) { var a, o, r, l, c, d, h, u, p, f, m, g = J.hasData(e) && J.get(e); if (g && (l = g.events)) { for (c = (t = (t || "").match(R) || [""]).length; c--;)if (p = m = (r = Te.exec(t[c]) || [])[1], f = (r[2] || "").split(".").sort(), p) { for (h = T.event.special[p] || {}, u = l[p = (n ? h.delegateType : h.bindType) || p] || [], r = r[2] && new RegExp("(^|\\.)" + f.join("\\.(?:.*\\.|)") + "(\\.|$)"), o = a = u.length; a--;)d = u[a], !s && m !== d.origType || i && i.guid !== d.guid || r && !r.test(d.namespace) || n && n !== d.selector && ("**" !== n || !d.selector) || (u.splice(a, 1), d.selector && u.delegateCount--, h.remove && h.remove.call(e, d)); o && !u.length && (h.teardown && !1 !== h.teardown.call(e, f, g.handle) || T.removeEvent(e, p, g.handle), delete l[p]) } else for (p in l) T.event.remove(e, p + t[c], i, n, !0); T.isEmptyObject(l) && J.remove(e, "handle events") } }, dispatch: function (e) { var t, i, n, s, a, o, r = new Array(arguments.length), l = T.event.fix(e), c = (J.get(this, "events") || Object.create(null))[l.type] || [], d = T.event.special[l.type] || {}; for (r[0] = l, t = 1; t < arguments.length; t++)r[t] = arguments[t]; if (l.delegateTarget = this, !d.preDispatch || !1 !== d.preDispatch.call(this, l)) { for (o = T.event.handlers.call(this, l, c), t = 0; (s = o[t++]) && !l.isPropagationStopped();)for (l.currentTarget = s.elem, i = 0; (a = s.handlers[i++]) && !l.isImmediatePropagationStopped();)l.rnamespace && !1 !== a.namespace && !l.rnamespace.test(a.namespace) || (l.handleObj = a, l.data = a.data, void 0 !== (n = ((T.event.special[a.origType] || {}).handle || a.handler).apply(s.elem, r)) && !1 === (l.result = n) && (l.preventDefault(), l.stopPropagation())); return d.postDispatch && d.postDispatch.call(this, l), l.result } }, handlers: function (e, t) { var i, n, s, a, o, r = [], l = t.delegateCount, c = e.target; if (l && c.nodeType && !("click" === e.type && e.button >= 1)) for (; c !== this; c = c.parentNode || this)if (1 === c.nodeType && ("click" !== e.type || !0 !== c.disabled)) { for (a = [], o = {}, i = 0; i < l; i++)void 0 === o[s = (n = t[i]).selector + " "] && (o[s] = n.needsContext ? T(s, this).index(c) > -1 : T.find(s, this, null, [c]).length), o[s] && a.push(n); a.length && r.push({ elem: c, handlers: a }) } return c = this, l < t.length && r.push({ elem: c, handlers: t.slice(l) }), r }, addProp: function (e, t) { Object.defineProperty(T.Event.prototype, e, { enumerable: !0, configurable: !0, get: v(t) ? function () { if (this.originalEvent) return t(this.originalEvent) } : function () { if (this.originalEvent) return this.originalEvent[e] }, set: function (t) { Object.defineProperty(this, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) } }) }, fix: function (e) { return e[T.expando] ? e : new T.Event(e) }, special: { load: { noBubble: !0 }, click: { setup: function (e) { var t = this || e; return ge.test(t.type) && t.click && L(t, "input") && ke(t, "click", Se), !1 }, trigger: function (e) { var t = this || e; return ge.test(t.type) && t.click && L(t, "input") && ke(t, "click"), !0 }, _default: function (e) { var t = e.target; return ge.test(t.type) && t.click && L(t, "input") && J.get(t, "click") || L(t, "a") } }, beforeunload: { postDispatch: function (e) { void 0 !== e.result && e.originalEvent && (e.originalEvent.returnValue = e.result) } } } }, T.removeEvent = function (e, t, i) { e.removeEventListener && e.removeEventListener(t, i) }, T.Event = function (e, t) { if (!(this instanceof T.Event)) return new T.Event(e, t); e && e.type ? (this.originalEvent = e, this.type = e.type, this.isDefaultPrevented = e.defaultPrevented || void 0 === e.defaultPrevented && !1 === e.returnValue ? Se : $e, this.target = e.target && 3 === e.target.nodeType ? e.target.parentNode : e.target, this.currentTarget = e.currentTarget, this.relatedTarget = e.relatedTarget) : this.type = e, t && T.extend(this, t), this.timeStamp = e && e.timeStamp || Date.now(), this[T.expando] = !0 }, T.Event.prototype = { constructor: T.Event, isDefaultPrevented: $e, isPropagationStopped: $e, isImmediatePropagationStopped: $e, isSimulated: !1, preventDefault: function () { var e = this.originalEvent; this.isDefaultPrevented = Se, e && !this.isSimulated && e.preventDefault() }, stopPropagation: function () { var e = this.originalEvent; this.isPropagationStopped = Se, e && !this.isSimulated && e.stopPropagation() }, stopImmediatePropagation: function () { var e = this.originalEvent; this.isImmediatePropagationStopped = Se, e && !this.isSimulated && e.stopImmediatePropagation(), this.stopPropagation() } }, T.each({ altKey: !0, bubbles: !0, cancelable: !0, changedTouches: !0, ctrlKey: !0, detail: !0, eventPhase: !0, metaKey: !0, pageX: !0, pageY: !0, shiftKey: !0, view: !0, char: !0, code: !0, charCode: !0, key: !0, keyCode: !0, button: !0, buttons: !0, clientX: !0, clientY: !0, offsetX: !0, offsetY: !0, pointerId: !0, pointerType: !0, screenX: !0, screenY: !0, targetTouches: !0, toElement: !0, touches: !0, which: !0 }, T.event.addProp), T.each({ focus: "focusin", blur: "focusout" }, (function (e, t) { T.event.special[e] = { setup: function () { return ke(this, e, Me), !1 }, trigger: function () { return ke(this, e), !0 }, _default: function (t) { return J.get(t.target, e) }, delegateType: t } })), T.each({ mouseenter: "mouseover", mouseleave: "mouseout", pointerenter: "pointerover", pointerleave: "pointerout" }, (function (e, t) { T.event.special[e] = { delegateType: t, bindType: t, handle: function (e) { var i, n = this, s = e.relatedTarget, a = e.handleObj; return s && (s === n || T.contains(n, s)) || (e.type = a.origType, i = a.handler.apply(this, arguments), e.type = t), i } } })), T.fn.extend({ on: function (e, t, i, n) { return Pe(this, e, t, i, n) }, one: function (e, t, i, n) { return Pe(this, e, t, i, n, 1) }, off: function (e, t, i) { var n, s; if (e && e.preventDefault && e.handleObj) return n = e.handleObj, T(e.delegateTarget).off(n.namespace ? n.origType + "." + n.namespace : n.origType, n.selector, n.handler), this; if ("object" == typeof e) { for (s in e) this.off(s, t, e[s]); return this } return !1 !== t && "function" != typeof t || (i = t, t = void 0), !1 === i && (i = $e), this.each((function () { T.event.remove(this, e, i, t) })) } }); var Le = /<script|<style|<link/i, Ae = /checked\s*(?:[^=]|=\s*.checked.)/i, ze = /^\s*<!\[CDATA\[|\]\]>\s*$/g; function Oe(e, t) { return L(e, "table") && L(11 !== t.nodeType ? t : t.firstChild, "tr") && T(e).children("tbody")[0] || e } function Ie(e) { return e.type = (null !== e.getAttribute("type")) + "/" + e.type, e } function De(e) { return "true/" === (e.type || "").slice(0, 5) ? e.type = e.type.slice(5) : e.removeAttribute("type"), e } function _e(e, t) { var i, n, s, a, o, r; if (1 === t.nodeType) { if (J.hasData(e) && (r = J.get(e).events)) for (s in J.remove(t, "handle events"), r) for (i = 0, n = r[s].length; i < n; i++)T.event.add(t, s, r[s][i]); Q.hasData(e) && (a = Q.access(e), o = T.extend({}, a), Q.set(t, o)) } } function Ne(e, t) { var i = t.nodeName.toLowerCase(); "input" === i && ge.test(e.type) ? t.checked = e.checked : "input" !== i && "textarea" !== i || (t.defaultValue = e.defaultValue) } function Re(e, t, i, n) { t = l(t); var s, a, o, r, c, d, h = 0, u = e.length, p = u - 1, f = t[0], m = v(f); if (m || u > 1 && "string" == typeof f && !g.checkClone && Ae.test(f)) return e.each((function (s) { var a = e.eq(s); m && (t[0] = f.call(this, s, a.html())), Re(a, t, i, n) })); if (u && (a = (s = Ee(t, e[0].ownerDocument, !1, e, n)).firstChild, 1 === s.childNodes.length && (s = a), a || n)) { for (r = (o = T.map(xe(s, "script"), Ie)).length; h < u; h++)c = s, h !== p && (c = T.clone(c, !0, !0), r && T.merge(o, xe(c, "script"))), i.call(e[h], c, h); if (r) for (d = o[o.length - 1].ownerDocument, T.map(o, De), h = 0; h < r; h++)c = o[h], ye.test(c.type || "") && !J.access(c, "globalEval") && T.contains(d, c) && (c.src && "module" !== (c.type || "").toLowerCase() ? T._evalUrl && !c.noModule && T._evalUrl(c.src, { nonce: c.nonce || c.getAttribute("nonce") }, d) : w(c.textContent.replace(ze, ""), c, d)) } return e } function He(e, t, i) { for (var n, s = t ? T.filter(t, e) : e, a = 0; null != (n = s[a]); a++)i || 1 !== n.nodeType || T.cleanData(xe(n)), n.parentNode && (i && re(n) && we(xe(n, "script")), n.parentNode.removeChild(n)); return e } T.extend({ htmlPrefilter: function (e) { return e }, clone: function (e, t, i) { var n, s, a, o, r = e.cloneNode(!0), l = re(e); if (!(g.noCloneChecked || 1 !== e.nodeType && 11 !== e.nodeType || T.isXMLDoc(e))) for (o = xe(r), n = 0, s = (a = xe(e)).length; n < s; n++)Ne(a[n], o[n]); if (t) if (i) for (a = a || xe(e), o = o || xe(r), n = 0, s = a.length; n < s; n++)_e(a[n], o[n]); else _e(e, r); return (o = xe(r, "script")).length > 0 && we(o, !l && xe(e, "script")), r }, cleanData: function (e) { for (var t, i, n, s = T.event.special, a = 0; void 0 !== (i = e[a]); a++)if (Z(i)) { if (t = i[J.expando]) { if (t.events) for (n in t.events) s[n] ? T.event.remove(i, n) : T.removeEvent(i, n, t.handle); i[J.expando] = void 0 } i[Q.expando] && (i[Q.expando] = void 0) } } }), T.fn.extend({ detach: function (e) { return He(this, e, !0) }, remove: function (e) { return He(this, e) }, text: function (e) { return X(this, (function (e) { return void 0 === e ? T.text(this) : this.empty().each((function () { 1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || (this.textContent = e) })) }), null, e, arguments.length) }, append: function () { return Re(this, arguments, (function (e) { 1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || Oe(this, e).appendChild(e) })) }, prepend: function () { return Re(this, arguments, (function (e) { if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) { var t = Oe(this, e); t.insertBefore(e, t.firstChild) } })) }, before: function () { return Re(this, arguments, (function (e) { this.parentNode && this.parentNode.insertBefore(e, this) })) }, after: function () { return Re(this, arguments, (function (e) { this.parentNode && this.parentNode.insertBefore(e, this.nextSibling) })) }, empty: function () { for (var e, t = 0; null != (e = this[t]); t++)1 === e.nodeType && (T.cleanData(xe(e, !1)), e.textContent = ""); return this }, clone: function (e, t) { return e = null != e && e, t = null == t ? e : t, this.map((function () { return T.clone(this, e, t) })) }, html: function (e) { return X(this, (function (e) { var t = this[0] || {}, i = 0, n = this.length; if (void 0 === e && 1 === t.nodeType) return t.innerHTML; if ("string" == typeof e && !Le.test(e) && !be[(ve.exec(e) || ["", ""])[1].toLowerCase()]) { e = T.htmlPrefilter(e); try { for (; i < n; i++)1 === (t = this[i] || {}).nodeType && (T.cleanData(xe(t, !1)), t.innerHTML = e); t = 0 } catch (e) { } } t && this.empty().append(e) }), null, e, arguments.length) }, replaceWith: function () { var e = []; return Re(this, arguments, (function (t) { var i = this.parentNode; T.inArray(this, e) < 0 && (T.cleanData(xe(this)), i && i.replaceChild(t, this)) }), e) } }), T.each({ appendTo: "append", prependTo: "prepend", insertBefore: "before", insertAfter: "after", replaceAll: "replaceWith" }, (function (e, t) { T.fn[e] = function (e) { for (var i, n = [], s = T(e), a = s.length - 1, o = 0; o <= a; o++)i = o === a ? this : this.clone(!0), T(s[o])[t](i), c.apply(n, i.get()); return this.pushStack(n) } })); var je = new RegExp("^(" + ne + ")(?!px)[a-z%]+$", "i"), Fe = /^--/, qe = function (e) { var t = e.ownerDocument.defaultView; return t && t.opener || (t = n), t.getComputedStyle(e) }, Be = function (e, t, i) { var n, s, a = {}; for (s in t) a[s] = e.style[s], e.style[s] = t[s]; for (s in n = i.call(e), t) e.style[s] = a[s]; return n }, We = new RegExp(ae.join("|"), "i"), Xe = "[\\x20\\t\\r\\n\\f]", Ye = new RegExp("^" + Xe + "+|((?:^|[^\\\\])(?:\\\\.)*)" + Xe + "+$", "g"); function Ge(e, t, i) { var n, s, a, o, r = Fe.test(t), l = e.style; return (i = i || qe(e)) && (o = i.getPropertyValue(t) || i[t], r && o && (o = o.replace(Ye, "$1") || void 0), "" !== o || re(e) || (o = T.style(e, t)), !g.pixelBoxStyles() && je.test(o) && We.test(t) && (n = l.width, s = l.minWidth, a = l.maxWidth, l.minWidth = l.maxWidth = l.width = o, o = i.width, l.width = n, l.minWidth = s, l.maxWidth = a)), void 0 !== o ? o + "" : o } function Ve(e, t) { return { get: function () { if (!e()) return (this.get = t).apply(this, arguments); delete this.get } } } !function () { function e() { if (d) { c.style.cssText = "position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0", d.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%", oe.appendChild(c).appendChild(d); var e = n.getComputedStyle(d); i = "1%" !== e.top, l = 12 === t(e.marginLeft), d.style.right = "60%", o = 36 === t(e.right), s = 36 === t(e.width), d.style.position = "absolute", a = 12 === t(d.offsetWidth / 3), oe.removeChild(c), d = null } } function t(e) { return Math.round(parseFloat(e)) } var i, s, a, o, r, l, c = b.createElement("div"), d = b.createElement("div"); d.style && (d.style.backgroundClip = "content-box", d.cloneNode(!0).style.backgroundClip = "", g.clearCloneStyle = "content-box" === d.style.backgroundClip, T.extend(g, { boxSizingReliable: function () { return e(), s }, pixelBoxStyles: function () { return e(), o }, pixelPosition: function () { return e(), i }, reliableMarginLeft: function () { return e(), l }, scrollboxSize: function () { return e(), a }, reliableTrDimensions: function () { var e, t, i, s; return null == r && (e = b.createElement("table"), t = b.createElement("tr"), i = b.createElement("div"), e.style.cssText = "position:absolute;left:-11111px;border-collapse:separate", t.style.cssText = "border:1px solid", t.style.height = "1px", i.style.height = "9px", i.style.display = "block", oe.appendChild(e).appendChild(t).appendChild(i), s = n.getComputedStyle(t), r = parseInt(s.height, 10) + parseInt(s.borderTopWidth, 10) + parseInt(s.borderBottomWidth, 10) === t.offsetHeight, oe.removeChild(e)), r } })) }(); var Ue = ["Webkit", "Moz", "ms"], Ze = b.createElement("div").style, Ke = {}; function Je(e) { var t = T.cssProps[e] || Ke[e]; return t || (e in Ze ? e : Ke[e] = function (e) { for (var t = e[0].toUpperCase() + e.slice(1), i = Ue.length; i--;)if ((e = Ue[i] + t) in Ze) return e }(e) || e) } var Qe = /^(none|table(?!-c[ea]).+)/, et = { position: "absolute", visibility: "hidden", display: "block" }, tt = { letterSpacing: "0", fontWeight: "400" }; function it(e, t, i) { var n = se.exec(t); return n ? Math.max(0, n[2] - (i || 0)) + (n[3] || "px") : t } function nt(e, t, i, n, s, a) { var o = "width" === t ? 1 : 0, r = 0, l = 0; if (i === (n ? "border" : "content")) return 0; for (; o < 4; o += 2)"margin" === i && (l += T.css(e, i + ae[o], !0, s)), n ? ("content" === i && (l -= T.css(e, "padding" + ae[o], !0, s)), "margin" !== i && (l -= T.css(e, "border" + ae[o] + "Width", !0, s))) : (l += T.css(e, "padding" + ae[o], !0, s), "padding" !== i ? l += T.css(e, "border" + ae[o] + "Width", !0, s) : r += T.css(e, "border" + ae[o] + "Width", !0, s)); return !n && a >= 0 && (l += Math.max(0, Math.ceil(e["offset" + t[0].toUpperCase() + t.slice(1)] - a - l - r - .5)) || 0), l } function st(e, t, i) { var n = qe(e), s = (!g.boxSizingReliable() || i) && "border-box" === T.css(e, "boxSizing", !1, n), a = s, o = Ge(e, t, n), r = "offset" + t[0].toUpperCase() + t.slice(1); if (je.test(o)) { if (!i) return o; o = "auto" } return (!g.boxSizingReliable() && s || !g.reliableTrDimensions() && L(e, "tr") || "auto" === o || !parseFloat(o) && "inline" === T.css(e, "display", !1, n)) && e.getClientRects().length && (s = "border-box" === T.css(e, "boxSizing", !1, n), (a = r in e) && (o = e[r])), (o = parseFloat(o) || 0) + nt(e, t, i || (s ? "border" : "content"), a, n, o) + "px" } function at(e, t, i, n, s) { return new at.prototype.init(e, t, i, n, s) } T.extend({ cssHooks: { opacity: { get: function (e, t) { if (t) { var i = Ge(e, "opacity"); return "" === i ? "1" : i } } } }, cssNumber: { animationIterationCount: !0, columnCount: !0, fillOpacity: !0, flexGrow: !0, flexShrink: !0, fontWeight: !0, gridArea: !0, gridColumn: !0, gridColumnEnd: !0, gridColumnStart: !0, gridRow: !0, gridRowEnd: !0, gridRowStart: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, widows: !0, zIndex: !0, zoom: !0 }, cssProps: {}, style: function (e, t, i, n) { if (e && 3 !== e.nodeType && 8 !== e.nodeType && e.style) { var s, a, o, r = U(t), l = Fe.test(t), c = e.style; if (l || (t = Je(r)), o = T.cssHooks[t] || T.cssHooks[r], void 0 === i) return o && "get" in o && void 0 !== (s = o.get(e, !1, n)) ? s : c[t]; "string" === (a = typeof i) && (s = se.exec(i)) && s[1] && (i = de(e, t, s), a = "number"), null != i && i == i && ("number" !== a || l || (i += s && s[3] || (T.cssNumber[r] ? "" : "px")), g.clearCloneStyle || "" !== i || 0 !== t.indexOf("background") || (c[t] = "inherit"), o && "set" in o && void 0 === (i = o.set(e, i, n)) || (l ? c.setProperty(t, i) : c[t] = i)) } }, css: function (e, t, i, n) { var s, a, o, r = U(t); return Fe.test(t) || (t = Je(r)), (o = T.cssHooks[t] || T.cssHooks[r]) && "get" in o && (s = o.get(e, !0, i)), void 0 === s && (s = Ge(e, t, n)), "normal" === s && t in tt && (s = tt[t]), "" === i || i ? (a = parseFloat(s), !0 === i || isFinite(a) ? a || 0 : s) : s } }), T.each(["height", "width"], (function (e, t) { T.cssHooks[t] = { get: function (e, i, n) { if (i) return !Qe.test(T.css(e, "display")) || e.getClientRects().length && e.getBoundingClientRect().width ? st(e, t, n) : Be(e, et, (function () { return st(e, t, n) })) }, set: function (e, i, n) { var s, a = qe(e), o = !g.scrollboxSize() && "absolute" === a.position, r = (o || n) && "border-box" === T.css(e, "boxSizing", !1, a), l = n ? nt(e, t, n, r, a) : 0; return r && o && (l -= Math.ceil(e["offset" + t[0].toUpperCase() + t.slice(1)] - parseFloat(a[t]) - nt(e, t, "border", !1, a) - .5)), l && (s = se.exec(i)) && "px" !== (s[3] || "px") && (e.style[t] = i, i = T.css(e, t)), it(0, i, l) } } })), T.cssHooks.marginLeft = Ve(g.reliableMarginLeft, (function (e, t) { if (t) return (parseFloat(Ge(e, "marginLeft")) || e.getBoundingClientRect().left - Be(e, { marginLeft: 0 }, (function () { return e.getBoundingClientRect().left }))) + "px" })), T.each({ margin: "", padding: "", border: "Width" }, (function (e, t) { T.cssHooks[e + t] = { expand: function (i) { for (var n = 0, s = {}, a = "string" == typeof i ? i.split(" ") : [i]; n < 4; n++)s[e + ae[n] + t] = a[n] || a[n - 2] || a[0]; return s } }, "margin" !== e && (T.cssHooks[e + t].set = it) })), T.fn.extend({ css: function (e, t) { return X(this, (function (e, t, i) { var n, s, a = {}, o = 0; if (Array.isArray(t)) { for (n = qe(e), s = t.length; o < s; o++)a[t[o]] = T.css(e, t[o], !1, n); return a } return void 0 !== i ? T.style(e, t, i) : T.css(e, t) }), e, t, arguments.length > 1) } }), T.Tween = at, at.prototype = { constructor: at, init: function (e, t, i, n, s, a) { this.elem = e, this.prop = i, this.easing = s || T.easing._default, this.options = t, this.start = this.now = this.cur(), this.end = n, this.unit = a || (T.cssNumber[i] ? "" : "px") }, cur: function () { var e = at.propHooks[this.prop]; return e && e.get ? e.get(this) : at.propHooks._default.get(this) }, run: function (e) { var t, i = at.propHooks[this.prop]; return this.options.duration ? this.pos = t = T.easing[this.easing](e, this.options.duration * e, 0, 1, this.options.duration) : this.pos = t = e, this.now = (this.end - this.start) * t + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), i && i.set ? i.set(this) : at.propHooks._default.set(this), this } }, at.prototype.init.prototype = at.prototype, at.propHooks = { _default: { get: function (e) { var t; return 1 !== e.elem.nodeType || null != e.elem[e.prop] && null == e.elem.style[e.prop] ? e.elem[e.prop] : (t = T.css(e.elem, e.prop, "")) && "auto" !== t ? t : 0 }, set: function (e) { T.fx.step[e.prop] ? T.fx.step[e.prop](e) : 1 !== e.elem.nodeType || !T.cssHooks[e.prop] && null == e.elem.style[Je(e.prop)] ? e.elem[e.prop] = e.now : T.style(e.elem, e.prop, e.now + e.unit) } } }, at.propHooks.scrollTop = at.propHooks.scrollLeft = { set: function (e) { e.elem.nodeType && e.elem.parentNode && (e.elem[e.prop] = e.now) } }, T.easing = { linear: function (e) { return e }, swing: function (e) { return .5 - Math.cos(e * Math.PI) / 2 }, _default: "swing" }, T.fx = at.prototype.init, T.fx.step = {}; var ot, rt, lt = /^(?:toggle|show|hide)$/, ct = /queueHooks$/; function dt() { rt && (!1 === b.hidden && n.requestAnimationFrame ? n.requestAnimationFrame(dt) : n.setTimeout(dt, T.fx.interval), T.fx.tick()) } function ht() { return n.setTimeout((function () { ot = void 0 })), ot = Date.now() } function ut(e, t) { var i, n = 0, s = { height: e }; for (t = t ? 1 : 0; n < 4; n += 2 - t)s["margin" + (i = ae[n])] = s["padding" + i] = e; return t && (s.opacity = s.width = e), s } function pt(e, t, i) { for (var n, s = (ft.tweeners[t] || []).concat(ft.tweeners["*"]), a = 0, o = s.length; a < o; a++)if (n = s[a].call(i, t, e)) return n } function ft(e, t, i) { var n, s, a = 0, o = ft.prefilters.length, r = T.Deferred().always((function () { delete l.elem })), l = function () { if (s) return !1; for (var t = ot || ht(), i = Math.max(0, c.startTime + c.duration - t), n = 1 - (i / c.duration || 0), a = 0, o = c.tweens.length; a < o; a++)c.tweens[a].run(n); return r.notifyWith(e, [c, n, i]), n < 1 && o ? i : (o || r.notifyWith(e, [c, 1, 0]), r.resolveWith(e, [c]), !1) }, c = r.promise({ elem: e, props: T.extend({}, t), opts: T.extend(!0, { specialEasing: {}, easing: T.easing._default }, i), originalProperties: t, originalOptions: i, startTime: ot || ht(), duration: i.duration, tweens: [], createTween: function (t, i) { var n = T.Tween(e, c.opts, t, i, c.opts.specialEasing[t] || c.opts.easing); return c.tweens.push(n), n }, stop: function (t) { var i = 0, n = t ? c.tweens.length : 0; if (s) return this; for (s = !0; i < n; i++)c.tweens[i].run(1); return t ? (r.notifyWith(e, [c, 1, 0]), r.resolveWith(e, [c, t])) : r.rejectWith(e, [c, t]), this } }), d = c.props; for (!function (e, t) { var i, n, s, a, o; for (i in e) if (s = t[n = U(i)], a = e[i], Array.isArray(a) && (s = a[1], a = e[i] = a[0]), i !== n && (e[n] = a, delete e[i]), (o = T.cssHooks[n]) && "expand" in o) for (i in a = o.expand(a), delete e[n], a) i in e || (e[i] = a[i], t[i] = s); else t[n] = s }(d, c.opts.specialEasing); a < o; a++)if (n = ft.prefilters[a].call(c, e, d, c.opts)) return v(n.stop) && (T._queueHooks(c.elem, c.opts.queue).stop = n.stop.bind(n)), n; return T.map(d, pt, c), v(c.opts.start) && c.opts.start.call(e, c), c.progress(c.opts.progress).done(c.opts.done, c.opts.complete).fail(c.opts.fail).always(c.opts.always), T.fx.timer(T.extend(l, { elem: e, anim: c, queue: c.opts.queue })), c } T.Animation = T.extend(ft, { tweeners: { "*": [function (e, t) { var i = this.createTween(e, t); return de(i.elem, e, se.exec(t), i), i }] }, tweener: function (e, t) { v(e) ? (t = e, e = ["*"]) : e = e.match(R); for (var i, n = 0, s = e.length; n < s; n++)i = e[n], ft.tweeners[i] = ft.tweeners[i] || [], ft.tweeners[i].unshift(t) }, prefilters: [function (e, t, i) { var n, s, a, o, r, l, c, d, h = "width" in t || "height" in t, u = this, p = {}, f = e.style, m = e.nodeType && ce(e), g = J.get(e, "fxshow"); for (n in i.queue || (null == (o = T._queueHooks(e, "fx")).unqueued && (o.unqueued = 0, r = o.empty.fire, o.empty.fire = function () { o.unqueued || r() }), o.unqueued++, u.always((function () { u.always((function () { o.unqueued--, T.queue(e, "fx").length || o.empty.fire() })) }))), t) if (s = t[n], lt.test(s)) { if (delete t[n], a = a || "toggle" === s, s === (m ? "hide" : "show")) { if ("show" !== s || !g || void 0 === g[n]) continue; m = !0 } p[n] = g && g[n] || T.style(e, n) } if ((l = !T.isEmptyObject(t)) || !T.isEmptyObject(p)) for (n in h && 1 === e.nodeType && (i.overflow = [f.overflow, f.overflowX, f.overflowY], null == (c = g && g.display) && (c = J.get(e, "display")), "none" === (d = T.css(e, "display")) && (c ? d = c : (pe([e], !0), c = e.style.display || c, d = T.css(e, "display"), pe([e]))), ("inline" === d || "inline-block" === d && null != c) && "none" === T.css(e, "float") && (l || (u.done((function () { f.display = c })), null == c && (d = f.display, c = "none" === d ? "" : d)), f.display = "inline-block")), i.overflow && (f.overflow = "hidden", u.always((function () { f.overflow = i.overflow[0], f.overflowX = i.overflow[1], f.overflowY = i.overflow[2] }))), l = !1, p) l || (g ? "hidden" in g && (m = g.hidden) : g = J.access(e, "fxshow", { display: c }), a && (g.hidden = !m), m && pe([e], !0), u.done((function () { for (n in m || pe([e]), J.remove(e, "fxshow"), p) T.style(e, n, p[n]) }))), l = pt(m ? g[n] : 0, n, u), n in g || (g[n] = l.start, m && (l.end = l.start, l.start = 0)) }], prefilter: function (e, t) { t ? ft.prefilters.unshift(e) : ft.prefilters.push(e) } }), T.speed = function (e, t, i) { var n = e && "object" == typeof e ? T.extend({}, e) : { complete: i || !i && t || v(e) && e, duration: e, easing: i && t || t && !v(t) && t }; return T.fx.off ? n.duration = 0 : "number" != typeof n.duration && (n.duration in T.fx.speeds ? n.duration = T.fx.speeds[n.duration] : n.duration = T.fx.speeds._default), null != n.queue && !0 !== n.queue || (n.queue = "fx"), n.old = n.complete, n.complete = function () { v(n.old) && n.old.call(this), n.queue && T.dequeue(this, n.queue) }, n }, T.fn.extend({ fadeTo: function (e, t, i, n) { return this.filter(ce).css("opacity", 0).show().end().animate({ opacity: t }, e, i, n) }, animate: function (e, t, i, n) { var s = T.isEmptyObject(e), a = T.speed(t, i, n), o = function () { var t = ft(this, T.extend({}, e), a); (s || J.get(this, "finish")) && t.stop(!0) }; return o.finish = o, s || !1 === a.queue ? this.each(o) : this.queue(a.queue, o) }, stop: function (e, t, i) { var n = function (e) { var t = e.stop; delete e.stop, t(i) }; return "string" != typeof e && (i = t, t = e, e = void 0), t && this.queue(e || "fx", []), this.each((function () { var t = !0, s = null != e && e + "queueHooks", a = T.timers, o = J.get(this); if (s) o[s] && o[s].stop && n(o[s]); else for (s in o) o[s] && o[s].stop && ct.test(s) && n(o[s]); for (s = a.length; s--;)a[s].elem !== this || null != e && a[s].queue !== e || (a[s].anim.stop(i), t = !1, a.splice(s, 1)); !t && i || T.dequeue(this, e) })) }, finish: function (e) { return !1 !== e && (e = e || "fx"), this.each((function () { var t, i = J.get(this), n = i[e + "queue"], s = i[e + "queueHooks"], a = T.timers, o = n ? n.length : 0; for (i.finish = !0, T.queue(this, e, []), s && s.stop && s.stop.call(this, !0), t = a.length; t--;)a[t].elem === this && a[t].queue === e && (a[t].anim.stop(!0), a.splice(t, 1)); for (t = 0; t < o; t++)n[t] && n[t].finish && n[t].finish.call(this); delete i.finish })) } }), T.each(["toggle", "show", "hide"], (function (e, t) { var i = T.fn[t]; T.fn[t] = function (e, n, s) { return null == e || "boolean" == typeof e ? i.apply(this, arguments) : this.animate(ut(t, !0), e, n, s) } })), T.each({ slideDown: ut("show"), slideUp: ut("hide"), slideToggle: ut("toggle"), fadeIn: { opacity: "show" }, fadeOut: { opacity: "hide" }, fadeToggle: { opacity: "toggle" } }, (function (e, t) { T.fn[e] = function (e, i, n) { return this.animate(t, e, i, n) } })), T.timers = [], T.fx.tick = function () { var e, t = 0, i = T.timers; for (ot = Date.now(); t < i.length; t++)(e = i[t])() || i[t] !== e || i.splice(t--, 1); i.length || T.fx.stop(), ot = void 0 }, T.fx.timer = function (e) { T.timers.push(e), T.fx.start() }, T.fx.interval = 13, T.fx.start = function () { rt || (rt = !0, dt()) }, T.fx.stop = function () { rt = null }, T.fx.speeds = { slow: 600, fast: 200, _default: 400 }, T.fn.delay = function (e, t) { return e = T.fx && T.fx.speeds[e] || e, t = t || "fx", this.queue(t, (function (t, i) { var s = n.setTimeout(t, e); i.stop = function () { n.clearTimeout(s) } })) }, function () { var e = b.createElement("input"), t = b.createElement("select").appendChild(b.createElement("option")); e.type = "checkbox", g.checkOn = "" !== e.value, g.optSelected = t.selected, (e = b.createElement("input")).value = "t", e.type = "radio", g.radioValue = "t" === e.value }(); var mt, gt = T.expr.attrHandle; T.fn.extend({ attr: function (e, t) { return X(this, T.attr, e, t, arguments.length > 1) }, removeAttr: function (e) { return this.each((function () { T.removeAttr(this, e) })) } }), T.extend({ attr: function (e, t, i) { var n, s, a = e.nodeType; if (3 !== a && 8 !== a && 2 !== a) return void 0 === e.getAttribute ? T.prop(e, t, i) : (1 === a && T.isXMLDoc(e) || (s = T.attrHooks[t.toLowerCase()] || (T.expr.match.bool.test(t) ? mt : void 0)), void 0 !== i ? null === i ? void T.removeAttr(e, t) : s && "set" in s && void 0 !== (n = s.set(e, i, t)) ? n : (e.setAttribute(t, i + ""), i) : s && "get" in s && null !== (n = s.get(e, t)) ? n : null == (n = T.find.attr(e, t)) ? void 0 : n) }, attrHooks: { type: { set: function (e, t) { if (!g.radioValue && "radio" === t && L(e, "input")) { var i = e.value; return e.setAttribute("type", t), i && (e.value = i), t } } } }, removeAttr: function (e, t) { var i, n = 0, s = t && t.match(R); if (s && 1 === e.nodeType) for (; i = s[n++];)e.removeAttribute(i) } }), mt = { set: function (e, t, i) { return !1 === t ? T.removeAttr(e, i) : e.setAttribute(i, i), i } }, T.each(T.expr.match.bool.source.match(/\w+/g), (function (e, t) { var i = gt[t] || T.find.attr; gt[t] = function (e, t, n) { var s, a, o = t.toLowerCase(); return n || (a = gt[o], gt[o] = s, s = null != i(e, t, n) ? o : null, gt[o] = a), s } })); var vt = /^(?:input|select|textarea|button)$/i, yt = /^(?:a|area)$/i; function bt(e) { return (e.match(R) || []).join(" ") } function xt(e) { return e.getAttribute && e.getAttribute("class") || "" } function wt(e) { return Array.isArray(e) ? e : "string" == typeof e && e.match(R) || [] } T.fn.extend({ prop: function (e, t) { return X(this, T.prop, e, t, arguments.length > 1) }, removeProp: function (e) { return this.each((function () { delete this[T.propFix[e] || e] })) } }), T.extend({ prop: function (e, t, i) { var n, s, a = e.nodeType; if (3 !== a && 8 !== a && 2 !== a) return 1 === a && T.isXMLDoc(e) || (t = T.propFix[t] || t, s = T.propHooks[t]), void 0 !== i ? s && "set" in s && void 0 !== (n = s.set(e, i, t)) ? n : e[t] = i : s && "get" in s && null !== (n = s.get(e, t)) ? n : e[t] }, propHooks: { tabIndex: { get: function (e) { var t = T.find.attr(e, "tabindex"); return t ? parseInt(t, 10) : vt.test(e.nodeName) || yt.test(e.nodeName) && e.href ? 0 : -1 } } }, propFix: { for: "htmlFor", class: "className" } }), g.optSelected || (T.propHooks.selected = { get: function (e) { var t = e.parentNode; return t && t.parentNode && t.parentNode.selectedIndex, null }, set: function (e) { var t = e.parentNode; t && (t.selectedIndex, t.parentNode && t.parentNode.selectedIndex) } }), T.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], (function () { T.propFix[this.toLowerCase()] = this })), T.fn.extend({ addClass: function (e) { var t, i, n, s, a, o; return v(e) ? this.each((function (t) { T(this).addClass(e.call(this, t, xt(this))) })) : (t = wt(e)).length ? this.each((function () { if (n = xt(this), i = 1 === this.nodeType && " " + bt(n) + " ") { for (a = 0; a < t.length; a++)s = t[a], i.indexOf(" " + s + " ") < 0 && (i += s + " "); o = bt(i), n !== o && this.setAttribute("class", o) } })) : this }, removeClass: function (e) { var t, i, n, s, a, o; return v(e) ? this.each((function (t) { T(this).removeClass(e.call(this, t, xt(this))) })) : arguments.length ? (t = wt(e)).length ? this.each((function () { if (n = xt(this), i = 1 === this.nodeType && " " + bt(n) + " ") { for (a = 0; a < t.length; a++)for (s = t[a]; i.indexOf(" " + s + " ") > -1;)i = i.replace(" " + s + " ", " "); o = bt(i), n !== o && this.setAttribute("class", o) } })) : this : this.attr("class", "") }, toggleClass: function (e, t) { var i, n, s, a, o = typeof e, r = "string" === o || Array.isArray(e); return v(e) ? this.each((function (i) { T(this).toggleClass(e.call(this, i, xt(this), t), t) })) : "boolean" == typeof t && r ? t ? this.addClass(e) : this.removeClass(e) : (i = wt(e), this.each((function () { if (r) for (a = T(this), s = 0; s < i.length; s++)n = i[s], a.hasClass(n) ? a.removeClass(n) : a.addClass(n); else void 0 !== e && "boolean" !== o || ((n = xt(this)) && J.set(this, "__className__", n), this.setAttribute && this.setAttribute("class", n || !1 === e ? "" : J.get(this, "__className__") || "")) }))) }, hasClass: function (e) { var t, i, n = 0; for (t = " " + e + " "; i = this[n++];)if (1 === i.nodeType && (" " + bt(xt(i)) + " ").indexOf(t) > -1) return !0; return !1 } }); var Ct = /\r/g; T.fn.extend({ val: function (e) { var t, i, n, s = this[0]; return arguments.length ? (n = v(e), this.each((function (i) { var s; 1 === this.nodeType && (null == (s = n ? e.call(this, i, T(this).val()) : e) ? s = "" : "number" == typeof s ? s += "" : Array.isArray(s) && (s = T.map(s, (function (e) { return null == e ? "" : e + "" }))), (t = T.valHooks[this.type] || T.valHooks[this.nodeName.toLowerCase()]) && "set" in t && void 0 !== t.set(this, s, "value") || (this.value = s)) }))) : s ? (t = T.valHooks[s.type] || T.valHooks[s.nodeName.toLowerCase()]) && "get" in t && void 0 !== (i = t.get(s, "value")) ? i : "string" == typeof (i = s.value) ? i.replace(Ct, "") : null == i ? "" : i : void 0 } }), T.extend({ valHooks: { option: { get: function (e) { var t = T.find.attr(e, "value"); return null != t ? t : bt(T.text(e)) } }, select: { get: function (e) { var t, i, n, s = e.options, a = e.selectedIndex, o = "select-one" === e.type, r = o ? null : [], l = o ? a + 1 : s.length; for (n = a < 0 ? l : o ? a : 0; n < l; n++)if (((i = s[n]).selected || n === a) && !i.disabled && (!i.parentNode.disabled || !L(i.parentNode, "optgroup"))) { if (t = T(i).val(), o) return t; r.push(t) } return r }, set: function (e, t) { for (var i, n, s = e.options, a = T.makeArray(t), o = s.length; o--;)((n = s[o]).selected = T.inArray(T.valHooks.option.get(n), a) > -1) && (i = !0); return i || (e.selectedIndex = -1), a } } } }), T.each(["radio", "checkbox"], (function () { T.valHooks[this] = { set: function (e, t) { if (Array.isArray(t)) return e.checked = T.inArray(T(e).val(), t) > -1 } }, g.checkOn || (T.valHooks[this].get = function (e) { return null === e.getAttribute("value") ? "on" : e.value }) })), g.focusin = "onfocusin" in n; var Et = /^(?:focusinfocus|focusoutblur)$/, Tt = function (e) { e.stopPropagation() }; T.extend(T.event, { trigger: function (e, t, i, s) { var a, o, r, l, c, d, h, u, f = [i || b], m = p.call(e, "type") ? e.type : e, g = p.call(e, "namespace") ? e.namespace.split(".") : []; if (o = u = r = i = i || b, 3 !== i.nodeType && 8 !== i.nodeType && !Et.test(m + T.event.triggered) && (m.indexOf(".") > -1 && (g = m.split("."), m = g.shift(), g.sort()), c = m.indexOf(":") < 0 && "on" + m, (e = e[T.expando] ? e : new T.Event(m, "object" == typeof e && e)).isTrigger = s ? 2 : 3, e.namespace = g.join("."), e.rnamespace = e.namespace ? new RegExp("(^|\\.)" + g.join("\\.(?:.*\\.|)") + "(\\.|$)") : null, e.result = void 0, e.target || (e.target = i), t = null == t ? [e] : T.makeArray(t, [e]), h = T.event.special[m] || {}, s || !h.trigger || !1 !== h.trigger.apply(i, t))) { if (!s && !h.noBubble && !y(i)) { for (l = h.delegateType || m, Et.test(l + m) || (o = o.parentNode); o; o = o.parentNode)f.push(o), r = o; r === (i.ownerDocument || b) && f.push(r.defaultView || r.parentWindow || n) } for (a = 0; (o = f[a++]) && !e.isPropagationStopped();)u = o, e.type = a > 1 ? l : h.bindType || m, (d = (J.get(o, "events") || Object.create(null))[e.type] && J.get(o, "handle")) && d.apply(o, t), (d = c && o[c]) && d.apply && Z(o) && (e.result = d.apply(o, t), !1 === e.result && e.preventDefault()); return e.type = m, s || e.isDefaultPrevented() || h._default && !1 !== h._default.apply(f.pop(), t) || !Z(i) || c && v(i[m]) && !y(i) && ((r = i[c]) && (i[c] = null), T.event.triggered = m, e.isPropagationStopped() && u.addEventListener(m, Tt), i[m](), e.isPropagationStopped() && u.removeEventListener(m, Tt), T.event.triggered = void 0, r && (i[c] = r)), e.result } }, simulate: function (e, t, i) { var n = T.extend(new T.Event, i, { type: e, isSimulated: !0 }); T.event.trigger(n, null, t) } }), T.fn.extend({ trigger: function (e, t) { return this.each((function () { T.event.trigger(e, t, this) })) }, triggerHandler: function (e, t) { var i = this[0]; if (i) return T.event.trigger(e, t, i, !0) } }), g.focusin || T.each({ focus: "focusin", blur: "focusout" }, (function (e, t) { var i = function (e) { T.event.simulate(t, e.target, T.event.fix(e)) }; T.event.special[t] = { setup: function () { var n = this.ownerDocument || this.document || this, s = J.access(n, t); s || n.addEventListener(e, i, !0), J.access(n, t, (s || 0) + 1) }, teardown: function () { var n = this.ownerDocument || this.document || this, s = J.access(n, t) - 1; s ? J.access(n, t, s) : (n.removeEventListener(e, i, !0), J.remove(n, t)) } } })); var St = n.location, $t = { guid: Date.now() }, Mt = /\?/; T.parseXML = function (e) { var t, i; if (!e || "string" != typeof e) return null; try { t = (new n.DOMParser).parseFromString(e, "text/xml") } catch (e) { } return i = t && t.getElementsByTagName("parsererror")[0], t && !i || T.error("Invalid XML: " + (i ? T.map(i.childNodes, (function (e) { return e.textContent })).join("\n") : e)), t }; var Pt = /\[\]$/, kt = /\r?\n/g, Lt = /^(?:submit|button|image|reset|file)$/i, At = /^(?:input|select|textarea|keygen)/i; function zt(e, t, i, n) { var s; if (Array.isArray(t)) T.each(t, (function (t, s) { i || Pt.test(e) ? n(e, s) : zt(e + "[" + ("object" == typeof s && null != s ? t : "") + "]", s, i, n) })); else if (i || "object" !== C(t)) n(e, t); else for (s in t) zt(e + "[" + s + "]", t[s], i, n) } T.param = function (e, t) { var i, n = [], s = function (e, t) { var i = v(t) ? t() : t; n[n.length] = encodeURIComponent(e) + "=" + encodeURIComponent(null == i ? "" : i) }; if (null == e) return ""; if (Array.isArray(e) || e.jquery && !T.isPlainObject(e)) T.each(e, (function () { s(this.name, this.value) })); else for (i in e) zt(i, e[i], t, s); return n.join("&") }, T.fn.extend({ serialize: function () { return T.param(this.serializeArray()) }, serializeArray: function () { return this.map((function () { var e = T.prop(this, "elements"); return e ? T.makeArray(e) : this })).filter((function () { var e = this.type; return this.name && !T(this).is(":disabled") && At.test(this.nodeName) && !Lt.test(e) && (this.checked || !ge.test(e)) })).map((function (e, t) { var i = T(this).val(); return null == i ? null : Array.isArray(i) ? T.map(i, (function (e) { return { name: t.name, value: e.replace(kt, "\r\n") } })) : { name: t.name, value: i.replace(kt, "\r\n") } })).get() } }); var Ot = /%20/g, It = /#.*$/, Dt = /([?&])_=[^&]*/, _t = /^(.*?):[ \t]*([^\r\n]*)$/gm, Nt = /^(?:GET|HEAD)$/, Rt = /^\/\//, Ht = {}, jt = {}, Ft = "*/".concat("*"), qt = b.createElement("a"); function Bt(e) { return function (t, i) { "string" != typeof t && (i = t, t = "*"); var n, s = 0, a = t.toLowerCase().match(R) || []; if (v(i)) for (; n = a[s++];)"+" === n[0] ? (n = n.slice(1) || "*", (e[n] = e[n] || []).unshift(i)) : (e[n] = e[n] || []).push(i) } } function Wt(e, t, i, n) { var s = {}, a = e === jt; function o(r) { var l; return s[r] = !0, T.each(e[r] || [], (function (e, r) { var c = r(t, i, n); return "string" != typeof c || a || s[c] ? a ? !(l = c) : void 0 : (t.dataTypes.unshift(c), o(c), !1) })), l } return o(t.dataTypes[0]) || !s["*"] && o("*") } function Xt(e, t) { var i, n, s = T.ajaxSettings.flatOptions || {}; for (i in t) void 0 !== t[i] && ((s[i] ? e : n || (n = {}))[i] = t[i]); return n && T.extend(!0, e, n), e } qt.href = St.href, T.extend({ active: 0, lastModified: {}, etag: {}, ajaxSettings: { url: St.href, type: "GET", isLocal: /^(?:about|app|app-storage|.+-extension|file|res|widget):$/.test(St.protocol), global: !0, processData: !0, async: !0, contentType: "application/x-www-form-urlencoded; charset=UTF-8", accepts: { "*": Ft, text: "text/plain", html: "text/html", xml: "application/xml, text/xml", json: "application/json, text/javascript" }, contents: { xml: /\bxml\b/, html: /\bhtml/, json: /\bjson\b/ }, responseFields: { xml: "responseXML", text: "responseText", json: "responseJSON" }, converters: { "* text": String, "text html": !0, "text json": JSON.parse, "text xml": T.parseXML }, flatOptions: { url: !0, context: !0 } }, ajaxSetup: function (e, t) { return t ? Xt(Xt(e, T.ajaxSettings), t) : Xt(T.ajaxSettings, e) }, ajaxPrefilter: Bt(Ht), ajaxTransport: Bt(jt), ajax: function (e, t) { "object" == typeof e && (t = e, e = void 0), t = t || {}; var i, s, a, o, r, l, c, d, h, u, p = T.ajaxSetup({}, t), f = p.context || p, m = p.context && (f.nodeType || f.jquery) ? T(f) : T.event, g = T.Deferred(), v = T.Callbacks("once memory"), y = p.statusCode || {}, x = {}, w = {}, C = "canceled", E = { readyState: 0, getResponseHeader: function (e) { var t; if (c) { if (!o) for (o = {}; t = _t.exec(a);)o[t[1].toLowerCase() + " "] = (o[t[1].toLowerCase() + " "] || []).concat(t[2]); t = o[e.toLowerCase() + " "] } return null == t ? null : t.join(", ") }, getAllResponseHeaders: function () { return c ? a : null }, setRequestHeader: function (e, t) { return null == c && (e = w[e.toLowerCase()] = w[e.toLowerCase()] || e, x[e] = t), this }, overrideMimeType: function (e) { return null == c && (p.mimeType = e), this }, statusCode: function (e) { var t; if (e) if (c) E.always(e[E.status]); else for (t in e) y[t] = [y[t], e[t]]; return this }, abort: function (e) { var t = e || C; return i && i.abort(t), S(0, t), this } }; if (g.promise(E), p.url = ((e || p.url || St.href) + "").replace(Rt, St.protocol + "//"), p.type = t.method || t.type || p.method || p.type, p.dataTypes = (p.dataType || "*").toLowerCase().match(R) || [""], null == p.crossDomain) { l = b.createElement("a"); try { l.href = p.url, l.href = l.href, p.crossDomain = qt.protocol + "//" + qt.host != l.protocol + "//" + l.host } catch (e) { p.crossDomain = !0 } } if (p.data && p.processData && "string" != typeof p.data && (p.data = T.param(p.data, p.traditional)), Wt(Ht, p, t, E), c) return E; for (h in (d = T.event && p.global) && 0 == T.active++ && T.event.trigger("ajaxStart"), p.type = p.type.toUpperCase(), p.hasContent = !Nt.test(p.type), s = p.url.replace(It, ""), p.hasContent ? p.data && p.processData && 0 === (p.contentType || "").indexOf("application/x-www-form-urlencoded") && (p.data = p.data.replace(Ot, "+")) : (u = p.url.slice(s.length), p.data && (p.processData || "string" == typeof p.data) && (s += (Mt.test(s) ? "&" : "?") + p.data, delete p.data), !1 === p.cache && (s = s.replace(Dt, "$1"), u = (Mt.test(s) ? "&" : "?") + "_=" + $t.guid++ + u), p.url = s + u), p.ifModified && (T.lastModified[s] && E.setRequestHeader("If-Modified-Since", T.lastModified[s]), T.etag[s] && E.setRequestHeader("If-None-Match", T.etag[s])), (p.data && p.hasContent && !1 !== p.contentType || t.contentType) && E.setRequestHeader("Content-Type", p.contentType), E.setRequestHeader("Accept", p.dataTypes[0] && p.accepts[p.dataTypes[0]] ? p.accepts[p.dataTypes[0]] + ("*" !== p.dataTypes[0] ? ", " + Ft + "; q=0.01" : "") : p.accepts["*"]), p.headers) E.setRequestHeader(h, p.headers[h]); if (p.beforeSend && (!1 === p.beforeSend.call(f, E, p) || c)) return E.abort(); if (C = "abort", v.add(p.complete), E.done(p.success), E.fail(p.error), i = Wt(jt, p, t, E)) { if (E.readyState = 1, d && m.trigger("ajaxSend", [E, p]), c) return E; p.async && p.timeout > 0 && (r = n.setTimeout((function () { E.abort("timeout") }), p.timeout)); try { c = !1, i.send(x, S) } catch (e) { if (c) throw e; S(-1, e) } } else S(-1, "No Transport"); function S(e, t, o, l) { var h, u, b, x, w, C = t; c || (c = !0, r && n.clearTimeout(r), i = void 0, a = l || "", E.readyState = e > 0 ? 4 : 0, h = e >= 200 && e < 300 || 304 === e, o && (x = function (e, t, i) { for (var n, s, a, o, r = e.contents, l = e.dataTypes; "*" === l[0];)l.shift(), void 0 === n && (n = e.mimeType || t.getResponseHeader("Content-Type")); if (n) for (s in r) if (r[s] && r[s].test(n)) { l.unshift(s); break } if (l[0] in i) a = l[0]; else { for (s in i) { if (!l[0] || e.converters[s + " " + l[0]]) { a = s; break } o || (o = s) } a = a || o } if (a) return a !== l[0] && l.unshift(a), i[a] }(p, E, o)), !h && T.inArray("script", p.dataTypes) > -1 && T.inArray("json", p.dataTypes) < 0 && (p.converters["text script"] = function () { }), x = function (e, t, i, n) { var s, a, o, r, l, c = {}, d = e.dataTypes.slice(); if (d[1]) for (o in e.converters) c[o.toLowerCase()] = e.converters[o]; for (a = d.shift(); a;)if (e.responseFields[a] && (i[e.responseFields[a]] = t), !l && n && e.dataFilter && (t = e.dataFilter(t, e.dataType)), l = a, a = d.shift()) if ("*" === a) a = l; else if ("*" !== l && l !== a) { if (!(o = c[l + " " + a] || c["* " + a])) for (s in c) if ((r = s.split(" "))[1] === a && (o = c[l + " " + r[0]] || c["* " + r[0]])) { !0 === o ? o = c[s] : !0 !== c[s] && (a = r[0], d.unshift(r[1])); break } if (!0 !== o) if (o && e.throws) t = o(t); else try { t = o(t) } catch (e) { return { state: "parsererror", error: o ? e : "No conversion from " + l + " to " + a } } } return { state: "success", data: t } }(p, x, E, h), h ? (p.ifModified && ((w = E.getResponseHeader("Last-Modified")) && (T.lastModified[s] = w), (w = E.getResponseHeader("etag")) && (T.etag[s] = w)), 204 === e || "HEAD" === p.type ? C = "nocontent" : 304 === e ? C = "notmodified" : (C = x.state, u = x.data, h = !(b = x.error))) : (b = C, !e && C || (C = "error", e < 0 && (e = 0))), E.status = e, E.statusText = (t || C) + "", h ? g.resolveWith(f, [u, C, E]) : g.rejectWith(f, [E, C, b]), E.statusCode(y), y = void 0, d && m.trigger(h ? "ajaxSuccess" : "ajaxError", [E, p, h ? u : b]), v.fireWith(f, [E, C]), d && (m.trigger("ajaxComplete", [E, p]), --T.active || T.event.trigger("ajaxStop"))) } return E }, getJSON: function (e, t, i) { return T.get(e, t, i, "json") }, getScript: function (e, t) { return T.get(e, void 0, t, "script") } }), T.each(["get", "post"], (function (e, t) { T[t] = function (e, i, n, s) { return v(i) && (s = s || n, n = i, i = void 0), T.ajax(T.extend({ url: e, type: t, dataType: s, data: i, success: n }, T.isPlainObject(e) && e)) } })), T.ajaxPrefilter((function (e) { var t; for (t in e.headers) "content-type" === t.toLowerCase() && (e.contentType = e.headers[t] || "") })), T._evalUrl = function (e, t, i) { return T.ajax({ url: e, type: "GET", dataType: "script", cache: !0, async: !1, global: !1, converters: { "text script": function () { } }, dataFilter: function (e) { T.globalEval(e, t, i) } }) }, T.fn.extend({ wrapAll: function (e) { var t; return this[0] && (v(e) && (e = e.call(this[0])), t = T(e, this[0].ownerDocument).eq(0).clone(!0), this[0].parentNode && t.insertBefore(this[0]), t.map((function () { for (var e = this; e.firstElementChild;)e = e.firstElementChild; return e })).append(this)), this }, wrapInner: function (e) { return v(e) ? this.each((function (t) { T(this).wrapInner(e.call(this, t)) })) : this.each((function () { var t = T(this), i = t.contents(); i.length ? i.wrapAll(e) : t.append(e) })) }, wrap: function (e) { var t = v(e); return this.each((function (i) { T(this).wrapAll(t ? e.call(this, i) : e) })) }, unwrap: function (e) { return this.parent(e).not("body").each((function () { T(this).replaceWith(this.childNodes) })), this } }), T.expr.pseudos.hidden = function (e) { return !T.expr.pseudos.visible(e) }, T.expr.pseudos.visible = function (e) { return !!(e.offsetWidth || e.offsetHeight || e.getClientRects().length) }, T.ajaxSettings.xhr = function () { try { return new n.XMLHttpRequest } catch (e) { } }; var Yt = { 0: 200, 1223: 204 }, Gt = T.ajaxSettings.xhr(); g.cors = !!Gt && "withCredentials" in Gt, g.ajax = Gt = !!Gt, T.ajaxTransport((function (e) { var t, i; if (g.cors || Gt && !e.crossDomain) return { send: function (s, a) { var o, r = e.xhr(); if (r.open(e.type, e.url, e.async, e.username, e.password), e.xhrFields) for (o in e.xhrFields) r[o] = e.xhrFields[o]; for (o in e.mimeType && r.overrideMimeType && r.overrideMimeType(e.mimeType), e.crossDomain || s["X-Requested-With"] || (s["X-Requested-With"] = "XMLHttpRequest"), s) r.setRequestHeader(o, s[o]); t = function (e) { return function () { t && (t = i = r.onload = r.onerror = r.onabort = r.ontimeout = r.onreadystatechange = null, "abort" === e ? r.abort() : "error" === e ? "number" != typeof r.status ? a(0, "error") : a(r.status, r.statusText) : a(Yt[r.status] || r.status, r.statusText, "text" !== (r.responseType || "text") || "string" != typeof r.responseText ? { binary: r.response } : { text: r.responseText }, r.getAllResponseHeaders())) } }, r.onload = t(), i = r.onerror = r.ontimeout = t("error"), void 0 !== r.onabort ? r.onabort = i : r.onreadystatechange = function () { 4 === r.readyState && n.setTimeout((function () { t && i() })) }, t = t("abort"); try { r.send(e.hasContent && e.data || null) } catch (e) { if (t) throw e } }, abort: function () { t && t() } } })), T.ajaxPrefilter((function (e) { e.crossDomain && (e.contents.script = !1) })), T.ajaxSetup({ accepts: { script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript" }, contents: { script: /\b(?:java|ecma)script\b/ }, converters: { "text script": function (e) { return T.globalEval(e), e } } }), T.ajaxPrefilter("script", (function (e) { void 0 === e.cache && (e.cache = !1), e.crossDomain && (e.type = "GET") })), T.ajaxTransport("script", (function (e) { var t, i; if (e.crossDomain || e.scriptAttrs) return { send: function (n, s) { t = T("<script>").attr(e.scriptAttrs || {}).prop({ charset: e.scriptCharset, src: e.url }).on("load error", i = function (e) { t.remove(), i = null, e && s("error" === e.type ? 404 : 200, e.type) }), b.head.appendChild(t[0]) }, abort: function () { i && i() } } })); var Vt, Ut = [], Zt = /(=)\?(?=&|$)|\?\?/; T.ajaxSetup({ jsonp: "callback", jsonpCallback: function () { var e = Ut.pop() || T.expando + "_" + $t.guid++; return this[e] = !0, e } }), T.ajaxPrefilter("json jsonp", (function (e, t, i) { var s, a, o, r = !1 !== e.jsonp && (Zt.test(e.url) ? "url" : "string" == typeof e.data && 0 === (e.contentType || "").indexOf("application/x-www-form-urlencoded") && Zt.test(e.data) && "data"); if (r || "jsonp" === e.dataTypes[0]) return s = e.jsonpCallback = v(e.jsonpCallback) ? e.jsonpCallback() : e.jsonpCallback, r ? e[r] = e[r].replace(Zt, "$1" + s) : !1 !== e.jsonp && (e.url += (Mt.test(e.url) ? "&" : "?") + e.jsonp + "=" + s), e.converters["script json"] = function () { return o || T.error(s + " was not called"), o[0] }, e.dataTypes[0] = "json", a = n[s], n[s] = function () { o = arguments }, i.always((function () { void 0 === a ? T(n).removeProp(s) : n[s] = a, e[s] && (e.jsonpCallback = t.jsonpCallback, Ut.push(s)), o && v(a) && a(o[0]), o = a = void 0 })), "script" })), g.createHTMLDocument = ((Vt = b.implementation.createHTMLDocument("").body).innerHTML = "<form></form><form></form>", 2 === Vt.childNodes.length), T.parseHTML = function (e, t, i) { return "string" != typeof e ? [] : ("boolean" == typeof t && (i = t, t = !1), t || (g.createHTMLDocument ? ((n = (t = b.implementation.createHTMLDocument("")).createElement("base")).href = b.location.href, t.head.appendChild(n)) : t = b), a = !i && [], (s = A.exec(e)) ? [t.createElement(s[1])] : (s = Ee([e], t, a), a && a.length && T(a).remove(), T.merge([], s.childNodes))); var n, s, a }, T.fn.load = function (e, t, i) { var n, s, a, o = this, r = e.indexOf(" "); return r > -1 && (n = bt(e.slice(r)), e = e.slice(0, r)), v(t) ? (i = t, t = void 0) : t && "object" == typeof t && (s = "POST"), o.length > 0 && T.ajax({ url: e, type: s || "GET", dataType: "html", data: t }).done((function (e) { a = arguments, o.html(n ? T("<div>").append(T.parseHTML(e)).find(n) : e) })).always(i && function (e, t) { o.each((function () { i.apply(this, a || [e.responseText, t, e]) })) }), this }, T.expr.pseudos.animated = function (e) { return T.grep(T.timers, (function (t) { return e === t.elem })).length }, T.offset = { setOffset: function (e, t, i) { var n, s, a, o, r, l, c = T.css(e, "position"), d = T(e), h = {}; "static" === c && (e.style.position = "relative"), r = d.offset(), a = T.css(e, "top"), l = T.css(e, "left"), ("absolute" === c || "fixed" === c) && (a + l).indexOf("auto") > -1 ? (o = (n = d.position()).top, s = n.left) : (o = parseFloat(a) || 0, s = parseFloat(l) || 0), v(t) && (t = t.call(e, i, T.extend({}, r))), null != t.top && (h.top = t.top - r.top + o), null != t.left && (h.left = t.left - r.left + s), "using" in t ? t.using.call(e, h) : d.css(h) } }, T.fn.extend({ offset: function (e) { if (arguments.length) return void 0 === e ? this : this.each((function (t) { T.offset.setOffset(this, e, t) })); var t, i, n = this[0]; return n ? n.getClientRects().length ? (t = n.getBoundingClientRect(), i = n.ownerDocument.defaultView, { top: t.top + i.pageYOffset, left: t.left + i.pageXOffset }) : { top: 0, left: 0 } : void 0 }, position: function () { if (this[0]) { var e, t, i, n = this[0], s = { top: 0, left: 0 }; if ("fixed" === T.css(n, "position")) t = n.getBoundingClientRect(); else { for (t = this.offset(), i = n.ownerDocument, e = n.offsetParent || i.documentElement; e && (e === i.body || e === i.documentElement) && "static" === T.css(e, "position");)e = e.parentNode; e && e !== n && 1 === e.nodeType && ((s = T(e).offset()).top += T.css(e, "borderTopWidth", !0), s.left += T.css(e, "borderLeftWidth", !0)) } return { top: t.top - s.top - T.css(n, "marginTop", !0), left: t.left - s.left - T.css(n, "marginLeft", !0) } } }, offsetParent: function () { return this.map((function () { for (var e = this.offsetParent; e && "static" === T.css(e, "position");)e = e.offsetParent; return e || oe })) } }), T.each({ scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, (function (e, t) { var i = "pageYOffset" === t; T.fn[e] = function (n) { return X(this, (function (e, n, s) { var a; if (y(e) ? a = e : 9 === e.nodeType && (a = e.defaultView), void 0 === s) return a ? a[t] : e[n]; a ? a.scrollTo(i ? a.pageXOffset : s, i ? s : a.pageYOffset) : e[n] = s }), e, n, arguments.length) } })), T.each(["top", "left"], (function (e, t) { T.cssHooks[t] = Ve(g.pixelPosition, (function (e, i) { if (i) return i = Ge(e, t), je.test(i) ? T(e).position()[t] + "px" : i })) })), T.each({ Height: "height", Width: "width" }, (function (e, t) { T.each({ padding: "inner" + e, content: t, "": "outer" + e }, (function (i, n) { T.fn[n] = function (s, a) { var o = arguments.length && (i || "boolean" != typeof s), r = i || (!0 === s || !0 === a ? "margin" : "border"); return X(this, (function (t, i, s) { var a; return y(t) ? 0 === n.indexOf("outer") ? t["inner" + e] : t.document.documentElement["client" + e] : 9 === t.nodeType ? (a = t.documentElement, Math.max(t.body["scroll" + e], a["scroll" + e], t.body["offset" + e], a["offset" + e], a["client" + e])) : void 0 === s ? T.css(t, i, r) : T.style(t, i, s, r) }), t, o ? s : void 0, o) } })) })), T.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], (function (e, t) { T.fn[t] = function (e) { return this.on(t, e) } })), T.fn.extend({ bind: function (e, t, i) { return this.on(e, null, t, i) }, unbind: function (e, t) { return this.off(e, null, t) }, delegate: function (e, t, i, n) { return this.on(t, e, i, n) }, undelegate: function (e, t, i) { return 1 === arguments.length ? this.off(e, "**") : this.off(t, e || "**", i) }, hover: function (e, t) { return this.mouseenter(e).mouseleave(t || e) } }), T.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "), (function (e, t) { T.fn[t] = function (e, i) { return arguments.length > 0 ? this.on(t, null, e, i) : this.trigger(t) } })); var Kt = /^[\s\uFEFF\xA0]+|([^\s\uFEFF\xA0])[\s\uFEFF\xA0]+$/g; T.proxy = function (e, t) { var i, n, s; if ("string" == typeof t && (i = e[t], t = e, e = i), v(e)) return n = r.call(arguments, 2), s = function () { return e.apply(t || this, n.concat(r.call(arguments))) }, s.guid = e.guid = e.guid || T.guid++, s }, T.holdReady = function (e) { e ? T.readyWait++ : T.ready(!0) }, T.isArray = Array.isArray, T.parseJSON = JSON.parse, T.nodeName = L, T.isFunction = v, T.isWindow = y, T.camelCase = U, T.type = C, T.now = Date.now, T.isNumeric = function (e) { var t = T.type(e); return ("number" === t || "string" === t) && !isNaN(e - parseFloat(e)) }, T.trim = function (e) { return null == e ? "" : (e + "").replace(Kt, "$1") }, void 0 === (i = function () { return T }.apply(t, [])) || (e.exports = i); var Jt = n.jQuery, Qt = n.$; return T.noConflict = function (e) { return n.$ === T && (n.$ = Qt), e && n.jQuery === T && (n.jQuery = Jt), T }, void 0 === s && (n.jQuery = n.$ = T), T })) } }, t = {}; function i(n) { var s = t[n]; if (void 0 !== s) return s.exports; var a = t[n] = { exports: {} }; return e[n].call(a.exports, a, a.exports, i), a.exports } !function () { "use strict"; var e = i(755); e(".accordion__title").on("click", (function () { e(this).next(".accordion__desc").slideToggle(), e(this).parent().toggleClass("active") })) }(), function () { "use strict"; i(755)("form#form_id").trigger("reset") }(), function () { "use strict"; var e = i(755); e(".hamburger").on("click", (function () { e("body").toggleClass("no-scroll"), e(this).toggleClass("open"), e(".slide-menu").toggleClass("open") })) }(), function () { "use strict"; var e = i(755); e(window).scroll((function () { var t = e(".header"), i = t.outerHeight(); scroll = e(window).scrollTop(), scroll >= i ? t.addClass("sticky") : t.removeClass("sticky") })) }(), function () { "use strict"; var e = i(755); e(document).ready((function () { e(".hero__img").addClass("active") })) }(), function () { "use strict"; var e = i(755); e(".count-items__item").each((function (t) { e(this).find(".count-items__count").append(t + 1 + ".") })) }(), function () { "use strict"; var e = i(755); window.matchMedia("(max-width: 575px)").matches ? e(".header__lang-seleced").on("click", (function () { e(this).parent().toggleClass("open") })) : e(".header__lang-dropdown, .header__lang-seleced").on({ mouseenter: function () { e(this).parent().addClass("open") }, mouseleave: function () { e(this).parent().removeClass("open") } }), e("document").mouseup((function (t) { var i = e(".header__lang"); i.is(t.target) || 0 !== i.has(t.target).length || i.removeClass("open") })), e(".footer__lang-active").on("click", (function () { e(this).parent().find(".footer__lang-dropdown").slideToggle() })), e(document).mouseup((function (t) { var i = e(".header__lang-seleced, .header__lang-dropdown, .footer__lang-active"); i.is(t.target) || 0 !== i.has(t.target).length || (e(".header__lang").removeClass("open"), e(".footer__lang-dropdown").slideUp()) })) }(), function () { "use strict"; var e = i(755), t = i(755); e(document).ready((function () { !function (e) { e(".tab .tabs").addClass("active").find("> .tab-item:eq(0)").addClass("current"); var t = function (t) { var i = e(this).closest(".tab"), n = e(this).closest(".tab-item").index(); i.find(".tabs > .tab-item").removeClass("current"), e(this).closest(".tab-item").addClass("current"), i.find(".tab-content").find("div.tab-content-item").not("div.tab-content-item:eq(" + n + ")").hide(), i.find(".tab-content").find("div.tab-content-item:eq(" + n + ")").css("display", "flex"), t.preventDefault() }; e(".header__menu-item .tab .tab-item a").hover(t), e(".transfer .tab .tab-item a, .clickable-tabs .tab .tab-item a").click(t) }(t), e(".attachment-trigger-js--hover, .header__item-dropdown,.header__item-content").on({ mouseenter: function () { e(".attachment-trigger-js").not(this).parent().removeClass("open"), e(this).parent().addClass("open") }, mouseleave: function () { e(".attachment-trigger-js").not(this).parent().removeClass("open"), e(this).parent().removeClass("open") } }), e(document).mouseup((function (t) { var i = e(".attachment-trigger-js, .header__item-content"); i.is(t.target) || 0 !== i.has(t.target).length || e(".has-attachment").removeClass("open") })) })) }(), function () { "use strict"; var e = i(755); e(".show-pass").on("click", (function () { e(this).hide(), e(".hide-pass").css("display", "flex"), e("#pass").attr("type", "text") })), e(".hide-pass").on("click", (function () { e(this).hide(), e(".show-pass").css("display", "flex"), e("#pass").attr("type", "password") })) }(), function () { "use strict"; for (var e = i(755)(".payment-system__list-item"), t = 0; t < e.length; t += 4)e.slice(t, t + 4).wrapAll('<div class="payment-system__list-wrap">') }(), function () { "use strict"; const e = e => "object" == typeof e && null !== e && e.constructor === Object && "[object Object]" === Object.prototype.toString.call(e), t = (...i) => { let n = !1; "boolean" == typeof i[0] && (n = i.shift()); let s = i[0]; if (!s || "object" != typeof s) throw new Error("extendee must be an object"); const a = i.slice(1), o = a.length; for (let i = 0; i < o; i++) { const o = a[i]; for (let i in o) if (o.hasOwnProperty(i)) { const a = o[i]; if (n && (Array.isArray(a) || e(a))) { const e = Array.isArray(a) ? [] : {}; s[i] = t(!0, s.hasOwnProperty(i) ? s[i] : e, a) } else s[i] = a } } return s }, n = (e, t = 1e4) => (e = parseFloat(e) || 0, Math.round((e + Number.EPSILON) * t) / t), s = function (e) { return !!(e && "object" == typeof e && e instanceof Element && e !== document.body) && !e.__Panzoom && (function (e) { const t = getComputedStyle(e)["overflow-y"], i = getComputedStyle(e)["overflow-x"], n = ("scroll" === t || "auto" === t) && Math.abs(e.scrollHeight - e.clientHeight) > 1, s = ("scroll" === i || "auto" === i) && Math.abs(e.scrollWidth - e.clientWidth) > 1; return n || s }(e) ? e : s(e.parentNode)) }, a = "undefined" != typeof window && window.ResizeObserver || class { constructor(e) { this.observables = [], this.boundCheck = this.check.bind(this), this.boundCheck(), this.callback = e } observe(e) { if (this.observables.some((t => t.el === e))) return; const t = { el: e, size: { height: e.clientHeight, width: e.clientWidth } }; this.observables.push(t) } unobserve(e) { this.observables = this.observables.filter((t => t.el !== e)) } disconnect() { this.observables = [] } check() { const e = this.observables.filter((e => { const t = e.el.clientHeight, i = e.el.clientWidth; if (e.size.height !== t || e.size.width !== i) return e.size.height = t, e.size.width = i, !0 })).map((e => e.el)); e.length > 0 && this.callback(e), window.requestAnimationFrame(this.boundCheck) } }; class o { constructor(e) { this.id = self.Touch && e instanceof Touch ? e.identifier : -1, this.pageX = e.pageX, this.pageY = e.pageY, this.clientX = e.clientX, this.clientY = e.clientY } } const r = (e, t) => t ? Math.sqrt((t.clientX - e.clientX) ** 2 + (t.clientY - e.clientY) ** 2) : 0, l = (e, t) => t ? { clientX: (e.clientX + t.clientX) / 2, clientY: (e.clientY + t.clientY) / 2 } : e; class c { constructor(e, { start: t = (() => !0), move: i = (() => { }), end: n = (() => { }) } = {}) { this._element = e, this.startPointers = [], this.currentPointers = [], this._pointerStart = e => { if (e.buttons > 0 && 0 !== e.button) return; const t = new o(e); this.currentPointers.some((e => e.id === t.id)) || this._triggerPointerStart(t, e) && (window.addEventListener("mousemove", this._move), window.addEventListener("mouseup", this._pointerEnd)) }, this._touchStart = e => { for (const t of Array.from(e.changedTouches || [])) this._triggerPointerStart(new o(t), e) }, this._move = e => { const t = this.currentPointers.slice(), i = (e => "changedTouches" in e)(e) ? Array.from(e.changedTouches).map((e => new o(e))) : [new o(e)]; for (const e of i) { const t = this.currentPointers.findIndex((t => t.id === e.id)); t < 0 || (this.currentPointers[t] = e) } this._moveCallback(t, this.currentPointers.slice(), e) }, this._triggerPointerEnd = (e, t) => { const i = this.currentPointers.findIndex((t => t.id === e.id)); return !(i < 0 || (this.currentPointers.splice(i, 1), this.startPointers.splice(i, 1), this._endCallback(e, t), 0)) }, this._pointerEnd = e => { e.buttons > 0 && 0 !== e.button || this._triggerPointerEnd(new o(e), e) && (window.removeEventListener("mousemove", this._move, { passive: !1 }), window.removeEventListener("mouseup", this._pointerEnd, { passive: !1 })) }, this._touchEnd = e => { for (const t of Array.from(e.changedTouches || [])) this._triggerPointerEnd(new o(t), e) }, this._startCallback = t, this._moveCallback = i, this._endCallback = n, this._element.addEventListener("mousedown", this._pointerStart, { passive: !1 }), this._element.addEventListener("touchstart", this._touchStart, { passive: !1 }), this._element.addEventListener("touchmove", this._move, { passive: !1 }), this._element.addEventListener("touchend", this._touchEnd), this._element.addEventListener("touchcancel", this._touchEnd) } stop() { this._element.removeEventListener("mousedown", this._pointerStart, { passive: !1 }), this._element.removeEventListener("touchstart", this._touchStart, { passive: !1 }), this._element.removeEventListener("touchmove", this._move, { passive: !1 }), this._element.removeEventListener("touchend", this._touchEnd), this._element.removeEventListener("touchcancel", this._touchEnd), window.removeEventListener("mousemove", this._move), window.removeEventListener("mouseup", this._pointerEnd) } _triggerPointerStart(e, t) { return !!this._startCallback(e, t) && (this.currentPointers.push(e), this.startPointers.push(e), !0) } } class d { constructor(e = {}) { this.options = t(!0, {}, e), this.plugins = [], this.events = {}; for (const e of ["on", "once"]) for (const t of Object.entries(this.options[e] || {})) this[e](...t) } option(e, t, ...i) { let n = (s = e = String(e), a = this.options, s.split(".").reduce((function (e, t) { return e && e[t] }), a)); var s, a; return "function" == typeof n && (n = n.call(this, this, ...i)), void 0 === n ? t : n } localize(e, t = []) { return (e = String(e).replace(/\{\{(\w+).?(\w+)?\}\}/g, ((e, i, n) => { let s = ""; n ? s = this.option(`${i[0] + i.toLowerCase().substring(1)}.l10n.${n}`) : i && (s = this.option(`l10n.${i}`)), s || (s = e); for (let e = 0; e < t.length; e++)s = s.split(t[e][0]).join(t[e][1]); return s }))).replace(/\{\{(.*)\}\}/, ((e, t) => t)) } on(t, i) { if (e(t)) { for (const e of Object.entries(t)) this.on(...e); return this } return String(t).split(" ").forEach((e => { const t = this.events[e] = this.events[e] || []; -1 == t.indexOf(i) && t.push(i) })), this } once(t, i) { if (e(t)) { for (const e of Object.entries(t)) this.once(...e); return this } return String(t).split(" ").forEach((e => { const t = (...n) => { this.off(e, t), i.call(this, this, ...n) }; t._ = i, this.on(e, t) })), this } off(t, i) { if (!e(t)) return t.split(" ").forEach((e => { const t = this.events[e]; if (!t || !t.length) return this; let n = -1; for (let e = 0, s = t.length; e < s; e++) { const s = t[e]; if (s && (s === i || s._ === i)) { n = e; break } } -1 != n && t.splice(n, 1) })), this; for (const e of Object.entries(t)) this.off(...e) } trigger(e, ...t) { for (const i of [...this.events[e] || []].slice()) if (i && !1 === i.call(this, this, ...t)) return !1; for (const i of [...this.events["*"] || []].slice()) if (i && !1 === i.call(this, e, this, ...t)) return !1; return !0 } attachPlugins(e) { const i = {}; for (const [n, s] of Object.entries(e || {})) !1 === this.options[n] || this.plugins[n] || (this.options[n] = t({}, s.defaults || {}, this.options[n]), i[n] = new s(this)); for (const [e, t] of Object.entries(i)) t.attach(this); return this.plugins = Object.assign({}, this.plugins, i), this } detachPlugins() { for (const e in this.plugins) { let t; (t = this.plugins[e]) && "function" == typeof t.detach && t.detach(this) } return this.plugins = {}, this } } const h = { touch: !0, zoom: !0, pinchToZoom: !0, panOnlyZoomed: !1, lockAxis: !1, friction: .64, decelFriction: .88, zoomFriction: .74, bounceForce: .2, baseScale: 1, minScale: 1, maxScale: 2, step: .5, textSelection: !1, click: "toggleZoom", wheel: "zoom", wheelFactor: 42, wheelLimit: 5, draggableClass: "is-draggable", draggingClass: "is-dragging", ratio: 1 }; class u extends d { constructor(e, i = {}) { super(t(!0, {}, h, i)), this.state = "init", this.$container = e; for (const e of ["onLoad", "onWheel", "onClick"]) this[e] = this[e].bind(this); this.initLayout(), this.resetValues(), this.attachPlugins(u.Plugins), this.trigger("init"), this.updateMetrics(), this.attachEvents(), this.trigger("ready"), !1 === this.option("centerOnStart") ? this.state = "ready" : this.panTo({ friction: 0 }), e.__Panzoom = this } initLayout() { const e = this.$container; if (!(e instanceof HTMLElement)) throw new Error("Panzoom: Container not found"); const t = this.option("content") || e.querySelector(".panzoom__content"); if (!t) throw new Error("Panzoom: Content not found"); this.$content = t; let i = this.option("viewport") || e.querySelector(".panzoom__viewport"); i || !1 === this.option("wrapInner") || (i = document.createElement("div"), i.classList.add("panzoom__viewport"), i.append(...e.childNodes), e.appendChild(i)), this.$viewport = i || t.parentNode } resetValues() { this.updateRate = this.option("updateRate", /iPhone|iPad|iPod|Android/i.test(navigator.userAgent) ? 250 : 24), this.container = { width: 0, height: 0 }, this.viewport = { width: 0, height: 0 }, this.content = { origWidth: 0, origHeight: 0, width: 0, height: 0, x: this.option("x", 0), y: this.option("y", 0), scale: this.option("baseScale") }, this.transform = { x: 0, y: 0, scale: 1 }, this.resetDragPosition() } onLoad(e) { this.updateMetrics(), this.panTo({ scale: this.option("baseScale"), friction: 0 }), this.trigger("load", e) } onClick(e) { if (e.defaultPrevented) return; if (document.activeElement && document.activeElement.closest("[contenteditable]")) return; if (this.option("textSelection") && window.getSelection().toString().length && (!e.target || !e.target.hasAttribute("data-fancybox-close"))) return void e.stopPropagation(); const t = this.$content.getClientRects()[0]; if ("ready" !== this.state && (this.dragPosition.midPoint || Math.abs(t.top - this.dragStart.rect.top) > 1 || Math.abs(t.left - this.dragStart.rect.left) > 1)) return e.preventDefault(), void e.stopPropagation(); !1 !== this.trigger("click", e) && this.option("zoom") && "toggleZoom" === this.option("click") && (e.preventDefault(), e.stopPropagation(), this.zoomWithClick(e)) } onWheel(e) { !1 !== this.trigger("wheel", e) && this.option("zoom") && this.option("wheel") && this.zoomWithWheel(e) } zoomWithWheel(e) { void 0 === this.changedDelta && (this.changedDelta = 0); const t = Math.max(-1, Math.min(1, -e.deltaY || -e.deltaX || e.wheelDelta || -e.detail)), i = this.content.scale; let n = i * (100 + t * this.option("wheelFactor")) / 100; if (t < 0 && Math.abs(i - this.option("minScale")) < .01 || t > 0 && Math.abs(i - this.option("maxScale")) < .01 ? (this.changedDelta += Math.abs(t), n = i) : (this.changedDelta = 0, n = Math.max(Math.min(n, this.option("maxScale")), this.option("minScale"))), this.changedDelta > this.option("wheelLimit")) return; if (e.preventDefault(), n === i) return; const s = this.$content.getBoundingClientRect(), a = e.clientX - s.left, o = e.clientY - s.top; this.zoomTo(n, { x: a, y: o }) } zoomWithClick(e) { const t = this.$content.getClientRects()[0], i = e.clientX - t.left, n = e.clientY - t.top; this.toggleZoom({ x: i, y: n }) } attachEvents() { this.$content.addEventListener("load", this.onLoad), this.$container.addEventListener("wheel", this.onWheel, { passive: !1 }), this.$container.addEventListener("click", this.onClick, { passive: !1 }), this.initObserver(); const e = new c(this.$container, { start: (t, i) => { if (!this.option("touch")) return !1; if (this.velocity.scale < 0) return !1; const n = i.composedPath()[0]; if (!e.currentPointers.length) { if (-1 !== ["BUTTON", "TEXTAREA", "OPTION", "INPUT", "SELECT", "VIDEO"].indexOf(n.nodeName)) return !1; if (this.option("textSelection") && ((e, t, i) => { const n = e.childNodes, s = document.createRange(); for (let e = 0; e < n.length; e++) { const a = n[e]; if (a.nodeType !== Node.TEXT_NODE) continue; s.selectNodeContents(a); const o = s.getBoundingClientRect(); if (t >= o.left && i >= o.top && t <= o.right && i <= o.bottom) return a } return !1 })(n, t.clientX, t.clientY)) return !1 } return !s(n) && !1 !== this.trigger("touchStart", i) && ("mousedown" === i.type && i.preventDefault(), this.state = "pointerdown", this.resetDragPosition(), this.dragPosition.midPoint = null, this.dragPosition.time = Date.now(), !0) }, move: (t, i, n) => { if ("pointerdown" !== this.state) return; if (!1 === this.trigger("touchMove", n)) return void n.preventDefault(); if (i.length < 2 && !0 === this.option("panOnlyZoomed") && this.content.width <= this.viewport.width && this.content.height <= this.viewport.height && this.transform.scale <= this.option("baseScale")) return; if (i.length > 1 && (!this.option("zoom") || !1 === this.option("pinchToZoom"))) return; const s = l(t[0], t[1]), a = l(i[0], i[1]), o = a.clientX - s.clientX, c = a.clientY - s.clientY, d = r(t[0], t[1]), h = r(i[0], i[1]), u = d && h ? h / d : 1; this.dragOffset.x += o, this.dragOffset.y += c, this.dragOffset.scale *= u, this.dragOffset.time = Date.now() - this.dragPosition.time; const p = 1 === this.dragStart.scale && this.option("lockAxis"); if (p && !this.lockAxis) { if (Math.abs(this.dragOffset.x) < 6 && Math.abs(this.dragOffset.y) < 6) return void n.preventDefault(); const e = Math.abs(180 * Math.atan2(this.dragOffset.y, this.dragOffset.x) / Math.PI); this.lockAxis = e > 45 && e < 135 ? "y" : "x" } if ("xy" === p || "y" !== this.lockAxis) { if (n.preventDefault(), n.stopPropagation(), n.stopImmediatePropagation(), this.lockAxis && (this.dragOffset["x" === this.lockAxis ? "y" : "x"] = 0), this.$container.classList.add(this.option("draggingClass")), this.transform.scale === this.option("baseScale") && "y" === this.lockAxis || (this.dragPosition.x = this.dragStart.x + this.dragOffset.x), this.transform.scale === this.option("baseScale") && "x" === this.lockAxis || (this.dragPosition.y = this.dragStart.y + this.dragOffset.y), this.dragPosition.scale = this.dragStart.scale * this.dragOffset.scale, i.length > 1) { const t = l(e.startPointers[0], e.startPointers[1]), i = t.clientX - this.dragStart.rect.x, n = t.clientY - this.dragStart.rect.y, { deltaX: s, deltaY: o } = this.getZoomDelta(this.content.scale * this.dragOffset.scale, i, n); this.dragPosition.x -= s, this.dragPosition.y -= o, this.dragPosition.midPoint = a } else this.setDragResistance(); this.transform = { x: this.dragPosition.x, y: this.dragPosition.y, scale: this.dragPosition.scale }, this.startAnimation() } }, end: (t, i) => { if ("pointerdown" !== this.state) return; if (this._dragOffset = { ...this.dragOffset }, e.currentPointers.length) return void this.resetDragPosition(); if (this.state = "decel", this.friction = this.option("decelFriction"), this.recalculateTransform(), this.$container.classList.remove(this.option("draggingClass")), !1 === this.trigger("touchEnd", i)) return; if ("decel" !== this.state) return; const n = this.option("minScale"); if (this.transform.scale < n) return void this.zoomTo(n, { friction: .64 }); const s = this.option("maxScale"); if (this.transform.scale - s > .01) { const e = this.dragPosition.midPoint || t, i = this.$content.getClientRects()[0]; this.zoomTo(s, { friction: .64, x: e.clientX - i.left, y: e.clientY - i.top }) } } }); this.pointerTracker = e } initObserver() { this.resizeObserver || (this.resizeObserver = new a((() => { this.updateTimer || (this.updateTimer = setTimeout((() => { const e = this.$container.getBoundingClientRect(); e.width && e.height ? ((Math.abs(e.width - this.container.width) > 1 || Math.abs(e.height - this.container.height) > 1) && (this.isAnimating() && this.endAnimation(!0), this.updateMetrics(), this.panTo({ x: this.content.x, y: this.content.y, scale: this.option("baseScale"), friction: 0 })), this.updateTimer = null) : this.updateTimer = null }), this.updateRate)) })), this.resizeObserver.observe(this.$container)) } resetDragPosition() { this.lockAxis = null, this.friction = this.option("friction"), this.velocity = { x: 0, y: 0, scale: 0 }; const { x: e, y: t, scale: i } = this.content; this.dragStart = { rect: this.$content.getBoundingClientRect(), x: e, y: t, scale: i }, this.dragPosition = { ...this.dragPosition, x: e, y: t, scale: i }, this.dragOffset = { x: 0, y: 0, scale: 1, time: 0 } } updateMetrics(e) { !0 !== e && this.trigger("beforeUpdate"); const t = this.$container, i = this.$content, s = this.$viewport, a = i instanceof HTMLImageElement, o = this.option("zoom"), r = this.option("resizeParent", o); let l = this.option("width"), c = this.option("height"), d = l || (h = i, Math.max(parseFloat(h.naturalWidth || 0), parseFloat(h.width && h.width.baseVal && h.width.baseVal.value || 0), parseFloat(h.offsetWidth || 0), parseFloat(h.scrollWidth || 0))); var h; let u = c || (e => Math.max(parseFloat(e.naturalHeight || 0), parseFloat(e.height && e.height.baseVal && e.height.baseVal.value || 0), parseFloat(e.offsetHeight || 0), parseFloat(e.scrollHeight || 0)))(i); Object.assign(i.style, { width: l ? `${l}px` : "", height: c ? `${c}px` : "", maxWidth: "", maxHeight: "" }), r && Object.assign(s.style, { width: "", height: "" }); const p = this.option("ratio"); d = n(d * p), u = n(u * p), l = d, c = u; const f = i.getBoundingClientRect(), m = s.getBoundingClientRect(), g = s == t ? m : t.getBoundingClientRect(); let v = Math.max(s.offsetWidth, n(m.width)), y = Math.max(s.offsetHeight, n(m.height)), b = window.getComputedStyle(s); if (v -= parseFloat(b.paddingLeft) + parseFloat(b.paddingRight), y -= parseFloat(b.paddingTop) + parseFloat(b.paddingBottom), this.viewport.width = v, this.viewport.height = y, o) { if (Math.abs(d - f.width) > .1 || Math.abs(u - f.height) > .1) { const e = ((e, t, i, n) => { const s = Math.min(i / e || 0, n / t); return { width: e * s || 0, height: t * s || 0 } })(d, u, Math.min(d, f.width), Math.min(u, f.height)); l = n(e.width), c = n(e.height) } Object.assign(i.style, { width: `${l}px`, height: `${c}px`, transform: "" }) } if (r && (Object.assign(s.style, { width: `${l}px`, height: `${c}px` }), this.viewport = { ...this.viewport, width: l, height: c }), a && o && "function" != typeof this.options.maxScale) { const e = this.option("maxScale"); this.options.maxScale = function () { return this.content.origWidth > 0 && this.content.fitWidth > 0 ? this.content.origWidth / this.content.fitWidth : e } } this.content = { ...this.content, origWidth: d, origHeight: u, fitWidth: l, fitHeight: c, width: l, height: c, scale: 1, isZoomable: o }, this.container = { width: g.width, height: g.height }, !0 !== e && this.trigger("afterUpdate") } zoomIn(e) { this.zoomTo(this.content.scale + (e || this.option("step"))) } zoomOut(e) { this.zoomTo(this.content.scale - (e || this.option("step"))) } toggleZoom(e = {}) { const t = this.option("maxScale"), i = this.option("baseScale"), n = this.content.scale > i + .5 * (t - i) ? i : t; this.zoomTo(n, e) } zoomTo(e = this.option("baseScale"), { x: t = null, y: i = null } = {}) { e = Math.max(Math.min(e, this.option("maxScale")), this.option("minScale")); const s = n(this.content.scale / (this.content.width / this.content.fitWidth), 1e7); null === t && (t = this.content.width * s * .5), null === i && (i = this.content.height * s * .5); const { deltaX: a, deltaY: o } = this.getZoomDelta(e, t, i); t = this.content.x - a, i = this.content.y - o, this.panTo({ x: t, y: i, scale: e, friction: this.option("zoomFriction") }) } getZoomDelta(e, t = 0, i = 0) { const n = this.content.fitWidth * this.content.scale, s = this.content.fitHeight * this.content.scale, a = t > 0 && n ? t / n : 0, o = i > 0 && s ? i / s : 0; return { deltaX: (this.content.fitWidth * e - n) * a, deltaY: (this.content.fitHeight * e - s) * o } } panTo({ x: e = this.content.x, y: t = this.content.y, scale: i, friction: n = this.option("friction"), ignoreBounds: s = !1 } = {}) { if (i = i || this.content.scale || 1, !s) { const { boundX: n, boundY: s } = this.getBounds(i); n && (e = Math.max(Math.min(e, n.to), n.from)), s && (t = Math.max(Math.min(t, s.to), s.from)) } this.friction = n, this.transform = { ...this.transform, x: e, y: t, scale: i }, n ? (this.state = "panning", this.velocity = { x: (1 / this.friction - 1) * (e - this.content.x), y: (1 / this.friction - 1) * (t - this.content.y), scale: (1 / this.friction - 1) * (i - this.content.scale) }, this.startAnimation()) : this.endAnimation() } startAnimation() { this.rAF ? cancelAnimationFrame(this.rAF) : this.trigger("startAnimation"), this.rAF = requestAnimationFrame((() => this.animate())) } animate() { if (this.setEdgeForce(), this.setDragForce(), this.velocity.x *= this.friction, this.velocity.y *= this.friction, this.velocity.scale *= this.friction, this.content.x += this.velocity.x, this.content.y += this.velocity.y, this.content.scale += this.velocity.scale, this.isAnimating()) this.setTransform(); else if ("pointerdown" !== this.state) return void this.endAnimation(); this.rAF = requestAnimationFrame((() => this.animate())) } getBounds(e) { let t = this.boundX, i = this.boundY; if (void 0 !== t && void 0 !== i) return { boundX: t, boundY: i }; t = { from: 0, to: 0 }, i = { from: 0, to: 0 }, e = e || this.transform.scale; const s = this.content.fitWidth * e, a = this.content.fitHeight * e, o = this.viewport.width, r = this.viewport.height; if (s < o) { const e = n(.5 * (o - s)); t.from = e, t.to = e } else t.from = n(o - s); if (a < r) { const e = .5 * (r - a); i.from = e, i.to = e } else i.from = n(r - a); return { boundX: t, boundY: i } } setEdgeForce() { if ("decel" !== this.state) return; const e = this.option("bounceForce"), { boundX: t, boundY: i } = this.getBounds(Math.max(this.transform.scale, this.content.scale)); let n, s, a, o; if (t && (n = this.content.x < t.from, s = this.content.x > t.to), i && (a = this.content.y < i.from, o = this.content.y > i.to), n || s) { let i = ((n ? t.from : t.to) - this.content.x) * e; const s = this.content.x + (this.velocity.x + i) / this.friction; s >= t.from && s <= t.to && (i += this.velocity.x), this.velocity.x = i, this.recalculateTransform() } if (a || o) { let t = ((a ? i.from : i.to) - this.content.y) * e; const n = this.content.y + (t + this.velocity.y) / this.friction; n >= i.from && n <= i.to && (t += this.velocity.y), this.velocity.y = t, this.recalculateTransform() } } setDragResistance() { if ("pointerdown" !== this.state) return; const { boundX: e, boundY: t } = this.getBounds(this.dragPosition.scale); let i, n, s, a; if (e && (i = this.dragPosition.x < e.from, n = this.dragPosition.x > e.to), t && (s = this.dragPosition.y < t.from, a = this.dragPosition.y > t.to), (i || n) && (!i || !n)) { const t = i ? e.from : e.to, n = t - this.dragPosition.x; this.dragPosition.x = t - .3 * n } if ((s || a) && (!s || !a)) { const e = s ? t.from : t.to, i = e - this.dragPosition.y; this.dragPosition.y = e - .3 * i } } setDragForce() { "pointerdown" === this.state && (this.velocity.x = this.dragPosition.x - this.content.x, this.velocity.y = this.dragPosition.y - this.content.y, this.velocity.scale = this.dragPosition.scale - this.content.scale) } recalculateTransform() { this.transform.x = this.content.x + this.velocity.x / (1 / this.friction - 1), this.transform.y = this.content.y + this.velocity.y / (1 / this.friction - 1), this.transform.scale = this.content.scale + this.velocity.scale / (1 / this.friction - 1) } isAnimating() { return !(!this.friction || !(Math.abs(this.velocity.x) > .05 || Math.abs(this.velocity.y) > .05 || Math.abs(this.velocity.scale) > .05)) } setTransform(e) { let t, i, s; if (e ? (t = n(this.transform.x), i = n(this.transform.y), s = this.transform.scale, this.content = { ...this.content, x: t, y: i, scale: s }) : (t = n(this.content.x), i = n(this.content.y), s = this.content.scale / (this.content.width / this.content.fitWidth), this.content = { ...this.content, x: t, y: i }), this.trigger("beforeTransform"), t = n(this.content.x), i = n(this.content.y), e && this.option("zoom")) { let e, a; e = n(this.content.fitWidth * s), a = n(this.content.fitHeight * s), this.content.width = e, this.content.height = a, this.transform = { ...this.transform, width: e, height: a, scale: s }, Object.assign(this.$content.style, { width: `${e}px`, height: `${a}px`, maxWidth: "none", maxHeight: "none", transform: `translate3d(${t}px, ${i}px, 0) scale(1)` }) } else this.$content.style.transform = `translate3d(${t}px, ${i}px, 0) scale(${s})`; this.trigger("afterTransform") } endAnimation(e) { cancelAnimationFrame(this.rAF), this.rAF = null, this.velocity = { x: 0, y: 0, scale: 0 }, this.setTransform(!0), this.state = "ready", this.handleCursor(), !0 !== e && this.trigger("endAnimation") } handleCursor() { const e = this.option("draggableClass"); e && this.option("touch") && (1 == this.option("panOnlyZoomed") && this.content.width <= this.viewport.width && this.content.height <= this.viewport.height && this.transform.scale <= this.option("baseScale") ? this.$container.classList.remove(e) : this.$container.classList.add(e)) } detachEvents() { this.$content.removeEventListener("load", this.onLoad), this.$container.removeEventListener("wheel", this.onWheel, { passive: !1 }), this.$container.removeEventListener("click", this.onClick, { passive: !1 }), this.pointerTracker && (this.pointerTracker.stop(), this.pointerTracker = null), this.resizeObserver && (this.resizeObserver.disconnect(), this.resizeObserver = null) } destroy() { "destroy" !== this.state && (this.state = "destroy", clearTimeout(this.updateTimer), this.updateTimer = null, cancelAnimationFrame(this.rAF), this.rAF = null, this.detachEvents(), this.detachPlugins(), this.resetDragPosition()) } } u.version = "4.0.31", u.Plugins = {}; const p = (e, t) => { let i = 0; return function (...n) { const s = (new Date).getTime(); if (!(s - i < t)) return i = s, e(...n) } }; class f { constructor(e) { this.$container = null, this.$prev = null, this.$next = null, this.carousel = e, this.onRefresh = this.onRefresh.bind(this) } option(e) { return this.carousel.option(`Navigation.${e}`) } createButton(e) { const t = document.createElement("button"); t.setAttribute("title", this.carousel.localize(`{{${e.toUpperCase()}}}`)); const i = this.option("classNames.button") + " " + this.option(`classNames.${e}`); return t.classList.add(...i.split(" ")), t.setAttribute("tabindex", "0"), t.innerHTML = this.carousel.localize(this.option(`${e}Tpl`)), t.addEventListener("click", (t => { t.preventDefault(), t.stopPropagation(), this.carousel["slide" + ("next" === e ? "Next" : "Prev")]() })), t } build() { this.$container || (this.$container = document.createElement("div"), this.$container.classList.add(...this.option("classNames.main").split(" ")), this.carousel.$container.appendChild(this.$container)), this.$next || (this.$next = this.createButton("next"), this.$container.appendChild(this.$next)), this.$prev || (this.$prev = this.createButton("prev"), this.$container.appendChild(this.$prev)) } onRefresh() { const e = this.carousel.pages.length; e <= 1 || e > 1 && this.carousel.elemDimWidth < this.carousel.wrapDimWidth && !Number.isInteger(this.carousel.option("slidesPerPage")) ? this.cleanup() : (this.build(), this.$prev.removeAttribute("disabled"), this.$next.removeAttribute("disabled"), this.carousel.option("infiniteX", this.carousel.option("infinite")) || (this.carousel.page <= 0 && this.$prev.setAttribute("disabled", ""), this.carousel.page >= e - 1 && this.$next.setAttribute("disabled", ""))) } cleanup() { this.$prev && this.$prev.remove(), this.$prev = null, this.$next && this.$next.remove(), this.$next = null, this.$container && this.$container.remove(), this.$container = null } attach() { this.carousel.on("refresh change", this.onRefresh) } detach() { this.carousel.off("refresh change", this.onRefresh), this.cleanup() } } f.defaults = { prevTpl: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" tabindex="-1"><path d="M15 3l-9 9 9 9"/></svg>', nextTpl: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" tabindex="-1"><path d="M9 3l9 9-9 9"/></svg>', classNames: { main: "carousel__nav", button: "carousel__button", next: "is-next", prev: "is-prev" } }; class m { constructor(e) { this.carousel = e, this.selectedIndex = null, this.friction = 0, this.onNavReady = this.onNavReady.bind(this), this.onNavClick = this.onNavClick.bind(this), this.onNavCreateSlide = this.onNavCreateSlide.bind(this), this.onTargetChange = this.onTargetChange.bind(this) } addAsTargetFor(e) { this.target = this.carousel, this.nav = e, this.attachEvents() } addAsNavFor(e) { this.target = e, this.nav = this.carousel, this.attachEvents() } attachEvents() { this.nav.options.initialSlide = this.target.options.initialPage, this.nav.on("ready", this.onNavReady), this.nav.on("createSlide", this.onNavCreateSlide), this.nav.on("Panzoom.click", this.onNavClick), this.target.on("change", this.onTargetChange), this.target.on("Panzoom.afterUpdate", this.onTargetChange) } onNavReady() { this.onTargetChange(!0) } onNavClick(e, t, i) { const n = i.target.closest(".carousel__slide"); if (!n) return; i.stopPropagation(); const s = parseInt(n.dataset.index, 10), a = this.target.findPageForSlide(s); this.target.page !== a && this.target.slideTo(a, { friction: this.friction }), this.markSelectedSlide(s) } onNavCreateSlide(e, t) { t.index === this.selectedIndex && this.markSelectedSlide(t.index) } onTargetChange() { const e = this.target.pages[this.target.page].indexes[0], t = this.nav.findPageForSlide(e); this.nav.slideTo(t), this.markSelectedSlide(e) } markSelectedSlide(e) { this.selectedIndex = e, [...this.nav.slides].filter((e => e.$el && e.$el.classList.remove("is-nav-selected"))); const t = this.nav.slides[e]; t && t.$el && t.$el.classList.add("is-nav-selected") } attach(e) { const t = e.options.Sync; (t.target || t.nav) && (t.target ? this.addAsNavFor(t.target) : t.nav && this.addAsTargetFor(t.nav), this.friction = t.friction) } detach() { this.nav && (this.nav.off("ready", this.onNavReady), this.nav.off("Panzoom.click", this.onNavClick), this.nav.off("createSlide", this.onNavCreateSlide)), this.target && (this.target.off("Panzoom.afterUpdate", this.onTargetChange), this.target.off("change", this.onTargetChange)) } } m.defaults = { friction: .92 }; const g = { Navigation: f, Dots: class { constructor(e) { this.carousel = e, this.$list = null, this.events = { change: this.onChange.bind(this), refresh: this.onRefresh.bind(this) } } buildList() { if (this.carousel.pages.length < this.carousel.option("Dots.minSlideCount")) return; const e = document.createElement("ol"); return e.classList.add("carousel__dots"), e.addEventListener("click", (e => { if (!("page" in e.target.dataset)) return; e.preventDefault(), e.stopPropagation(); const t = parseInt(e.target.dataset.page, 10), i = this.carousel; t !== i.page && (i.pages.length < 3 && i.option("infinite") ? i[0 == t ? "slidePrev" : "slideNext"]() : i.slideTo(t)) })), this.$list = e, this.carousel.$container.appendChild(e), this.carousel.$container.classList.add("has-dots"), e } removeList() { this.$list && (this.$list.parentNode.removeChild(this.$list), this.$list = null), this.carousel.$container.classList.remove("has-dots") } rebuildDots() { let e = this.$list; const t = !!e, i = this.carousel.pages.length; if (i < 2) return void (t && this.removeList()); t || (e = this.buildList()); const n = this.$list.children.length; if (n > i) for (let e = i; e < n; e++)this.$list.removeChild(this.$list.lastChild); else { for (let e = n; e < i; e++) { const t = document.createElement("li"); t.classList.add("carousel__dot"), t.dataset.page = e, t.setAttribute("role", "button"), t.setAttribute("tabindex", "0"), t.setAttribute("title", this.carousel.localize("{{GOTO}}", [["%d", e + 1]])), t.addEventListener("keydown", (e => { const i = e.code; let n; "Enter" === i || "NumpadEnter" === i ? n = t : "ArrowRight" === i ? n = t.nextSibling : "ArrowLeft" === i && (n = t.previousSibling), n && n.click() })), this.$list.appendChild(t) } this.setActiveDot() } } setActiveDot() { if (!this.$list) return; this.$list.childNodes.forEach((e => { e.classList.remove("is-selected") })); const e = this.$list.childNodes[this.carousel.page]; e && e.classList.add("is-selected") } onChange() { this.setActiveDot() } onRefresh() { this.rebuildDots() } attach() { this.carousel.on(this.events) } detach() { this.removeList(), this.carousel.off(this.events), this.carousel = null } }, Sync: m }, v = { slides: [], preload: 0, slidesPerPage: "auto", initialPage: null, initialSlide: null, friction: .92, center: !0, infinite: !0, fill: !0, dragFree: !1, prefix: "", classNames: { viewport: "carousel__viewport", track: "carousel__track", slide: "carousel__slide", slideSelected: "is-selected" }, l10n: { NEXT: "Next slide", PREV: "Previous slide", GOTO: "Go to slide #%d" } }; class y extends d { constructor(e, i = {}) { if (super(i = t(!0, {}, v, i)), this.state = "init", this.$container = e, !(this.$container instanceof HTMLElement)) throw new Error("No root element provided"); this.slideNext = p(this.slideNext.bind(this), 250), this.slidePrev = p(this.slidePrev.bind(this), 250), this.init(), e.__Carousel = this } init() { this.pages = [], this.page = this.pageIndex = null, this.prevPage = this.prevPageIndex = null, this.attachPlugins(y.Plugins), this.trigger("init"), this.initLayout(), this.initSlides(), this.updateMetrics(), this.$track && this.pages.length && (this.$track.style.transform = `translate3d(${-1 * this.pages[this.page].left}px, 0px, 0) scale(1)`), this.manageSlideVisiblity(), this.initPanzoom(), this.state = "ready", this.trigger("ready") } initLayout() { const e = this.option("prefix"), t = this.option("classNames"); this.$viewport = this.option("viewport") || this.$container.querySelector(`.${e}${t.viewport}`), this.$viewport || (this.$viewport = document.createElement("div"), this.$viewport.classList.add(...(e + t.viewport).split(" ")), this.$viewport.append(...this.$container.childNodes), this.$container.appendChild(this.$viewport)), this.$track = this.option("track") || this.$container.querySelector(`.${e}${t.track}`), this.$track || (this.$track = document.createElement("div"), this.$track.classList.add(...(e + t.track).split(" ")), this.$track.append(...this.$viewport.childNodes), this.$viewport.appendChild(this.$track)) } initSlides() { this.slides = [], this.$viewport.querySelectorAll(`.${this.option("prefix")}${this.option("classNames.slide")}`).forEach((e => { const t = { $el: e, isDom: !0 }; this.slides.push(t), this.trigger("createSlide", t, this.slides.length) })), Array.isArray(this.options.slides) && (this.slides = t(!0, [...this.slides], this.options.slides)) } updateMetrics() { let e, t = 0, i = []; this.slides.forEach(((n, s) => { const a = n.$el, o = n.isDom || !e ? this.getSlideMetrics(a) : e; n.index = s, n.width = o, n.left = t, e = o, t += o, i.push(s) })); let s = Math.max(this.$track.offsetWidth, n(this.$track.getBoundingClientRect().width)), a = getComputedStyle(this.$track); s -= parseFloat(a.paddingLeft) + parseFloat(a.paddingRight), this.contentWidth = t, this.viewportWidth = s; const o = [], r = this.option("slidesPerPage"); if (Number.isInteger(r) && t > s) for (let e = 0; e < this.slides.length; e += r)o.push({ indexes: i.slice(e, e + r), slides: this.slides.slice(e, e + r) }); else { let e = 0, t = 0; for (let i = 0; i < this.slides.length; i += 1) { let n = this.slides[i]; (!o.length || t + n.width > s) && (o.push({ indexes: [], slides: [] }), e = o.length - 1, t = 0), t += n.width, o[e].indexes.push(i), o[e].slides.push(n) } } const l = this.option("center"), c = this.option("fill"); o.forEach(((e, i) => { e.index = i, e.width = e.slides.reduce(((e, t) => e + t.width), 0), e.left = e.slides[0].left, l && (e.left += .5 * (s - e.width) * -1), c && !this.option("infiniteX", this.option("infinite")) && t > s && (e.left = Math.max(e.left, 0), e.left = Math.min(e.left, t - s)) })); const d = []; let h; o.forEach((e => { const t = { ...e }; h && t.left === h.left ? (h.width += t.width, h.slides = [...h.slides, ...t.slides], h.indexes = [...h.indexes, ...t.indexes]) : (t.index = d.length, h = t, d.push(t)) })), this.pages = d; let u = this.page; if (null === u) { const e = this.option("initialSlide"); u = null !== e ? this.findPageForSlide(e) : parseInt(this.option("initialPage", 0), 10) || 0, d[u] || (u = d.length && u > d.length ? d[d.length - 1].index : 0), this.page = u, this.pageIndex = u } this.updatePanzoom(), this.trigger("refresh") } getSlideMetrics(e) { if (!e) { const t = this.slides[0]; (e = document.createElement("div")).dataset.isTestEl = 1, e.style.visibility = "hidden", e.classList.add(...(this.option("prefix") + this.option("classNames.slide")).split(" ")), t.customClass && e.classList.add(...t.customClass.split(" ")), this.$track.prepend(e) } let t = Math.max(e.offsetWidth, n(e.getBoundingClientRect().width)); const i = e.currentStyle || window.getComputedStyle(e); return t = t + (parseFloat(i.marginLeft) || 0) + (parseFloat(i.marginRight) || 0), e.dataset.isTestEl && e.remove(), t } findPageForSlide(e) { e = parseInt(e, 10) || 0; const t = this.pages.find((t => t.indexes.indexOf(e) > -1)); return t ? t.index : null } slideNext() { this.slideTo(this.pageIndex + 1) } slidePrev() { this.slideTo(this.pageIndex - 1) } slideTo(e, t = {}) { const { x: i = -1 * this.setPage(e, !0), y: n = 0, friction: s = this.option("friction") } = t; this.Panzoom.content.x === i && !this.Panzoom.velocity.x && s || (this.Panzoom.panTo({ x: i, y: n, friction: s, ignoreBounds: !0 }), "ready" === this.state && "ready" === this.Panzoom.state && this.trigger("settle")) } initPanzoom() { this.Panzoom && this.Panzoom.destroy(); const e = t(!0, {}, { content: this.$track, wrapInner: !1, resizeParent: !1, zoom: !1, click: !1, lockAxis: "x", x: this.pages.length ? -1 * this.pages[this.page].left : 0, centerOnStart: !1, textSelection: () => this.option("textSelection", !1), panOnlyZoomed: function () { return this.content.width <= this.viewport.width } }, this.option("Panzoom")); this.Panzoom = new u(this.$container, e), this.Panzoom.on({ "*": (e, ...t) => this.trigger(`Panzoom.${e}`, ...t), afterUpdate: () => { this.updatePage() }, beforeTransform: this.onBeforeTransform.bind(this), touchEnd: this.onTouchEnd.bind(this), endAnimation: () => { this.trigger("settle") } }), this.updateMetrics(), this.manageSlideVisiblity() } updatePanzoom() { this.Panzoom && (this.Panzoom.content = { ...this.Panzoom.content, fitWidth: this.contentWidth, origWidth: this.contentWidth, width: this.contentWidth }, this.pages.length > 1 && this.option("infiniteX", this.option("infinite")) ? this.Panzoom.boundX = null : this.pages.length && (this.Panzoom.boundX = { from: -1 * this.pages[this.pages.length - 1].left, to: -1 * this.pages[0].left }), this.option("infiniteY", this.option("infinite")) ? this.Panzoom.boundY = null : this.Panzoom.boundY = { from: 0, to: 0 }, this.Panzoom.handleCursor()) } manageSlideVisiblity() { const e = this.contentWidth, t = this.viewportWidth; let i = this.Panzoom ? -1 * this.Panzoom.content.x : this.pages.length ? this.pages[this.page].left : 0; const n = this.option("preload"), s = this.option("infiniteX", this.option("infinite")), a = parseFloat(getComputedStyle(this.$viewport, null).getPropertyValue("padding-left")), o = parseFloat(getComputedStyle(this.$viewport, null).getPropertyValue("padding-right")); this.slides.forEach((r => { let l, c, d = 0; l = i - a, c = i + t + o, l -= n * (t + a + o), c += n * (t + a + o); const h = r.left + r.width > l && r.left < c; l = i + e - a, c = i + e + t + o, l -= n * (t + a + o); const u = s && r.left + r.width > l && r.left < c; l = i - e - a, c = i - e + t + o, l -= n * (t + a + o); const p = s && r.left + r.width > l && r.left < c; u || h || p ? (this.createSlideEl(r), h && (d = 0), u && (d = -1), p && (d = 1), r.left + r.width > i && r.left <= i + t + o && (d = 0)) : this.removeSlideEl(r), r.hasDiff = d })); let r = 0, l = 0; this.slides.forEach(((t, i) => { let n = 0; t.$el ? (i !== r || t.hasDiff ? n = l + t.hasDiff * e : l = 0, t.$el.style.left = Math.abs(n) > .1 ? `${l + t.hasDiff * e}px` : "", r++) : l += t.width })), this.markSelectedSlides() } createSlideEl(e) { if (!e) return; if (e.$el) { let t = e.$el.dataset.index; if (!t || parseInt(t, 10) !== e.index) { let t; e.$el.dataset.index = e.index, e.$el.querySelectorAll("[data-lazy-srcset]").forEach((e => { e.srcset = e.dataset.lazySrcset })), e.$el.querySelectorAll("[data-lazy-src]").forEach((e => { let t = e.dataset.lazySrc; e instanceof HTMLImageElement ? e.src = t : e.style.backgroundImage = `url('${t}')` })), (t = e.$el.dataset.lazySrc) && (e.$el.style.backgroundImage = `url('${t}')`), e.state = "ready" } return } const t = document.createElement("div"); t.dataset.index = e.index, t.classList.add(...(this.option("prefix") + this.option("classNames.slide")).split(" ")), e.customClass && t.classList.add(...e.customClass.split(" ")), e.html && (t.innerHTML = e.html); const i = []; this.slides.forEach(((e, t) => { e.$el && i.push(t) })); const n = e.index; let s = null; if (i.length) { let e = i.reduce(((e, t) => Math.abs(t - n) < Math.abs(e - n) ? t : e)); s = this.slides[e] } return this.$track.insertBefore(t, s && s.$el ? s.index < e.index ? s.$el.nextSibling : s.$el : null), e.$el = t, this.trigger("createSlide", e, n), e } removeSlideEl(e) { e.$el && !e.isDom && (this.trigger("removeSlide", e), e.$el.remove(), e.$el = null) } markSelectedSlides() { const e = this.option("classNames.slideSelected"), t = "aria-hidden"; this.slides.forEach(((i, n) => { const s = i.$el; if (!s) return; const a = this.pages[this.page]; a && a.indexes && a.indexes.indexOf(n) > -1 ? (e && !s.classList.contains(e) && (s.classList.add(e), this.trigger("selectSlide", i)), s.removeAttribute(t)) : (e && s.classList.contains(e) && (s.classList.remove(e), this.trigger("unselectSlide", i)), s.setAttribute(t, !0)) })) } updatePage() { this.updateMetrics(), this.slideTo(this.page, { friction: 0 }) } onBeforeTransform() { this.option("infiniteX", this.option("infinite")) && this.manageInfiniteTrack(), this.manageSlideVisiblity() } manageInfiniteTrack() { const e = this.contentWidth, t = this.viewportWidth; if (!this.option("infiniteX", this.option("infinite")) || this.pages.length < 2 || e < t) return; const i = this.Panzoom; let n = !1; return i.content.x < -1 * (e - t) && (i.content.x += e, this.pageIndex = this.pageIndex - this.pages.length, n = !0), i.content.x > t && (i.content.x -= e, this.pageIndex = this.pageIndex + this.pages.length, n = !0), n && "pointerdown" === i.state && i.resetDragPosition(), n } onTouchEnd(e, t) { const i = this.option("dragFree"); if (!i && this.pages.length > 1 && e.dragOffset.time < 350 && Math.abs(e.dragOffset.y) < 1 && Math.abs(e.dragOffset.x) > 5) this[e.dragOffset.x < 0 ? "slideNext" : "slidePrev"](); else if (i) { const [, t] = this.getPageFromPosition(-1 * e.transform.x); this.setPage(t) } else this.slideToClosest() } slideToClosest(e = {}) { let [, t] = this.getPageFromPosition(-1 * this.Panzoom.content.x); this.slideTo(t, e) } getPageFromPosition(e) { const t = this.pages.length; this.option("center") && (e += .5 * this.viewportWidth); const i = Math.floor(e / this.contentWidth); e -= i * this.contentWidth; let n = this.slides.find((t => t.left <= e && t.left + t.width > e)); if (n) { let e = this.findPageForSlide(n.index); return [e, e + i * t] } return [0, 0] } setPage(e, t) { let i = 0, n = parseInt(e, 10) || 0; const s = this.page, a = this.pageIndex, o = this.pages.length, r = this.contentWidth, l = this.viewportWidth; if (e = (n % o + o) % o, this.option("infiniteX", this.option("infinite")) && r > l) { const s = Math.floor(n / o) || 0, a = r; if (i = this.pages[e].left + s * a, !0 === t && o > 2) { let e = -1 * this.Panzoom.content.x; const t = i - a, s = i + a, r = Math.abs(e - i), l = Math.abs(e - t), c = Math.abs(e - s); c < r && c <= l ? (i = s, n += o) : l < r && l < c && (i = t, n -= o) } } else e = n = Math.max(0, Math.min(n, o - 1)), i = this.pages.length ? this.pages[e].left : 0; return this.page = e, this.pageIndex = n, null !== s && e !== s && (this.prevPage = s, this.prevPageIndex = a, this.trigger("change", e, s)), i } destroy() { this.state = "destroy", this.slides.forEach((e => { this.removeSlideEl(e) })), this.slides = [], this.Panzoom.destroy(), this.detachPlugins() } } y.version = "4.0.31", y.Plugins = g; const b = !("undefined" == typeof window || !window.document || !window.document.createElement); let x = null; const w = ["a[href]", "area[href]", 'input:not([disabled]):not([type="hidden"]):not([aria-hidden])', "select:not([disabled]):not([aria-hidden])", "textarea:not([disabled]):not([aria-hidden])", "button:not([disabled]):not([aria-hidden])", "iframe", "object", "embed", "video", "audio", "[contenteditable]", '[tabindex]:not([tabindex^="-"]):not([disabled]):not([aria-hidden])'], C = e => { if (e && b) { null === x && document.createElement("div").focus({ get preventScroll() { return x = !0, !1 } }); try { if (e.setActive) e.setActive(); else if (x) e.focus({ preventScroll: !0 }); else { const t = window.pageXOffset || document.body.scrollTop, i = window.pageYOffset || document.body.scrollLeft; e.focus(), document.body.scrollTo({ top: t, left: i, behavior: "auto" }) } } catch (e) { } } }; class E { constructor(e) { this.fancybox = e, this.$container = null, this.state = "init"; for (const e of ["onPrepare", "onClosing", "onKeydown"]) this[e] = this[e].bind(this); this.events = { prepare: this.onPrepare, closing: this.onClosing, keydown: this.onKeydown } } onPrepare() { this.getSlides().length < this.fancybox.option("Thumbs.minSlideCount") ? this.state = "disabled" : !0 === this.fancybox.option("Thumbs.autoStart") && this.fancybox.Carousel.Panzoom.content.height >= this.fancybox.option("Thumbs.minScreenHeight") && this.build() } onClosing() { this.Carousel && this.Carousel.Panzoom.detachEvents() } onKeydown(e, t) { t === e.option("Thumbs.key") && this.toggle() } build() { if (this.$container) return; const e = document.createElement("div"); e.classList.add("fancybox__thumbs"), this.fancybox.$carousel.parentNode.insertBefore(e, this.fancybox.$carousel.nextSibling), this.Carousel = new y(e, t(!0, { Dots: !1, Navigation: !1, Sync: { friction: 0 }, infinite: !1, center: !0, fill: !0, dragFree: !0, slidesPerPage: 1, preload: 1 }, this.fancybox.option("Thumbs.Carousel"), { Sync: { target: this.fancybox.Carousel }, slides: this.getSlides() })), this.Carousel.Panzoom.on("wheel", ((e, t) => { t.preventDefault(), this.fancybox[t.deltaY < 0 ? "prev" : "next"]() })), this.$container = e, this.state = "visible" } getSlides() { const e = []; for (const t of this.fancybox.items) { const i = t.thumb; i && e.push({ html: this.fancybox.option("Thumbs.tpl").replace(/\{\{src\}\}/gi, i), customClass: `has-thumb has-${t.type || "image"}` }) } return e } toggle() { "visible" === this.state ? this.hide() : "hidden" === this.state ? this.show() : this.build() } show() { "hidden" === this.state && (this.$container.style.display = "", this.Carousel.Panzoom.attachEvents(), this.state = "visible") } hide() { "visible" === this.state && (this.Carousel.Panzoom.detachEvents(), this.$container.style.display = "none", this.state = "hidden") } cleanup() { this.Carousel && (this.Carousel.destroy(), this.Carousel = null), this.$container && (this.$container.remove(), this.$container = null), this.state = "init" } attach() { this.fancybox.on(this.events) } detach() { this.fancybox.off(this.events), this.cleanup() } } E.defaults = { minSlideCount: 2, minScreenHeight: 500, autoStart: !0, key: "t", Carousel: {}, tpl: '<div class="fancybox__thumb" style="background-image:url(\'{{src}}\')"></div>' }; const T = (e, t) => { const i = new URL(e), n = new URLSearchParams(i.search); let s = new URLSearchParams; for (const [e, i] of [...n, ...Object.entries(t)]) "t" === e ? s.set("start", parseInt(i)) : s.set(e, i); s = s.toString(); let a = e.match(/#t=((.*)?\d+s)/); return a && (s += `#t=${a[1]}`), s }, S = { video: { autoplay: !0, ratio: 16 / 9 }, youtube: { autohide: 1, fs: 1, rel: 0, hd: 1, wmode: "transparent", enablejsapi: 1, html5: 1 }, vimeo: { hd: 1, show_title: 1, show_byline: 1, show_portrait: 0, fullscreen: 1 }, html5video: { tpl: '<video class="fancybox__html5video" playsinline controls controlsList="nodownload" poster="{{poster}}">\n  <source src="{{src}}" type="{{format}}" />Sorry, your browser doesn\'t support embedded videos.</video>', format: "" } }; class $ { constructor(e) { this.fancybox = e; for (const e of ["onInit", "onReady", "onCreateSlide", "onRemoveSlide", "onSelectSlide", "onUnselectSlide", "onRefresh", "onMessage"]) this[e] = this[e].bind(this); this.events = { init: this.onInit, ready: this.onReady, "Carousel.createSlide": this.onCreateSlide, "Carousel.removeSlide": this.onRemoveSlide, "Carousel.selectSlide": this.onSelectSlide, "Carousel.unselectSlide": this.onUnselectSlide, "Carousel.refresh": this.onRefresh } } onInit() { for (const e of this.fancybox.items) this.processType(e) } processType(e) { if (e.html) return e.src = e.html, e.type = "html", void delete e.html; const i = e.src || ""; let n = e.type || this.fancybox.options.type, s = null; if (!i || "string" == typeof i) { if (s = i.match(/(?:youtube\.com|youtu\.be|youtube\-nocookie\.com)\/(?:watch\?(?:.*&)?v=|v\/|u\/|embed\/?)?(videoseries\?list=(?:.*)|[\w-]{11}|\?listType=(?:.*)&list=(?:.*))(?:.*)/i)) { const t = T(i, this.fancybox.option("Html.youtube")), a = encodeURIComponent(s[1]); e.videoId = a, e.src = `https://www.youtube-nocookie.com/embed/${a}?${t}`, e.thumb = e.thumb || `https://i.ytimg.com/vi/${a}/mqdefault.jpg`, e.vendor = "youtube", n = "video" } else if (s = i.match(/^.+vimeo.com\/(?:\/)?([\d]+)(.*)?/)) { const t = T(i, this.fancybox.option("Html.vimeo")), a = encodeURIComponent(s[1]); e.videoId = a, e.src = `https://player.vimeo.com/video/${a}?${t}`, e.vendor = "vimeo", n = "video" } else (s = i.match(/(?:maps\.)?google\.([a-z]{2,3}(?:\.[a-z]{2})?)\/(?:(?:(?:maps\/(?:place\/(?:.*)\/)?\@(.*),(\d+.?\d+?)z))|(?:\?ll=))(.*)?/i)) ? (e.src = `//maps.google.${s[1]}/?ll=${(s[2] ? s[2] + "&z=" + Math.floor(s[3]) + (s[4] ? s[4].replace(/^\//, "&") : "") : s[4] + "").replace(/\?/, "&")}&output=${s[4] && s[4].indexOf("layer=c") > 0 ? "svembed" : "embed"}`, n = "map") : (s = i.match(/(?:maps\.)?google\.([a-z]{2,3}(?:\.[a-z]{2})?)\/(?:maps\/search\/)(.*)/i)) && (e.src = `//maps.google.${s[1]}/maps?q=${s[2].replace("query=", "q=").replace("api=1", "")}&output=embed`, n = "map"); n || ("#" === i.charAt(0) ? n = "inline" : (s = i.match(/\.(mp4|mov|ogv|webm)((\?|#).*)?$/i)) ? (n = "html5video", e.format = e.format || "video/" + ("ogv" === s[1] ? "ogg" : s[1])) : i.match(/(^data:image\/[a-z0-9+\/=]*,)|(\.(jp(e|g|eg)|gif|png|bmp|webp|svg|ico)((\?|#).*)?$)/i) ? n = "image" : i.match(/\.(pdf)((\?|#).*)?$/i) && (n = "pdf")), e.type = n || this.fancybox.option("defaultType", "image"), "html5video" !== n && "video" !== n || (e.video = t({}, this.fancybox.option("Html.video"), e.video), e._width && e._height ? e.ratio = parseFloat(e._width) / parseFloat(e._height) : e.ratio = e.ratio || e.video.ratio || S.video.ratio) } } onReady() { this.fancybox.Carousel.slides.forEach((e => { e.$el && (this.setContent(e), e.index === this.fancybox.getSlide().index && this.playVideo(e)) })) } onCreateSlide(e, t, i) { "ready" === this.fancybox.state && this.setContent(i) } loadInlineContent(e) { let t; if (e.src instanceof HTMLElement) t = e.src; else if ("string" == typeof e.src) { const i = e.src.split("#", 2), n = 2 === i.length && "" === i[0] ? i[1] : i[0]; t = document.getElementById(n) } if (t) { if ("clone" === e.type || t.$placeHolder) { t = t.cloneNode(!0); let i = t.getAttribute("id"); i = i ? `${i}--clone` : `clone-${this.fancybox.id}-${e.index}`, t.setAttribute("id", i) } else { const e = document.createElement("div"); e.classList.add("fancybox-placeholder"), t.parentNode.insertBefore(e, t), t.$placeHolder = e } this.fancybox.setContent(e, t) } else this.fancybox.setError(e, "{{ELEMENT_NOT_FOUND}}") } loadAjaxContent(e) { const t = this.fancybox, i = new XMLHttpRequest; t.showLoading(e), i.onreadystatechange = function () { i.readyState === XMLHttpRequest.DONE && "ready" === t.state && (t.hideLoading(e), 200 === i.status ? t.setContent(e, i.responseText) : t.setError(e, 404 === i.status ? "{{AJAX_NOT_FOUND}}" : "{{AJAX_FORBIDDEN}}")) }; const n = e.ajax || null; i.open(n ? "POST" : "GET", e.src), i.setRequestHeader("Content-Type", "application/x-www-form-urlencoded"), i.setRequestHeader("X-Requested-With", "XMLHttpRequest"), i.send(n), e.xhr = i } loadIframeContent(e) { const t = this.fancybox, i = document.createElement("iframe"); if (i.className = "fancybox__iframe", i.setAttribute("id", `fancybox__iframe_${t.id}_${e.index}`), i.setAttribute("allow", "autoplay; fullscreen"), i.setAttribute("scrolling", "auto"), e.$iframe = i, "iframe" !== e.type || !1 === e.preload) return i.setAttribute("src", e.src), this.fancybox.setContent(e, i), void this.resizeIframe(e); t.showLoading(e); const n = document.createElement("div"); n.style.visibility = "hidden", this.fancybox.setContent(e, n), n.appendChild(i), i.onerror = () => { t.setError(e, "{{IFRAME_ERROR}}") }, i.onload = () => { t.hideLoading(e); let n = !1; i.isReady || (i.isReady = !0, n = !0), i.src.length && (i.parentNode.style.visibility = "", this.resizeIframe(e), n && t.revealContent(e)) }, i.setAttribute("src", e.src) } setAspectRatio(e) { const t = e.$content, i = e.ratio; if (!t) return; let n = e._width, s = e._height; if (i || n && s) { Object.assign(t.style, { width: n && s ? "100%" : "", height: n && s ? "100%" : "", maxWidth: "", maxHeight: "" }); let e = t.offsetWidth, a = t.offsetHeight; if (n = n || e, s = s || a, n > e || s > a) { let t = Math.min(e / n, a / s); n *= t, s *= t } Math.abs(n / s - i) > .01 && (i < n / s ? n = s * i : s = n / i), Object.assign(t.style, { width: `${n}px`, height: `${s}px` }) } } resizeIframe(e) { const t = e.$iframe; if (!t) return; let i = e._width || 0, n = e._height || 0; i && n && (e.autoSize = !1); const s = t.parentNode, a = s && s.style; if (!1 !== e.preload && !1 !== e.autoSize && a) try { const e = window.getComputedStyle(s), o = parseFloat(e.paddingLeft) + parseFloat(e.paddingRight), r = parseFloat(e.paddingTop) + parseFloat(e.paddingBottom), l = t.contentWindow.document, c = l.getElementsByTagName("html")[0], d = l.body; a.width = "", d.style.overflow = "hidden", i = i || c.scrollWidth + o, a.width = `${i}px`, d.style.overflow = "", a.flex = "0 0 auto", a.height = `${d.scrollHeight}px`, n = c.scrollHeight + r } catch (e) { } if (i || n) { const e = { flex: "0 1 auto" }; i && (e.width = `${i}px`), n && (e.height = `${n}px`), Object.assign(a, e) } } onRefresh(e, t) { t.slides.forEach((e => { e.$el && (e.$iframe && this.resizeIframe(e), e.ratio && this.setAspectRatio(e)) })) } setContent(e) { if (e && !e.isDom) { switch (e.type) { case "html": this.fancybox.setContent(e, e.src); break; case "html5video": this.fancybox.setContent(e, this.fancybox.option("Html.html5video.tpl").replace(/\{\{src\}\}/gi, e.src).replace("{{format}}", e.format || e.html5video && e.html5video.format || "").replace("{{poster}}", e.poster || e.thumb || "")); break; case "inline": case "clone": this.loadInlineContent(e); break; case "ajax": this.loadAjaxContent(e); break; case "pdf": case "video": case "map": e.preload = !1; case "iframe": this.loadIframeContent(e) }e.ratio && this.setAspectRatio(e) } } onSelectSlide(e, t, i) { "ready" === e.state && this.playVideo(i) } playVideo(e) { if ("html5video" === e.type && e.video.autoplay) try { const t = e.$el.querySelector("video"); if (t) { const e = t.play(); void 0 !== e && e.then((() => { })).catch((e => { t.muted = !0, t.play() })) } } catch (e) { } if ("video" !== e.type || !e.$iframe || !e.$iframe.contentWindow) return; const t = () => { if ("done" === e.state && e.$iframe && e.$iframe.contentWindow) { let t; if (e.$iframe.isReady) return e.video && e.video.autoplay && (t = "youtube" == e.vendor ? { event: "command", func: "playVideo" } : { method: "play", value: "true" }), void (t && e.$iframe.contentWindow.postMessage(JSON.stringify(t), "*")); "youtube" === e.vendor && (t = { event: "listening", id: e.$iframe.getAttribute("id") }, e.$iframe.contentWindow.postMessage(JSON.stringify(t), "*")) } e.poller = setTimeout(t, 250) }; t() } onUnselectSlide(e, t, i) { if ("html5video" === i.type) { try { i.$el.querySelector("video").pause() } catch (e) { } return } let n = !1; "vimeo" == i.vendor ? n = { method: "pause", value: "true" } : "youtube" === i.vendor && (n = { event: "command", func: "pauseVideo" }), n && i.$iframe && i.$iframe.contentWindow && i.$iframe.contentWindow.postMessage(JSON.stringify(n), "*"), clearTimeout(i.poller) } onRemoveSlide(e, t, i) { i.xhr && (i.xhr.abort(), i.xhr = null), i.$iframe && (i.$iframe.onload = i.$iframe.onerror = null, i.$iframe.src = "//about:blank", i.$iframe = null); const n = i.$content; "inline" === i.type && n && (n.classList.remove("fancybox__content"), "none" !== n.style.display && (n.style.display = "none")), i.$closeButton && (i.$closeButton.remove(), i.$closeButton = null); const s = n && n.$placeHolder; s && (s.parentNode.insertBefore(n, s), s.remove(), n.$placeHolder = null) } onMessage(e) { try { let t = JSON.parse(e.data); if ("https://player.vimeo.com" === e.origin) { if ("ready" === t.event) for (let t of document.getElementsByClassName("fancybox__iframe")) t.contentWindow === e.source && (t.isReady = 1) } else "https://www.youtube-nocookie.com" === e.origin && "onReady" === t.event && (document.getElementById(t.id).isReady = 1) } catch (e) { } } attach() { this.fancybox.on(this.events), window.addEventListener("message", this.onMessage, !1) } detach() { this.fancybox.off(this.events), window.removeEventListener("message", this.onMessage, !1) } } $.defaults = S; class M { constructor(e) { this.fancybox = e; for (const e of ["onReady", "onClosing", "onDone", "onPageChange", "onCreateSlide", "onRemoveSlide", "onImageStatusChange"]) this[e] = this[e].bind(this); this.events = { ready: this.onReady, closing: this.onClosing, done: this.onDone, "Carousel.change": this.onPageChange, "Carousel.createSlide": this.onCreateSlide, "Carousel.removeSlide": this.onRemoveSlide } } onReady() { this.fancybox.Carousel.slides.forEach((e => { e.$el && this.setContent(e) })) } onDone(e, t) { this.handleCursor(t) } onClosing(e) { clearTimeout(this.clickTimer), this.clickTimer = null, e.Carousel.slides.forEach((e => { e.$image && (e.state = "destroy"), e.Panzoom && e.Panzoom.detachEvents() })), "closing" === this.fancybox.state && this.canZoom(e.getSlide()) && this.zoomOut() } onCreateSlide(e, t, i) { "ready" === this.fancybox.state && this.setContent(i) } onRemoveSlide(e, t, i) { i.$image && (i.$el.classList.remove(e.option("Image.canZoomInClass")), i.$image.remove(), i.$image = null), i.Panzoom && (i.Panzoom.destroy(), i.Panzoom = null), i.$el && i.$el.dataset && delete i.$el.dataset.imageFit } setContent(e) { if (e.isDom || e.html || e.type && "image" !== e.type) return; if (e.$image) return; e.type = "image", e.state = "loading"; const t = document.createElement("div"); t.style.visibility = "hidden"; const i = document.createElement("img"); i.addEventListener("load", (t => { t.stopImmediatePropagation(), this.onImageStatusChange(e) })), i.addEventListener("error", (() => { this.onImageStatusChange(e) })), i.src = e.src, i.alt = "", i.draggable = !1, i.classList.add("fancybox__image"), e.srcset && i.setAttribute("srcset", e.srcset), e.sizes && i.setAttribute("sizes", e.sizes), e.$image = i; const n = this.fancybox.option("Image.wrap"); if (n) { const s = document.createElement("div"); s.classList.add("string" == typeof n ? n : "fancybox__image-wrap"), s.appendChild(i), t.appendChild(s), e.$wrap = s } else t.appendChild(i); e.$el.dataset.imageFit = this.fancybox.option("Image.fit"), this.fancybox.setContent(e, t), i.complete || i.error ? this.onImageStatusChange(e) : this.fancybox.showLoading(e) } onImageStatusChange(e) { const t = e.$image; t && "loading" === e.state && (t.complete && t.naturalWidth && t.naturalHeight ? (this.fancybox.hideLoading(e), "contain" === this.fancybox.option("Image.fit") && this.initSlidePanzoom(e), e.$el.addEventListener("wheel", (t => this.onWheel(e, t)), { passive: !1 }), e.$content.addEventListener("click", (t => this.onClick(e, t)), { passive: !1 }), this.revealContent(e)) : this.fancybox.setError(e, "{{IMAGE_ERROR}}")) } initSlidePanzoom(e) { e.Panzoom || (e.Panzoom = new u(e.$el, t(!0, this.fancybox.option("Image.Panzoom", {}), { viewport: e.$wrap, content: e.$image, width: e._width, height: e._height, wrapInner: !1, textSelection: !0, touch: this.fancybox.option("Image.touch"), panOnlyZoomed: !0, click: !1, wheel: !1 })), e.Panzoom.on("startAnimation", (() => { this.fancybox.trigger("Image.startAnimation", e) })), e.Panzoom.on("endAnimation", (() => { "zoomIn" === e.state && this.fancybox.done(e), this.handleCursor(e), this.fancybox.trigger("Image.endAnimation", e) })), e.Panzoom.on("afterUpdate", (() => { this.handleCursor(e), this.fancybox.trigger("Image.afterUpdate", e) }))) } revealContent(e) { null === this.fancybox.Carousel.prevPage && e.index === this.fancybox.options.startIndex && this.canZoom(e) ? this.zoomIn() : this.fancybox.revealContent(e) } getZoomInfo(e) { const t = e.$thumb.getBoundingClientRect(), i = t.width, n = t.height, s = e.$content.getBoundingClientRect(), a = s.width, o = s.height, r = s.top - t.top, l = s.left - t.left; let c = this.fancybox.option("Image.zoomOpacity"); return "auto" === c && (c = Math.abs(i / n - a / o) > .1), { top: r, left: l, scale: a && i ? i / a : 1, opacity: c } } canZoom(e) { const t = this.fancybox, i = t.$container; if (window.visualViewport && 1 !== window.visualViewport.scale) return !1; if (e.Panzoom && !e.Panzoom.content.width) return !1; if (!t.option("Image.zoom") || "contain" !== t.option("Image.fit")) return !1; const n = e.$thumb; if (!n || "loading" === e.state) return !1; i.classList.add("fancybox__no-click"); const s = n.getBoundingClientRect(); let a; if (this.fancybox.option("Image.ignoreCoveredThumbnail")) { const e = document.elementFromPoint(s.left + 1, s.top + 1) === n, t = document.elementFromPoint(s.right - 1, s.bottom - 1) === n; a = e && t } else a = document.elementFromPoint(s.left + .5 * s.width, s.top + .5 * s.height) === n; return i.classList.remove("fancybox__no-click"), a } zoomIn() { const e = this.fancybox, t = e.getSlide(), i = t.Panzoom, { top: n, left: s, scale: a, opacity: o } = this.getZoomInfo(t); e.trigger("reveal", t), i.panTo({ x: -1 * s, y: -1 * n, scale: a, friction: 0, ignoreBounds: !0 }), t.$content.style.visibility = "", t.state = "zoomIn", !0 === o && i.on("afterTransform", (e => { "zoomIn" !== t.state && "zoomOut" !== t.state || (e.$content.style.opacity = Math.min(1, 1 - (1 - e.content.scale) / (1 - a))) })), i.panTo({ x: 0, y: 0, scale: 1, friction: this.fancybox.option("Image.zoomFriction") }) } zoomOut() { const e = this.fancybox, t = e.getSlide(), i = t.Panzoom; if (!i) return; t.state = "zoomOut", e.state = "customClosing", t.$caption && (t.$caption.style.visibility = "hidden"); let n = this.fancybox.option("Image.zoomFriction"); const s = e => { const { top: s, left: a, scale: o, opacity: r } = this.getZoomInfo(t); e || r || (n *= .82), i.panTo({ x: -1 * a, y: -1 * s, scale: o, friction: n, ignoreBounds: !0 }), n *= .98 }; window.addEventListener("scroll", s), i.once("endAnimation", (() => { window.removeEventListener("scroll", s), e.destroy() })), s() } handleCursor(e) { if ("image" !== e.type || !e.$el) return; const t = e.Panzoom, i = this.fancybox.option("Image.click", !1, e), n = this.fancybox.option("Image.touch"), s = e.$el.classList, a = this.fancybox.option("Image.canZoomInClass"), o = this.fancybox.option("Image.canZoomOutClass"); s.remove(o), s.remove(a), t && "toggleZoom" === i ? t && 1 === t.content.scale && t.option("maxScale") - t.content.scale > .01 ? s.add(a) : t.content.scale > 1 && !n && s.add(o) : "close" === i && s.add(o) } onWheel(e, t) { if ("ready" === this.fancybox.state && !1 !== this.fancybox.trigger("Image.wheel", t)) switch (this.fancybox.option("Image.wheel")) { case "zoom": "done" === e.state && e.Panzoom && e.Panzoom.zoomWithWheel(t); break; case "close": this.fancybox.close(); break; case "slide": this.fancybox[t.deltaY < 0 ? "prev" : "next"]() } } onClick(e, t) { if ("ready" !== this.fancybox.state) return; const i = e.Panzoom; if (i && (i.dragPosition.midPoint || 0 !== i.dragOffset.x || 0 !== i.dragOffset.y || 1 !== i.dragOffset.scale)) return; if (this.fancybox.Carousel.Panzoom.lockAxis) return !1; const n = i => { switch (i) { case "toggleZoom": t.stopPropagation(), e.Panzoom && e.Panzoom.zoomWithClick(t); break; case "close": this.fancybox.close(); break; case "next": t.stopPropagation(), this.fancybox.next() } }, s = this.fancybox.option("Image.click"), a = this.fancybox.option("Image.doubleClick"); a ? this.clickTimer ? (clearTimeout(this.clickTimer), this.clickTimer = null, n(a)) : this.clickTimer = setTimeout((() => { this.clickTimer = null, n(s) }), 300) : n(s) } onPageChange(e, t) { const i = e.getSlide(); t.slides.forEach((e => { e.Panzoom && "done" === e.state && e.index !== i.index && e.Panzoom.panTo({ x: 0, y: 0, scale: 1, friction: .8 }) })) } attach() { this.fancybox.on(this.events) } detach() { this.fancybox.off(this.events) } } M.defaults = { canZoomInClass: "can-zoom_in", canZoomOutClass: "can-zoom_out", zoom: !0, zoomOpacity: "auto", zoomFriction: .82, ignoreCoveredThumbnail: !1, touch: !0, click: "toggleZoom", doubleClick: null, wheel: "zoom", fit: "contain", wrap: !1, Panzoom: { ratio: 1 } }; class P { constructor(e) { this.fancybox = e; for (const e of ["onChange", "onClosing"]) this[e] = this[e].bind(this); this.events = { initCarousel: this.onChange, "Carousel.change": this.onChange, closing: this.onClosing }, this.hasCreatedHistory = !1, this.origHash = "", this.timer = null } onChange(e) { const t = e.Carousel; this.timer && clearTimeout(this.timer); const i = null === t.prevPage, n = e.getSlide(), s = new URL(document.URL).hash; let a = !1; if (n.slug) a = "#" + n.slug; else { const i = n.$trigger && n.$trigger.dataset, s = e.option("slug") || i && i.fancybox; s && s.length && "true" !== s && (a = "#" + s + (t.slides.length > 1 ? "-" + (n.index + 1) : "")) } i && (this.origHash = s !== a ? s : ""), a && s !== a && (this.timer = setTimeout((() => { try { window.history[i ? "pushState" : "replaceState"]({}, document.title, window.location.pathname + window.location.search + a), i && (this.hasCreatedHistory = !0) } catch (e) { } }), 300)) } onClosing() { if (this.timer && clearTimeout(this.timer), !0 !== this.hasSilentClose) try { return void window.history.replaceState({}, document.title, window.location.pathname + window.location.search + (this.origHash || "")) } catch (e) { } } attach(e) { e.on(this.events) } detach(e) { e.off(this.events) } static startFromUrl() { const e = P.Fancybox; if (!e || e.getInstance() || !1 === e.defaults.Hash) return; const { hash: t, slug: i, index: n } = P.getParsedURL(); if (!i) return; let s = document.querySelector(`[data-slug="${t}"]`); if (s && s.dispatchEvent(new CustomEvent("click", { bubbles: !0, cancelable: !0 })), e.getInstance()) return; const a = document.querySelectorAll(`[data-fancybox="${i}"]`); a.length && (null === n && 1 === a.length ? s = a[0] : n && (s = a[n - 1]), s && s.dispatchEvent(new CustomEvent("click", { bubbles: !0, cancelable: !0 }))) } static onHashChange() { const { slug: e, index: t } = P.getParsedURL(), i = P.Fancybox, n = i && i.getInstance(); if (n && n.plugins.Hash) { if (e) { const i = n.Carousel; if (e === n.option("slug")) return i.slideTo(t - 1); for (let t of i.slides) if (t.slug && t.slug === e) return i.slideTo(t.index); const s = n.getSlide(), a = s.$trigger && s.$trigger.dataset; if (a && a.fancybox === e) return i.slideTo(t - 1) } n.plugins.Hash.hasSilentClose = !0, n.close() } P.startFromUrl() } static create(e) { function t() { window.addEventListener("hashchange", P.onHashChange, !1), P.startFromUrl() } P.Fancybox = e, b && window.requestAnimationFrame((() => { /complete|interactive|loaded/.test(document.readyState) ? t() : document.addEventListener("DOMContentLoaded", t) })) } static destroy() { window.removeEventListener("hashchange", P.onHashChange, !1) } static getParsedURL() { const e = window.location.hash.substr(1), t = e.split("-"), i = t.length > 1 && /^\+?\d+$/.test(t[t.length - 1]) && parseInt(t.pop(-1), 10) || null; return { hash: e, slug: t.join("-"), index: i } } } const k = { pageXOffset: 0, pageYOffset: 0, element: () => document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement, activate(e) { k.pageXOffset = window.pageXOffset, k.pageYOffset = window.pageYOffset, e.requestFullscreen ? e.requestFullscreen() : e.mozRequestFullScreen ? e.mozRequestFullScreen() : e.webkitRequestFullscreen ? e.webkitRequestFullscreen() : e.msRequestFullscreen && e.msRequestFullscreen() }, deactivate() { document.exitFullscreen ? document.exitFullscreen() : document.mozCancelFullScreen ? document.mozCancelFullScreen() : document.webkitExitFullscreen && document.webkitExitFullscreen() } }; class L { constructor(e) { this.fancybox = e, this.active = !1, this.handleVisibilityChange = this.handleVisibilityChange.bind(this) } isActive() { return this.active } setTimer() { if (!this.active || this.timer) return; const e = this.fancybox.option("slideshow.delay", 3e3); this.timer = setTimeout((() => { this.timer = null, this.fancybox.option("infinite") || this.fancybox.getSlide().index !== this.fancybox.Carousel.slides.length - 1 ? this.fancybox.next() : this.fancybox.jumpTo(0, { friction: 0 }) }), e); let t = this.$progress; t || (t = document.createElement("div"), t.classList.add("fancybox__progress"), this.fancybox.$carousel.parentNode.insertBefore(t, this.fancybox.$carousel), this.$progress = t, t.offsetHeight), t.style.transitionDuration = `${e}ms`, t.style.transform = "scaleX(1)" } clearTimer() { clearTimeout(this.timer), this.timer = null, this.$progress && (this.$progress.style.transitionDuration = "", this.$progress.style.transform = "", this.$progress.offsetHeight) } activate() { this.active || (this.active = !0, this.fancybox.$container.classList.add("has-slideshow"), "done" === this.fancybox.getSlide().state && this.setTimer(), document.addEventListener("visibilitychange", this.handleVisibilityChange, !1)) } handleVisibilityChange() { this.deactivate() } deactivate() { this.active = !1, this.clearTimer(), this.fancybox.$container.classList.remove("has-slideshow"), document.removeEventListener("visibilitychange", this.handleVisibilityChange, !1) } toggle() { this.active ? this.deactivate() : this.fancybox.Carousel.slides.length > 1 && this.activate() } } const A = { display: ["counter", "zoom", "slideshow", "fullscreen", "thumbs", "close"], autoEnable: !0, items: { counter: { position: "left", type: "div", class: "fancybox__counter", html: '<span data-fancybox-index=""></span>&nbsp;/&nbsp;<span data-fancybox-count=""></span>', attr: { tabindex: -1 } }, prev: { type: "button", class: "fancybox__button--prev", label: "PREV", html: '<svg viewBox="0 0 24 24"><path d="M15 4l-8 8 8 8"/></svg>', attr: { "data-fancybox-prev": "" } }, next: { type: "button", class: "fancybox__button--next", label: "NEXT", html: '<svg viewBox="0 0 24 24"><path d="M8 4l8 8-8 8"/></svg>', attr: { "data-fancybox-next": "" } }, fullscreen: { type: "button", class: "fancybox__button--fullscreen", label: "TOGGLE_FULLSCREEN", html: '<svg viewBox="0 0 24 24">\n                <g><path d="M3 8 V3h5"></path><path d="M21 8V3h-5"></path><path d="M8 21H3v-5"></path><path d="M16 21h5v-5"></path></g>\n                <g><path d="M7 2v5H2M17 2v5h5M2 17h5v5M22 17h-5v5"/></g>\n            </svg>', click: function (e) { e.preventDefault(), k.element() ? k.deactivate() : k.activate(this.fancybox.$container) } }, slideshow: { type: "button", class: "fancybox__button--slideshow", label: "TOGGLE_SLIDESHOW", html: '<svg viewBox="0 0 24 24">\n                <g><path d="M6 4v16"/><path d="M20 12L6 20"/><path d="M20 12L6 4"/></g>\n                <g><path d="M7 4v15M17 4v15"/></g>\n            </svg>', click: function (e) { e.preventDefault(), this.Slideshow.toggle() } }, zoom: { type: "button", class: "fancybox__button--zoom", label: "TOGGLE_ZOOM", html: '<svg viewBox="0 0 24 24"><circle cx="10" cy="10" r="7"></circle><path d="M16 16 L21 21"></svg>', click: function (e) { e.preventDefault(); const t = this.fancybox.getSlide().Panzoom; t && t.toggleZoom() } }, download: { type: "link", label: "DOWNLOAD", class: "fancybox__button--download", html: '<svg viewBox="0 0 24 24"><path d="M12 15V3m0 12l-4-4m4 4l4-4M2 17l.62 2.48A2 2 0 004.56 21h14.88a2 2 0 001.94-1.51L22 17"/></svg>', click: function (e) { e.stopPropagation() } }, thumbs: { type: "button", label: "TOGGLE_THUMBS", class: "fancybox__button--thumbs", html: '<svg viewBox="0 0 24 24"><circle cx="4" cy="4" r="1" /><circle cx="12" cy="4" r="1" transform="rotate(90 12 4)"/><circle cx="20" cy="4" r="1" transform="rotate(90 20 4)"/><circle cx="4" cy="12" r="1" transform="rotate(90 4 12)"/><circle cx="12" cy="12" r="1" transform="rotate(90 12 12)"/><circle cx="20" cy="12" r="1" transform="rotate(90 20 12)"/><circle cx="4" cy="20" r="1" transform="rotate(90 4 20)"/><circle cx="12" cy="20" r="1" transform="rotate(90 12 20)"/><circle cx="20" cy="20" r="1" transform="rotate(90 20 20)"/></svg>', click: function (e) { e.stopPropagation(); const t = this.fancybox.plugins.Thumbs; t && t.toggle() } }, close: { type: "button", label: "CLOSE", class: "fancybox__button--close", html: '<svg viewBox="0 0 24 24"><path d="M20 20L4 4m16 0L4 20"></path></svg>', attr: { "data-fancybox-close": "", tabindex: 0 } } } }; class z { constructor(e) { this.fancybox = e, this.$container = null, this.state = "init"; for (const e of ["onInit", "onPrepare", "onDone", "onKeydown", "onClosing", "onChange", "onSettle", "onRefresh"]) this[e] = this[e].bind(this); this.events = { init: this.onInit, prepare: this.onPrepare, done: this.onDone, keydown: this.onKeydown, closing: this.onClosing, "Carousel.change": this.onChange, "Carousel.settle": this.onSettle, "Carousel.Panzoom.touchStart": () => this.onRefresh(), "Image.startAnimation": (e, t) => this.onRefresh(t), "Image.afterUpdate": (e, t) => this.onRefresh(t) } } onInit() { if (this.fancybox.option("Toolbar.autoEnable")) { let e = !1; for (const t of this.fancybox.items) if ("image" === t.type) { e = !0; break } if (!e) return void (this.state = "disabled") } for (const t of this.fancybox.option("Toolbar.display")) if ("close" === (e(t) ? t.id : t)) { this.fancybox.options.closeButton = !1; break } } onPrepare() { const e = this.fancybox; if ("init" === this.state && (this.build(), this.update(), this.Slideshow = new L(e), !e.Carousel.prevPage && (e.option("slideshow.autoStart") && this.Slideshow.activate(), e.option("fullscreen.autoStart") && !k.element()))) try { k.activate(e.$container) } catch (e) { } } onFsChange() { window.scrollTo(k.pageXOffset, k.pageYOffset) } onSettle() { const e = this.fancybox, t = this.Slideshow; t && t.isActive() && (e.getSlide().index !== e.Carousel.slides.length - 1 || e.option("infinite") ? "done" === e.getSlide().state && t.setTimer() : t.deactivate()) } onChange() { this.update(), this.Slideshow && this.Slideshow.isActive() && this.Slideshow.clearTimer() } onDone(e, t) { const i = this.Slideshow; t.index === e.getSlide().index && (this.update(), i && i.isActive() && (e.option("infinite") || t.index !== e.Carousel.slides.length - 1 ? i.setTimer() : i.deactivate())) } onRefresh(e) { e && e.index !== this.fancybox.getSlide().index || (this.update(), !this.Slideshow || !this.Slideshow.isActive() || e && "done" !== e.state || this.Slideshow.deactivate()) } onKeydown(e, t, i) { " " === t && this.Slideshow && (this.Slideshow.toggle(), i.preventDefault()) } onClosing() { this.Slideshow && this.Slideshow.deactivate(), document.removeEventListener("fullscreenchange", this.onFsChange) } createElement(e) { let t; "div" === e.type ? t = document.createElement("div") : (t = document.createElement("link" === e.type ? "a" : "button"), t.classList.add("carousel__button")), t.innerHTML = e.html, t.setAttribute("tabindex", e.tabindex || 0), e.class && t.classList.add(...e.class.split(" ")); for (const i in e.attr) t.setAttribute(i, e.attr[i]); e.label && t.setAttribute("title", this.fancybox.localize(`{{${e.label}}}`)), e.click && t.addEventListener("click", e.click.bind(this)), "prev" === e.id && t.setAttribute("data-fancybox-prev", ""), "next" === e.id && t.setAttribute("data-fancybox-next", ""); const i = t.querySelector("svg"); return i && (i.setAttribute("role", "img"), i.setAttribute("tabindex", "-1"), i.setAttribute("xmlns", "http://www.w3.org/2000/svg")), t } build() { this.cleanup(); const i = this.fancybox.option("Toolbar.items"), n = [{ position: "left", items: [] }, { position: "center", items: [] }, { position: "right", items: [] }], s = this.fancybox.plugins.Thumbs; for (const a of this.fancybox.option("Toolbar.display")) { let o, r; if (e(a) ? (o = a.id, r = t({}, i[o], a)) : (o = a, r = i[o]), ["counter", "next", "prev", "slideshow"].includes(o) && this.fancybox.items.length < 2) continue; if ("fullscreen" === o) { if (!document.fullscreenEnabled || window.fullScreen) continue; document.addEventListener("fullscreenchange", this.onFsChange) } if ("thumbs" === o && (!s || "disabled" === s.state)) continue; if (!r) continue; let l = r.position || "right", c = n.find((e => e.position === l)); c && c.items.push(r) } const a = document.createElement("div"); a.classList.add("fancybox__toolbar"); for (const e of n) if (e.items.length) { const t = document.createElement("div"); t.classList.add("fancybox__toolbar__items"), t.classList.add(`fancybox__toolbar__items--${e.position}`); for (const i of e.items) t.appendChild(this.createElement(i)); a.appendChild(t) } this.fancybox.$carousel.parentNode.insertBefore(a, this.fancybox.$carousel), this.$container = a } update() { const e = this.fancybox.getSlide(), t = e.index, i = this.fancybox.items.length, n = e.downloadSrc || ("image" !== e.type || e.error ? null : e.src); for (const e of this.fancybox.$container.querySelectorAll("a.fancybox__button--download")) n ? (e.removeAttribute("disabled"), e.removeAttribute("tabindex"), e.setAttribute("href", n), e.setAttribute("download", n), e.setAttribute("target", "_blank")) : (e.setAttribute("disabled", ""), e.setAttribute("tabindex", -1), e.removeAttribute("href"), e.removeAttribute("download")); const s = e.Panzoom, a = s && s.option("maxScale") > s.option("baseScale"); for (const e of this.fancybox.$container.querySelectorAll(".fancybox__button--zoom")) a ? e.removeAttribute("disabled") : e.setAttribute("disabled", ""); for (const t of this.fancybox.$container.querySelectorAll("[data-fancybox-index]")) t.innerHTML = e.index + 1; for (const e of this.fancybox.$container.querySelectorAll("[data-fancybox-count]")) e.innerHTML = i; if (!this.fancybox.option("infinite")) { for (const e of this.fancybox.$container.querySelectorAll("[data-fancybox-prev]")) 0 === t ? e.setAttribute("disabled", "") : e.removeAttribute("disabled"); for (const e of this.fancybox.$container.querySelectorAll("[data-fancybox-next]")) t === i - 1 ? e.setAttribute("disabled", "") : e.removeAttribute("disabled") } } cleanup() { this.Slideshow && this.Slideshow.isActive() && this.Slideshow.clearTimer(), this.$container && this.$container.remove(), this.$container = null } attach() { this.fancybox.on(this.events) } detach() { this.fancybox.off(this.events), this.cleanup() } } z.defaults = A; const O = { ScrollLock: class { constructor(e) { this.fancybox = e, this.viewport = null, this.pendingUpdate = null; for (const e of ["onReady", "onResize", "onTouchstart", "onTouchmove"]) this[e] = this[e].bind(this) } onReady() { const e = window.visualViewport; e && (this.viewport = e, this.startY = 0, e.addEventListener("resize", this.onResize), this.updateViewport()), window.addEventListener("touchstart", this.onTouchstart, { passive: !1 }), window.addEventListener("touchmove", this.onTouchmove, { passive: !1 }), window.addEventListener("wheel", this.onWheel, { passive: !1 }) } onResize() { this.updateViewport() } updateViewport() { const e = this.fancybox, t = this.viewport, i = t.scale || 1, n = e.$container; if (!n) return; let s = "", a = "", o = ""; i - 1 > .1 && (s = t.width * i + "px", a = t.height * i + "px", o = `translate3d(${t.offsetLeft}px, ${t.offsetTop}px, 0) scale(${1 / i})`), n.style.width = s, n.style.height = a, n.style.transform = o } onTouchstart(e) { this.startY = e.touches ? e.touches[0].screenY : e.screenY } onTouchmove(e) { const t = this.startY, i = window.innerWidth / window.document.documentElement.clientWidth; if (!e.cancelable) return; if (e.touches.length > 1 || 1 !== i) return; const n = s(e.composedPath()[0]); if (!n) return void e.preventDefault(); const a = window.getComputedStyle(n), o = parseInt(a.getPropertyValue("height"), 10), r = e.touches ? e.touches[0].screenY : e.screenY, l = t <= r && 0 === n.scrollTop, c = t >= r && n.scrollHeight - n.scrollTop === o; (l || c) && e.preventDefault() } onWheel(e) { s(e.composedPath()[0]) || e.preventDefault() } cleanup() { this.pendingUpdate && (cancelAnimationFrame(this.pendingUpdate), this.pendingUpdate = null); const e = this.viewport; e && (e.removeEventListener("resize", this.onResize), this.viewport = null), window.removeEventListener("touchstart", this.onTouchstart, !1), window.removeEventListener("touchmove", this.onTouchmove, !1), window.removeEventListener("wheel", this.onWheel, { passive: !1 }) } attach() { this.fancybox.on("initLayout", this.onReady) } detach() { this.fancybox.off("initLayout", this.onReady), this.cleanup() } }, Thumbs: E, Html: $, Toolbar: z, Image: M, Hash: P }, I = { startIndex: 0, preload: 1, infinite: !0, showClass: "fancybox-zoomInUp", hideClass: "fancybox-fadeOut", animated: !0, hideScrollbar: !0, parentEl: null, mainClass: null, autoFocus: !0, trapFocus: !0, placeFocusBack: !0, click: "close", closeButton: "inside", dragToClose: !0, keyboard: { Escape: "close", Delete: "close", Backspace: "close", PageUp: "next", PageDown: "prev", ArrowUp: "next", ArrowDown: "prev", ArrowRight: "next", ArrowLeft: "prev" }, template: { closeButton: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" tabindex="-1"><path d="M20 20L4 4m16 0L4 20"/></svg>', spinner: '<svg xmlns="http://www.w3.org/2000/svg" width="50" height="50" viewBox="25 25 50 50" tabindex="-1"><circle cx="50" cy="50" r="20"/></svg>', main: null }, l10n: { CLOSE: "Close", NEXT: "Next", PREV: "Previous", MODAL: "You can close this modal content with the ESC key", ERROR: "Something Went Wrong, Please Try Again Later", IMAGE_ERROR: "Image Not Found", ELEMENT_NOT_FOUND: "HTML Element Not Found", AJAX_NOT_FOUND: "Error Loading AJAX : Not Found", AJAX_FORBIDDEN: "Error Loading AJAX : Forbidden", IFRAME_ERROR: "Error Loading Page", TOGGLE_ZOOM: "Toggle zoom level", TOGGLE_THUMBS: "Toggle thumbnails", TOGGLE_SLIDESHOW: "Toggle slideshow", TOGGLE_FULLSCREEN: "Toggle full-screen mode", DOWNLOAD: "Download" } }, D = new Map; let _ = 0; class N extends d { constructor(e, i = {}) { e = e.map((e => (e.width && (e._width = e.width), e.height && (e._height = e.height), e))), super(t(!0, {}, I, i)), this.bindHandlers(), this.state = "init", this.setItems(e), this.attachPlugins(N.Plugins), this.trigger("init"), !0 === this.option("hideScrollbar") && this.hideScrollbar(), this.initLayout(), this.initCarousel(), this.attachEvents(), D.set(this.id, this), this.trigger("prepare"), this.state = "ready", this.trigger("ready"), this.$container.setAttribute("aria-hidden", "false"), this.option("trapFocus") && this.focus() } option(e, ...t) { const i = this.getSlide(); let n = i ? i[e] : void 0; return void 0 !== n ? ("function" == typeof n && (n = n.call(this, this, ...t)), n) : super.option(e, ...t) } bindHandlers() { for (const e of ["onMousedown", "onKeydown", "onClick", "onFocus", "onCreateSlide", "onSettle", "onTouchMove", "onTouchEnd", "onTransform"]) this[e] = this[e].bind(this) } attachEvents() { document.addEventListener("mousedown", this.onMousedown), document.addEventListener("keydown", this.onKeydown, !0), this.option("trapFocus") && document.addEventListener("focus", this.onFocus, !0), this.$container.addEventListener("click", this.onClick) } detachEvents() { document.removeEventListener("mousedown", this.onMousedown), document.removeEventListener("keydown", this.onKeydown, !0), document.removeEventListener("focus", this.onFocus, !0), this.$container.removeEventListener("click", this.onClick) } initLayout() { this.$root = this.option("parentEl") || document.body; let e = this.option("template.main"); e && (this.$root.insertAdjacentHTML("beforeend", this.localize(e)), this.$container = this.$root.querySelector(".fancybox__container")), this.$container || (this.$container = document.createElement("div"), this.$root.appendChild(this.$container)), this.$container.onscroll = () => (this.$container.scrollLeft = 0, !1), Object.entries({ class: "fancybox__container", role: "dialog", tabIndex: "-1", "aria-modal": "true", "aria-hidden": "true", "aria-label": this.localize("{{MODAL}}") }).forEach((e => this.$container.setAttribute(...e))), this.option("animated") && this.$container.classList.add("is-animated"), this.$backdrop = this.$container.querySelector(".fancybox__backdrop"), this.$backdrop || (this.$backdrop = document.createElement("div"), this.$backdrop.classList.add("fancybox__backdrop"), this.$container.appendChild(this.$backdrop)), this.$carousel = this.$container.querySelector(".fancybox__carousel"), this.$carousel || (this.$carousel = document.createElement("div"), this.$carousel.classList.add("fancybox__carousel"), this.$container.appendChild(this.$carousel)), this.$container.Fancybox = this, this.id = this.$container.getAttribute("id"), this.id || (this.id = this.options.id || ++_, this.$container.setAttribute("id", "fancybox-" + this.id)); const t = this.option("mainClass"); return t && this.$container.classList.add(...t.split(" ")), document.documentElement.classList.add("with-fancybox"), this.trigger("initLayout"), this } setItems(e) { const t = []; for (const i of e) { const e = i.$trigger; if (e) { const t = e.dataset || {}; i.src = t.src || e.getAttribute("href") || i.src, i.type = t.type || i.type, !i.src && e instanceof HTMLImageElement && (i.src = e.currentSrc || i.$trigger.src) } let n = i.$thumb; if (!n) { let e = i.$trigger && i.$trigger.origTarget; e && (n = e instanceof HTMLImageElement ? e : e.querySelector("img:not([aria-hidden])")), !n && i.$trigger && (n = i.$trigger instanceof HTMLImageElement ? i.$trigger : i.$trigger.querySelector("img:not([aria-hidden])")) } i.$thumb = n || null; let s = i.thumb; !s && n && (s = n.currentSrc || n.src, !s && n.dataset && (s = n.dataset.lazySrc || n.dataset.src)), s || "image" !== i.type || (s = i.src), i.thumb = s || null, i.caption = i.caption || "", t.push(i) } this.items = t } initCarousel() { return this.Carousel = new y(this.$carousel, t(!0, {}, { prefix: "", classNames: { viewport: "fancybox__viewport", track: "fancybox__track", slide: "fancybox__slide" }, textSelection: !0, preload: this.option("preload"), friction: .88, slides: this.items, initialPage: this.options.startIndex, slidesPerPage: 1, infiniteX: this.option("infinite"), infiniteY: !0, l10n: this.option("l10n"), Dots: !1, Navigation: { classNames: { main: "fancybox__nav", button: "carousel__button", next: "is-next", prev: "is-prev" } }, Panzoom: { textSelection: !0, panOnlyZoomed: () => this.Carousel && this.Carousel.pages && this.Carousel.pages.length < 2 && !this.option("dragToClose"), lockAxis: () => { if (this.Carousel) { let e = "x"; return this.option("dragToClose") && (e += "y"), e } } }, on: { "*": (e, ...t) => this.trigger(`Carousel.${e}`, ...t), init: e => this.Carousel = e, createSlide: this.onCreateSlide, settle: this.onSettle } }, this.option("Carousel"))), this.option("dragToClose") && this.Carousel.Panzoom.on({ touchMove: this.onTouchMove, afterTransform: this.onTransform, touchEnd: this.onTouchEnd }), this.trigger("initCarousel"), this } onCreateSlide(e, t) { let i = t.caption || ""; if ("function" == typeof this.options.caption && (i = this.options.caption.call(this, this, this.Carousel, t)), "string" == typeof i && i.length) { const e = document.createElement("div"), n = `fancybox__caption_${this.id}_${t.index}`; e.className = "fancybox__caption", e.innerHTML = i, e.setAttribute("id", n), t.$caption = t.$el.appendChild(e), t.$el.classList.add("has-caption"), t.$el.setAttribute("aria-labelledby", n) } } onSettle() { this.option("autoFocus") && this.focus() } onFocus(e) { this.isTopmost() && this.focus(e) } onClick(e) { if (e.defaultPrevented) return; let t = e.composedPath()[0]; if (t.matches("[data-fancybox-close]")) return e.preventDefault(), void N.close(!1, e); if (t.matches("[data-fancybox-next]")) return e.preventDefault(), void N.next(); if (t.matches("[data-fancybox-prev]")) return e.preventDefault(), void N.prev(); const i = document.activeElement; if (i) { if (i.closest("[contenteditable]")) return; t.matches(w) || i.blur() } if (!t.closest(".fancybox__content") && !getSelection().toString().length && !1 !== this.trigger("click", e)) switch (this.option("click")) { case "close": this.close(); break; case "next": this.next() } } onTouchMove() { const e = this.getSlide().Panzoom; return !e || 1 === e.content.scale } onTouchEnd(e) { const t = e.dragOffset.y; Math.abs(t) >= 150 || Math.abs(t) >= 35 && e.dragOffset.time < 350 ? (this.option("hideClass") && (this.getSlide().hideClass = "fancybox-throwOut" + (e.content.y < 0 ? "Up" : "Down")), this.close()) : "y" === e.lockAxis && e.panTo({ y: 0 }) } onTransform(e) { if (this.$backdrop) { const t = Math.abs(e.content.y), i = t < 1 ? "" : Math.max(.33, Math.min(1, 1 - t / e.content.fitHeight * 1.5)); this.$container.style.setProperty("--fancybox-ts", i ? "0s" : ""), this.$container.style.setProperty("--fancybox-opacity", i) } } onMousedown() { "ready" === this.state && document.body.classList.add("is-using-mouse") } onKeydown(e) { if (!this.isTopmost()) return; document.body.classList.remove("is-using-mouse"); const t = e.key, i = this.option("keyboard"); if (!i || e.ctrlKey || e.altKey || e.shiftKey) return; const n = e.composedPath()[0], s = document.activeElement && document.activeElement.classList, a = s && s.contains("carousel__button"); if ("Escape" !== t && !a && (e.target.isContentEditable || -1 !== ["BUTTON", "TEXTAREA", "OPTION", "INPUT", "SELECT", "VIDEO"].indexOf(n.nodeName))) return; if (!1 === this.trigger("keydown", t, e)) return; const o = i[t]; "function" == typeof this[o] && this[o]() } getSlide() { const e = this.Carousel; if (!e) return null; const t = null === e.page ? e.option("initialPage") : e.page, i = e.pages || []; return i.length && i[t] ? i[t].slides[0] : null } focus(e) { if (N.ignoreFocusChange) return; if (["init", "closing", "customClosing", "destroy"].indexOf(this.state) > -1) return; const t = this.$container, i = this.getSlide(), n = "done" === i.state ? i.$el : null; if (n && n.contains(document.activeElement)) return; e && e.preventDefault(), N.ignoreFocusChange = !0; const s = Array.from(t.querySelectorAll(w)); let a, o = []; for (let e of s) { const t = e.offsetParent, i = n && n.contains(e), s = !this.Carousel.$viewport.contains(e); t && (i || s) ? (o.push(e), void 0 !== e.dataset.origTabindex && (e.tabIndex = e.dataset.origTabindex, e.removeAttribute("data-orig-tabindex")), (e.hasAttribute("autoFocus") || !a && i && !e.classList.contains("carousel__button")) && (a = e)) : (e.dataset.origTabindex = void 0 === e.dataset.origTabindex ? e.getAttribute("tabindex") : e.dataset.origTabindex, e.tabIndex = -1) } e ? o.indexOf(e.target) > -1 ? this.lastFocus = e.target : this.lastFocus === t ? C(o[o.length - 1]) : C(t) : this.option("autoFocus") && a ? C(a) : o.indexOf(document.activeElement) < 0 && C(t), this.lastFocus = document.activeElement, N.ignoreFocusChange = !1 } hideScrollbar() { if (!b) return; const e = window.innerWidth - document.documentElement.getBoundingClientRect().width, t = "fancybox-style-noscroll"; let i = document.getElementById(t); i || e > 0 && (i = document.createElement("style"), i.id = t, i.type = "text/css", i.innerHTML = `.compensate-for-scrollbar {padding-right: ${e}px;}`, document.getElementsByTagName("head")[0].appendChild(i), document.body.classList.add("compensate-for-scrollbar")) } revealScrollbar() { document.body.classList.remove("compensate-for-scrollbar"); const e = document.getElementById("fancybox-style-noscroll"); e && e.remove() } clearContent(e) { this.Carousel.trigger("removeSlide", e), e.$content && (e.$content.remove(), e.$content = null), e.$closeButton && (e.$closeButton.remove(), e.$closeButton = null), e._className && e.$el.classList.remove(e._className) } setContent(e, t, i = {}) { let n; const s = e.$el; if (t instanceof HTMLElement) ["img", "iframe", "video", "audio"].indexOf(t.nodeName.toLowerCase()) > -1 ? (n = document.createElement("div"), n.appendChild(t)) : n = t; else { const e = document.createRange().createContextualFragment(t); n = document.createElement("div"), n.appendChild(e) } if (e.filter && !e.error && (n = n.querySelector(e.filter)), n instanceof Element) return e._className = `has-${i.suffix || e.type || "unknown"}`, s.classList.add(e._className), n.classList.add("fancybox__content"), "none" !== n.style.display && "none" !== getComputedStyle(n).getPropertyValue("display") || (n.style.display = e.display || this.option("defaultDisplay") || "flex"), e.id && n.setAttribute("id", e.id), e.$content = n, s.prepend(n), this.manageCloseButton(e), "loading" !== e.state && this.revealContent(e), n; this.setError(e, "{{ELEMENT_NOT_FOUND}}") } manageCloseButton(e) { const t = void 0 === e.closeButton ? this.option("closeButton") : e.closeButton; if (!t || "top" === t && this.$closeButton) return; const i = document.createElement("button"); i.classList.add("carousel__button", "is-close"), i.setAttribute("title", this.options.l10n.CLOSE), i.innerHTML = this.option("template.closeButton"), i.addEventListener("click", (e => this.close(e))), "inside" === t ? (e.$closeButton && e.$closeButton.remove(), e.$closeButton = e.$content.appendChild(i)) : this.$closeButton = this.$container.insertBefore(i, this.$container.firstChild) } revealContent(e) { this.trigger("reveal", e), e.$content.style.visibility = ""; let t = !1; e.error || "loading" === e.state || null !== this.Carousel.prevPage || e.index !== this.options.startIndex || (t = void 0 === e.showClass ? this.option("showClass") : e.showClass), t ? (e.state = "animating", this.animateCSS(e.$content, t, (() => { this.done(e) }))) : this.done(e) } animateCSS(e, t, i) { if (e && e.dispatchEvent(new CustomEvent("animationend", { bubbles: !0, cancelable: !0 })), !e || !t) return void ("function" == typeof i && i()); const n = function (s) { s.currentTarget === this && (e.removeEventListener("animationend", n), i && i(), e.classList.remove(t)) }; e.addEventListener("animationend", n), e.classList.add(t) } done(e) { e.state = "done", this.trigger("done", e); const t = this.getSlide(); t && e.index === t.index && this.option("autoFocus") && this.focus() } setError(e, t) { e.error = t, this.hideLoading(e), this.clearContent(e); const i = document.createElement("div"); i.classList.add("fancybox-error"), i.innerHTML = this.localize(t || "<p>{{ERROR}}</p>"), this.setContent(e, i, { suffix: "error" }) } showLoading(e) { e.state = "loading", e.$el.classList.add("is-loading"); let t = e.$el.querySelector(".fancybox__spinner"); t || (t = document.createElement("div"), t.classList.add("fancybox__spinner"), t.innerHTML = this.option("template.spinner"), t.addEventListener("click", (() => { this.Carousel.Panzoom.velocity || this.close() })), e.$el.prepend(t)) } hideLoading(e) { const t = e.$el && e.$el.querySelector(".fancybox__spinner"); t && (t.remove(), e.$el.classList.remove("is-loading")), "loading" === e.state && (this.trigger("load", e), e.state = "ready") } next() { const e = this.Carousel; e && e.pages.length > 1 && e.slideNext() } prev() { const e = this.Carousel; e && e.pages.length > 1 && e.slidePrev() } jumpTo(...e) { this.Carousel && this.Carousel.slideTo(...e) } isClosing() { return ["closing", "customClosing", "destroy"].includes(this.state) } isTopmost() { return N.getInstance().id == this.id } close(e) { if (e && e.preventDefault(), this.isClosing()) return; if (!1 === this.trigger("shouldClose", e)) return; if (this.state = "closing", this.Carousel.Panzoom.destroy(), this.detachEvents(), this.trigger("closing", e), "destroy" === this.state) return; this.$container.setAttribute("aria-hidden", "true"), this.$container.classList.add("is-closing"); const t = this.getSlide(); if (this.Carousel.slides.forEach((e => { e.$content && e.index !== t.index && this.Carousel.trigger("removeSlide", e) })), "closing" === this.state) { const e = void 0 === t.hideClass ? this.option("hideClass") : t.hideClass; this.animateCSS(t.$content, e, (() => { this.destroy() }), !0) } } destroy() { if ("destroy" === this.state) return; this.state = "destroy", this.trigger("destroy"); const e = this.option("placeFocusBack") ? this.option("triggerTarget", this.getSlide().$trigger) : null; this.Carousel.destroy(), this.detachPlugins(), this.Carousel = null, this.options = {}, this.events = {}, this.$container.remove(), this.$container = this.$backdrop = this.$carousel = null, e && C(e), D.delete(this.id); const t = N.getInstance(); t ? t.focus() : (document.documentElement.classList.remove("with-fancybox"), document.body.classList.remove("is-using-mouse"), this.revealScrollbar()) } static show(e, t = {}) { return new N(e, t) } static fromEvent(e, t = {}) { if (e.defaultPrevented) return; if (e.button && 0 !== e.button) return; if (e.ctrlKey || e.metaKey || e.shiftKey) return; const i = e.composedPath()[0]; let n, s, a, o = i; if ((o.matches("[data-fancybox-trigger]") || (o = o.closest("[data-fancybox-trigger]"))) && (t.triggerTarget = o, n = o && o.dataset && o.dataset.fancyboxTrigger), n) { const e = document.querySelectorAll(`[data-fancybox="${n}"]`), t = parseInt(o.dataset.fancyboxIndex, 10) || 0; o = e.length ? e[t] : o } Array.from(N.openers.keys()).reverse().some((t => { a = o || i; let n = !1; try { a instanceof Element && ("string" == typeof t || t instanceof String) && (n = a.matches(t) || (a = a.closest(t))) } catch (e) { } return !!n && (e.preventDefault(), s = t, !0) })); let r = !1; if (s) { t.event = e, t.target = a, a.origTarget = i, r = N.fromOpener(s, t); const n = N.getInstance(); n && "ready" === n.state && e.detail && document.body.classList.add("is-using-mouse") } return r } static fromOpener(e, i = {}) { let n = [], s = i.startIndex || 0, a = i.target || null; const o = void 0 !== (i = t({}, i, N.openers.get(e))).groupAll && i.groupAll, r = void 0 === i.groupAttr ? "data-fancybox" : i.groupAttr, l = r && a ? a.getAttribute(`${r}`) : ""; if (!a || l || o) { const t = i.root || (a ? a.getRootNode() : document.body); n = [].slice.call(t.querySelectorAll(e)) } if (a && !o && (n = l ? n.filter((e => e.getAttribute(`${r}`) === l)) : [a]), !n.length) return !1; const c = N.getInstance(); return !(c && n.indexOf(c.options.$trigger) > -1) && (s = a ? n.indexOf(a) : s, n = n.map((function (e) { const t = ["false", "0", "no", "null", "undefined"], i = ["true", "1", "yes"], n = Object.assign({}, e.dataset), s = {}; for (let [e, a] of Object.entries(n)) if ("fancybox" !== e) if ("width" === e || "height" === e) s[`_${e}`] = a; else if ("string" == typeof a || a instanceof String) if (t.indexOf(a) > -1) s[e] = !1; else if (i.indexOf(s[e]) > -1) s[e] = !0; else try { s[e] = JSON.parse(a) } catch (t) { s[e] = a } else s[e] = a; return e instanceof Element && (s.$trigger = e), s })), new N(n, t({}, i, { startIndex: s, $trigger: a }))) } static bind(e, t = {}) { function i() { document.body.addEventListener("click", N.fromEvent, !1) } b && (N.openers.size || (/complete|interactive|loaded/.test(document.readyState) ? i() : document.addEventListener("DOMContentLoaded", i)), N.openers.set(e, t)) } static unbind(e) { N.openers.delete(e), N.openers.size || N.destroy() } static destroy() { let e; for (; e = N.getInstance();)e.destroy(); N.openers = new Map, document.body.removeEventListener("click", N.fromEvent, !1) } static getInstance(e) { return e ? D.get(e) : Array.from(D.values()).reverse().find((e => !e.isClosing() && e)) || null } static close(e = !0, t) { if (e) for (const e of D.values()) e.close(t); else { const e = N.getInstance(); e && e.close(t) } } static next() { const e = N.getInstance(); e && e.next() } static prev() { const e = N.getInstance(); e && e.prev() } } N.version = "4.0.31", N.defaults = I, N.openers = new Map, N.Plugins = O, N.bind("[data-fancybox]"); for (const [e, t] of Object.entries(N.Plugins || {})) "function" == typeof t.create && t.create(N); var R = i(755); R(".forget-pass-js").on("click", (function () { R("#forget-pass").addClass("open"), R("body").addClass("no-scroll") })), R(".popup-close-js").on("click", (function () { R(".popup").removeClass("open"), R("body").removeClass("no-scroll") })), R("#submit-inquiry").on("click", (function () { R("#code").addClass("open"), R("body").addClass("no-scroll") })), R(".popup__pincode input").keydown((function (e) { R(this).val("") })), R(".popup__pincode input").keyup((function (e) { var t = R(this).closest(".popup__pincode").find('input[type="number"]'); 8 == e.keyCode && t.eq(t.index(this) - 1).focus(), 0 == t.index(this) && t.eq(t.index(this)).focus() })), R(".popup__pincode input").keyup((function (e) { var t = R(this).closest(".popup__pincode"), i = t.find('input[type="number"]'), n = R(this).val(); if (n == n.replace(/[0-9]/, "")) return R(this).val(""), !1; i.eq(i.index(this) + 1).focus(); var s = ""; i.each((function () { s += parseInt(R(this).val()) || "0" })), t.find('input[type="hidden"]').val(s) })) }(), function () { "use strict"; function e(e) { return null !== e && "object" == typeof e && "constructor" in e && e.constructor === Object } function t(i = {}, n = {}) { Object.keys(n).forEach((s => { void 0 === i[s] ? i[s] = n[s] : e(n[s]) && e(i[s]) && Object.keys(n[s]).length > 0 && t(i[s], n[s]) })) } const i = { body: {}, addEventListener() { }, removeEventListener() { }, activeElement: { blur() { }, nodeName: "" }, querySelector() { return null }, querySelectorAll() { return [] }, getElementById() { return null }, createEvent() { return { initEvent() { } } }, createElement() { return { children: [], childNodes: [], style: {}, setAttribute() { }, getElementsByTagName() { return [] } } }, createElementNS() { return {} }, importNode() { return null }, location: { hash: "", host: "", hostname: "", href: "", origin: "", pathname: "", protocol: "", search: "" } }; function n() { const e = "undefined" != typeof document ? document : {}; return t(e, i), e } const s = { document: i, navigator: { userAgent: "" }, location: { hash: "", host: "", hostname: "", href: "", origin: "", pathname: "", protocol: "", search: "" }, history: { replaceState() { }, pushState() { }, go() { }, back() { } }, CustomEvent: function () { return this }, addEventListener() { }, removeEventListener() { }, getComputedStyle() { return { getPropertyValue() { return "" } } }, Image() { }, Date() { }, screen: {}, setTimeout() { }, clearTimeout() { }, matchMedia() { return {} }, requestAnimationFrame(e) { return "undefined" == typeof setTimeout ? (e(), null) : setTimeout(e, 0) }, cancelAnimationFrame(e) { "undefined" != typeof setTimeout && clearTimeout(e) } }; function a() { const e = "undefined" != typeof window ? window : {}; return t(e, s), e } class o extends Array { constructor(e) { "number" == typeof e ? super(e) : (super(...e || []), function (e) { const t = e.__proto__; Object.defineProperty(e, "__proto__", { get() { return t }, set(e) { t.__proto__ = e } }) }(this)) } } function r(e = []) { const t = []; return e.forEach((e => { Array.isArray(e) ? t.push(...r(e)) : t.push(e) })), t } function l(e, t) { return Array.prototype.filter.call(e, t) } function c(e, t) { const i = a(), s = n(); let r = []; if (!t && e instanceof o) return e; if (!e) return new o(r); if ("string" == typeof e) { const i = e.trim(); if (i.indexOf("<") >= 0 && i.indexOf(">") >= 0) { let e = "div"; 0 === i.indexOf("<li") && (e = "ul"), 0 === i.indexOf("<tr") && (e = "tbody"), 0 !== i.indexOf("<td") && 0 !== i.indexOf("<th") || (e = "tr"), 0 === i.indexOf("<tbody") && (e = "table"), 0 === i.indexOf("<option") && (e = "select"); const t = s.createElement(e); t.innerHTML = i; for (let e = 0; e < t.childNodes.length; e += 1)r.push(t.childNodes[e]) } else r = function (e, t) { if ("string" != typeof e) return [e]; const i = [], n = t.querySelectorAll(e); for (let e = 0; e < n.length; e += 1)i.push(n[e]); return i }(e.trim(), t || s) } else if (e.nodeType || e === i || e === s) r.push(e); else if (Array.isArray(e)) { if (e instanceof o) return e; r = e } return new o(function (e) { const t = []; for (let i = 0; i < e.length; i += 1)-1 === t.indexOf(e[i]) && t.push(e[i]); return t }(r)) } c.fn = o.prototype; const d = "resize scroll".split(" "); function h(e) { return function (...t) { if (void 0 === t[0]) { for (let t = 0; t < this.length; t += 1)d.indexOf(e) < 0 && (e in this[t] ? this[t][e]() : c(this[t]).trigger(e)); return this } return this.on(e, ...t) } } h("click"), h("blur"), h("focus"), h("focusin"), h("focusout"), h("keyup"), h("keydown"), h("keypress"), h("submit"), h("change"), h("mousedown"), h("mousemove"), h("mouseup"), h("mouseenter"), h("mouseleave"), h("mouseout"), h("mouseover"), h("touchstart"), h("touchend"), h("touchmove"), h("resize"), h("scroll"); const u = { addClass: function (...e) { const t = r(e.map((e => e.split(" ")))); return this.forEach((e => { e.classList.add(...t) })), this }, removeClass: function (...e) { const t = r(e.map((e => e.split(" ")))); return this.forEach((e => { e.classList.remove(...t) })), this }, hasClass: function (...e) { const t = r(e.map((e => e.split(" ")))); return l(this, (e => t.filter((t => e.classList.contains(t))).length > 0)).length > 0 }, toggleClass: function (...e) { const t = r(e.map((e => e.split(" ")))); this.forEach((e => { t.forEach((t => { e.classList.toggle(t) })) })) }, attr: function (e, t) { if (1 === arguments.length && "string" == typeof e) return this[0] ? this[0].getAttribute(e) : void 0; for (let i = 0; i < this.length; i += 1)if (2 === arguments.length) this[i].setAttribute(e, t); else for (const t in e) this[i][t] = e[t], this[i].setAttribute(t, e[t]); return this }, removeAttr: function (e) { for (let t = 0; t < this.length; t += 1)this[t].removeAttribute(e); return this }, transform: function (e) { for (let t = 0; t < this.length; t += 1)this[t].style.transform = e; return this }, transition: function (e) { for (let t = 0; t < this.length; t += 1)this[t].style.transitionDuration = "string" != typeof e ? `${e}ms` : e; return this }, on: function (...e) { let [t, i, n, s] = e; function a(e) { const t = e.target; if (!t) return; const s = e.target.dom7EventData || []; if (s.indexOf(e) < 0 && s.unshift(e), c(t).is(i)) n.apply(t, s); else { const e = c(t).parents(); for (let t = 0; t < e.length; t += 1)c(e[t]).is(i) && n.apply(e[t], s) } } function o(e) { const t = e && e.target && e.target.dom7EventData || []; t.indexOf(e) < 0 && t.unshift(e), n.apply(this, t) } "function" == typeof e[1] && ([t, n, s] = e, i = void 0), s || (s = !1); const r = t.split(" "); let l; for (let e = 0; e < this.length; e += 1) { const t = this[e]; if (i) for (l = 0; l < r.length; l += 1) { const e = r[l]; t.dom7LiveListeners || (t.dom7LiveListeners = {}), t.dom7LiveListeners[e] || (t.dom7LiveListeners[e] = []), t.dom7LiveListeners[e].push({ listener: n, proxyListener: a }), t.addEventListener(e, a, s) } else for (l = 0; l < r.length; l += 1) { const e = r[l]; t.dom7Listeners || (t.dom7Listeners = {}), t.dom7Listeners[e] || (t.dom7Listeners[e] = []), t.dom7Listeners[e].push({ listener: n, proxyListener: o }), t.addEventListener(e, o, s) } } return this }, off: function (...e) { let [t, i, n, s] = e; "function" == typeof e[1] && ([t, n, s] = e, i = void 0), s || (s = !1); const a = t.split(" "); for (let e = 0; e < a.length; e += 1) { const t = a[e]; for (let e = 0; e < this.length; e += 1) { const a = this[e]; let o; if (!i && a.dom7Listeners ? o = a.dom7Listeners[t] : i && a.dom7LiveListeners && (o = a.dom7LiveListeners[t]), o && o.length) for (let e = o.length - 1; e >= 0; e -= 1) { const i = o[e]; n && i.listener === n || n && i.listener && i.listener.dom7proxy && i.listener.dom7proxy === n ? (a.removeEventListener(t, i.proxyListener, s), o.splice(e, 1)) : n || (a.removeEventListener(t, i.proxyListener, s), o.splice(e, 1)) } } } return this }, trigger: function (...e) { const t = a(), i = e[0].split(" "), n = e[1]; for (let s = 0; s < i.length; s += 1) { const a = i[s]; for (let i = 0; i < this.length; i += 1) { const s = this[i]; if (t.CustomEvent) { const i = new t.CustomEvent(a, { detail: n, bubbles: !0, cancelable: !0 }); s.dom7EventData = e.filter(((e, t) => t > 0)), s.dispatchEvent(i), s.dom7EventData = [], delete s.dom7EventData } } } return this }, transitionEnd: function (e) { const t = this; return e && t.on("transitionend", (function i(n) { n.target === this && (e.call(this, n), t.off("transitionend", i)) })), this }, outerWidth: function (e) { if (this.length > 0) { if (e) { const e = this.styles(); return this[0].offsetWidth + parseFloat(e.getPropertyValue("margin-right")) + parseFloat(e.getPropertyValue("margin-left")) } return this[0].offsetWidth } return null }, outerHeight: function (e) { if (this.length > 0) { if (e) { const e = this.styles(); return this[0].offsetHeight + parseFloat(e.getPropertyValue("margin-top")) + parseFloat(e.getPropertyValue("margin-bottom")) } return this[0].offsetHeight } return null }, styles: function () { const e = a(); return this[0] ? e.getComputedStyle(this[0], null) : {} }, offset: function () { if (this.length > 0) { const e = a(), t = n(), i = this[0], s = i.getBoundingClientRect(), o = t.body, r = i.clientTop || o.clientTop || 0, l = i.clientLeft || o.clientLeft || 0, c = i === e ? e.scrollY : i.scrollTop, d = i === e ? e.scrollX : i.scrollLeft; return { top: s.top + c - r, left: s.left + d - l } } return null }, css: function (e, t) { const i = a(); let n; if (1 === arguments.length) { if ("string" != typeof e) { for (n = 0; n < this.length; n += 1)for (const t in e) this[n].style[t] = e[t]; return this } if (this[0]) return i.getComputedStyle(this[0], null).getPropertyValue(e) } if (2 === arguments.length && "string" == typeof e) { for (n = 0; n < this.length; n += 1)this[n].style[e] = t; return this } return this }, each: function (e) { return e ? (this.forEach(((t, i) => { e.apply(t, [t, i]) })), this) : this }, html: function (e) { if (void 0 === e) return this[0] ? this[0].innerHTML : null; for (let t = 0; t < this.length; t += 1)this[t].innerHTML = e; return this }, text: function (e) { if (void 0 === e) return this[0] ? this[0].textContent.trim() : null; for (let t = 0; t < this.length; t += 1)this[t].textContent = e; return this }, is: function (e) { const t = a(), i = n(), s = this[0]; let r, l; if (!s || void 0 === e) return !1; if ("string" == typeof e) { if (s.matches) return s.matches(e); if (s.webkitMatchesSelector) return s.webkitMatchesSelector(e); if (s.msMatchesSelector) return s.msMatchesSelector(e); for (r = c(e), l = 0; l < r.length; l += 1)if (r[l] === s) return !0; return !1 } if (e === i) return s === i; if (e === t) return s === t; if (e.nodeType || e instanceof o) { for (r = e.nodeType ? [e] : e, l = 0; l < r.length; l += 1)if (r[l] === s) return !0; return !1 } return !1 }, index: function () { let e, t = this[0]; if (t) { for (e = 0; null !== (t = t.previousSibling);)1 === t.nodeType && (e += 1); return e } }, eq: function (e) { if (void 0 === e) return this; const t = this.length; if (e > t - 1) return c([]); if (e < 0) { const i = t + e; return c(i < 0 ? [] : [this[i]]) } return c([this[e]]) }, append: function (...e) { let t; const i = n(); for (let n = 0; n < e.length; n += 1) { t = e[n]; for (let e = 0; e < this.length; e += 1)if ("string" == typeof t) { const n = i.createElement("div"); for (n.innerHTML = t; n.firstChild;)this[e].appendChild(n.firstChild) } else if (t instanceof o) for (let i = 0; i < t.length; i += 1)this[e].appendChild(t[i]); else this[e].appendChild(t) } return this }, prepend: function (e) { const t = n(); let i, s; for (i = 0; i < this.length; i += 1)if ("string" == typeof e) { const n = t.createElement("div"); for (n.innerHTML = e, s = n.childNodes.length - 1; s >= 0; s -= 1)this[i].insertBefore(n.childNodes[s], this[i].childNodes[0]) } else if (e instanceof o) for (s = 0; s < e.length; s += 1)this[i].insertBefore(e[s], this[i].childNodes[0]); else this[i].insertBefore(e, this[i].childNodes[0]); return this }, next: function (e) { return this.length > 0 ? e ? this[0].nextElementSibling && c(this[0].nextElementSibling).is(e) ? c([this[0].nextElementSibling]) : c([]) : this[0].nextElementSibling ? c([this[0].nextElementSibling]) : c([]) : c([]) }, nextAll: function (e) { const t = []; let i = this[0]; if (!i) return c([]); for (; i.nextElementSibling;) { const n = i.nextElementSibling; e ? c(n).is(e) && t.push(n) : t.push(n), i = n } return c(t) }, prev: function (e) { if (this.length > 0) { const t = this[0]; return e ? t.previousElementSibling && c(t.previousElementSibling).is(e) ? c([t.previousElementSibling]) : c([]) : t.previousElementSibling ? c([t.previousElementSibling]) : c([]) } return c([]) }, prevAll: function (e) { const t = []; let i = this[0]; if (!i) return c([]); for (; i.previousElementSibling;) { const n = i.previousElementSibling; e ? c(n).is(e) && t.push(n) : t.push(n), i = n } return c(t) }, parent: function (e) { const t = []; for (let i = 0; i < this.length; i += 1)null !== this[i].parentNode && (e ? c(this[i].parentNode).is(e) && t.push(this[i].parentNode) : t.push(this[i].parentNode)); return c(t) }, parents: function (e) { const t = []; for (let i = 0; i < this.length; i += 1) { let n = this[i].parentNode; for (; n;)e ? c(n).is(e) && t.push(n) : t.push(n), n = n.parentNode } return c(t) }, closest: function (e) { let t = this; return void 0 === e ? c([]) : (t.is(e) || (t = t.parents(e).eq(0)), t) }, find: function (e) { const t = []; for (let i = 0; i < this.length; i += 1) { const n = this[i].querySelectorAll(e); for (let e = 0; e < n.length; e += 1)t.push(n[e]) } return c(t) }, children: function (e) { const t = []; for (let i = 0; i < this.length; i += 1) { const n = this[i].children; for (let i = 0; i < n.length; i += 1)e && !c(n[i]).is(e) || t.push(n[i]) } return c(t) }, filter: function (e) { return c(l(this, e)) }, remove: function () { for (let e = 0; e < this.length; e += 1)this[e].parentNode && this[e].parentNode.removeChild(this[e]); return this } }; Object.keys(u).forEach((e => { Object.defineProperty(c.fn, e, { value: u[e], writable: !0 }) })); var p = c; function f(e, t = 0) { return setTimeout(e, t) } function m() { return Date.now() } function g(e, t = "x") { const i = a(); let n, s, o; const r = function (e) { const t = a(); let i; return t.getComputedStyle && (i = t.getComputedStyle(e, null)), !i && e.currentStyle && (i = e.currentStyle), i || (i = e.style), i }(e); return i.WebKitCSSMatrix ? (s = r.transform || r.webkitTransform, s.split(",").length > 6 && (s = s.split(", ").map((e => e.replace(",", "."))).join(", ")), o = new i.WebKitCSSMatrix("none" === s ? "" : s)) : (o = r.MozTransform || r.OTransform || r.MsTransform || r.msTransform || r.transform || r.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,"), n = o.toString().split(",")), "x" === t && (s = i.WebKitCSSMatrix ? o.m41 : 16 === n.length ? parseFloat(n[12]) : parseFloat(n[4])), "y" === t && (s = i.WebKitCSSMatrix ? o.m42 : 16 === n.length ? parseFloat(n[13]) : parseFloat(n[5])), s || 0 } function v(e) { return "object" == typeof e && null !== e && e.constructor && "Object" === Object.prototype.toString.call(e).slice(8, -1) } function y(...e) { const t = Object(e[0]), i = ["__proto__", "constructor", "prototype"]; for (let s = 1; s < e.length; s += 1) { const a = e[s]; if (null != a && (n = a, !("undefined" != typeof window && void 0 !== window.HTMLElement ? n instanceof HTMLElement : n && (1 === n.nodeType || 11 === n.nodeType)))) { const e = Object.keys(Object(a)).filter((e => i.indexOf(e) < 0)); for (let i = 0, n = e.length; i < n; i += 1) { const n = e[i], s = Object.getOwnPropertyDescriptor(a, n); void 0 !== s && s.enumerable && (v(t[n]) && v(a[n]) ? a[n].__swiper__ ? t[n] = a[n] : y(t[n], a[n]) : !v(t[n]) && v(a[n]) ? (t[n] = {}, a[n].__swiper__ ? t[n] = a[n] : y(t[n], a[n])) : t[n] = a[n]) } } } var n; return t } function b(e, t, i) { e.style.setProperty(t, i) } function x({ swiper: e, targetPosition: t, side: i }) { const n = a(), s = -e.translate; let o, r = null; const l = e.params.speed; e.wrapperEl.style.scrollSnapType = "none", n.cancelAnimationFrame(e.cssModeFrameID); const c = t > s ? "next" : "prev", d = (e, t) => "next" === c && e >= t || "prev" === c && e <= t, h = () => { o = (new Date).getTime(), null === r && (r = o); const a = Math.max(Math.min((o - r) / l, 1), 0), c = .5 - Math.cos(a * Math.PI) / 2; let u = s + c * (t - s); if (d(u, t) && (u = t), e.wrapperEl.scrollTo({ [i]: u }), d(u, t)) return e.wrapperEl.style.overflow = "hidden", e.wrapperEl.style.scrollSnapType = "", setTimeout((() => { e.wrapperEl.style.overflow = "", e.wrapperEl.scrollTo({ [i]: u }) })), void n.cancelAnimationFrame(e.cssModeFrameID); e.cssModeFrameID = n.requestAnimationFrame(h) }; h() } let w, C, E; function T() { return w || (w = function () { const e = a(), t = n(); return { smoothScroll: t.documentElement && "scrollBehavior" in t.documentElement.style, touch: !!("ontouchstart" in e || e.DocumentTouch && t instanceof e.DocumentTouch), passiveListener: function () { let t = !1; try { const i = Object.defineProperty({}, "passive", { get() { t = !0 } }); e.addEventListener("testPassiveListener", null, i) } catch (e) { } return t }(), gestures: "ongesturestart" in e } }()), w } function S(e = {}) { return C || (C = function ({ userAgent: e } = {}) { const t = T(), i = a(), n = i.navigator.platform, s = e || i.navigator.userAgent, o = { ios: !1, android: !1 }, r = i.screen.width, l = i.screen.height, c = s.match(/(Android);?[\s\/]+([\d.]+)?/); let d = s.match(/(iPad).*OS\s([\d_]+)/); const h = s.match(/(iPod)(.*OS\s([\d_]+))?/), u = !d && s.match(/(iPhone\sOS|iOS)\s([\d_]+)/), p = "Win32" === n; let f = "MacIntel" === n; return !d && f && t.touch && ["1024x1366", "1366x1024", "834x1194", "1194x834", "834x1112", "1112x834", "768x1024", "1024x768", "820x1180", "1180x820", "810x1080", "1080x810"].indexOf(`${r}x${l}`) >= 0 && (d = s.match(/(Version)\/([\d.]+)/), d || (d = [0, 1, "13_0_0"]), f = !1), c && !p && (o.os = "android", o.android = !0), (d || u || h) && (o.os = "ios", o.ios = !0), o }(e)), C } function $() { return E || (E = function () { const e = a(); return { isSafari: function () { const t = e.navigator.userAgent.toLowerCase(); return t.indexOf("safari") >= 0 && t.indexOf("chrome") < 0 && t.indexOf("android") < 0 }(), isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(e.navigator.userAgent) } }()), E } var M = { on(e, t, i) { const n = this; if (!n.eventsListeners || n.destroyed) return n; if ("function" != typeof t) return n; const s = i ? "unshift" : "push"; return e.split(" ").forEach((e => { n.eventsListeners[e] || (n.eventsListeners[e] = []), n.eventsListeners[e][s](t) })), n }, once(e, t, i) { const n = this; if (!n.eventsListeners || n.destroyed) return n; if ("function" != typeof t) return n; function s(...i) { n.off(e, s), s.__emitterProxy && delete s.__emitterProxy, t.apply(n, i) } return s.__emitterProxy = t, n.on(e, s, i) }, onAny(e, t) { const i = this; if (!i.eventsListeners || i.destroyed) return i; if ("function" != typeof e) return i; const n = t ? "unshift" : "push"; return i.eventsAnyListeners.indexOf(e) < 0 && i.eventsAnyListeners[n](e), i }, offAny(e) { const t = this; if (!t.eventsListeners || t.destroyed) return t; if (!t.eventsAnyListeners) return t; const i = t.eventsAnyListeners.indexOf(e); return i >= 0 && t.eventsAnyListeners.splice(i, 1), t }, off(e, t) { const i = this; return !i.eventsListeners || i.destroyed ? i : i.eventsListeners ? (e.split(" ").forEach((e => { void 0 === t ? i.eventsListeners[e] = [] : i.eventsListeners[e] && i.eventsListeners[e].forEach(((n, s) => { (n === t || n.__emitterProxy && n.__emitterProxy === t) && i.eventsListeners[e].splice(s, 1) })) })), i) : i }, emit(...e) { const t = this; if (!t.eventsListeners || t.destroyed) return t; if (!t.eventsListeners) return t; let i, n, s; "string" == typeof e[0] || Array.isArray(e[0]) ? (i = e[0], n = e.slice(1, e.length), s = t) : (i = e[0].events, n = e[0].data, s = e[0].context || t), n.unshift(s); return (Array.isArray(i) ? i : i.split(" ")).forEach((e => { t.eventsAnyListeners && t.eventsAnyListeners.length && t.eventsAnyListeners.forEach((t => { t.apply(s, [e, ...n]) })), t.eventsListeners && t.eventsListeners[e] && t.eventsListeners[e].forEach((e => { e.apply(s, n) })) })), t } }; var P = { updateSize: function () { const e = this; let t, i; const n = e.$el; t = void 0 !== e.params.width && null !== e.params.width ? e.params.width : n[0].clientWidth, i = void 0 !== e.params.height && null !== e.params.height ? e.params.height : n[0].clientHeight, 0 === t && e.isHorizontal() || 0 === i && e.isVertical() || (t = t - parseInt(n.css("padding-left") || 0, 10) - parseInt(n.css("padding-right") || 0, 10), i = i - parseInt(n.css("padding-top") || 0, 10) - parseInt(n.css("padding-bottom") || 0, 10), Number.isNaN(t) && (t = 0), Number.isNaN(i) && (i = 0), Object.assign(e, { width: t, height: i, size: e.isHorizontal() ? t : i })) }, updateSlides: function () { const e = this; function t(t) { return e.isHorizontal() ? t : { width: "height", "margin-top": "margin-left", "margin-bottom ": "margin-right", "margin-left": "margin-top", "margin-right": "margin-bottom", "padding-left": "padding-top", "padding-right": "padding-bottom", marginRight: "marginBottom" }[t] } function i(e, i) { return parseFloat(e.getPropertyValue(t(i)) || 0) } const n = e.params, { $wrapperEl: s, size: a, rtlTranslate: o, wrongRTL: r } = e, l = e.virtual && n.virtual.enabled, c = l ? e.virtual.slides.length : e.slides.length, d = s.children(`.${e.params.slideClass}`), h = l ? e.virtual.slides.length : d.length; let u = []; const p = [], f = []; let m = n.slidesOffsetBefore; "function" == typeof m && (m = n.slidesOffsetBefore.call(e)); let g = n.slidesOffsetAfter; "function" == typeof g && (g = n.slidesOffsetAfter.call(e)); const v = e.snapGrid.length, y = e.slidesGrid.length; let x = n.spaceBetween, w = -m, C = 0, E = 0; if (void 0 === a) return; "string" == typeof x && x.indexOf("%") >= 0 && (x = parseFloat(x.replace("%", "")) / 100 * a), e.virtualSize = -x, o ? d.css({ marginLeft: "", marginBottom: "", marginTop: "" }) : d.css({ marginRight: "", marginBottom: "", marginTop: "" }), n.centeredSlides && n.cssMode && (b(e.wrapperEl, "--swiper-centered-offset-before", ""), b(e.wrapperEl, "--swiper-centered-offset-after", "")); const T = n.grid && n.grid.rows > 1 && e.grid; let S; T && e.grid.initSlides(h); const $ = "auto" === n.slidesPerView && n.breakpoints && Object.keys(n.breakpoints).filter((e => void 0 !== n.breakpoints[e].slidesPerView)).length > 0; for (let s = 0; s < h; s += 1) { S = 0; const o = d.eq(s); if (T && e.grid.updateSlide(s, o, h, t), "none" !== o.css("display")) { if ("auto" === n.slidesPerView) { $ && (d[s].style[t("width")] = ""); const a = getComputedStyle(o[0]), r = o[0].style.transform, l = o[0].style.webkitTransform; if (r && (o[0].style.transform = "none"), l && (o[0].style.webkitTransform = "none"), n.roundLengths) S = e.isHorizontal() ? o.outerWidth(!0) : o.outerHeight(!0); else { const e = i(a, "width"), t = i(a, "padding-left"), n = i(a, "padding-right"), s = i(a, "margin-left"), r = i(a, "margin-right"), l = a.getPropertyValue("box-sizing"); if (l && "border-box" === l) S = e + s + r; else { const { clientWidth: i, offsetWidth: a } = o[0]; S = e + t + n + s + r + (a - i) } } r && (o[0].style.transform = r), l && (o[0].style.webkitTransform = l), n.roundLengths && (S = Math.floor(S)) } else S = (a - (n.slidesPerView - 1) * x) / n.slidesPerView, n.roundLengths && (S = Math.floor(S)), d[s] && (d[s].style[t("width")] = `${S}px`); d[s] && (d[s].swiperSlideSize = S), f.push(S), n.centeredSlides ? (w = w + S / 2 + C / 2 + x, 0 === C && 0 !== s && (w = w - a / 2 - x), 0 === s && (w = w - a / 2 - x), Math.abs(w) < .001 && (w = 0), n.roundLengths && (w = Math.floor(w)), E % n.slidesPerGroup == 0 && u.push(w), p.push(w)) : (n.roundLengths && (w = Math.floor(w)), (E - Math.min(e.params.slidesPerGroupSkip, E)) % e.params.slidesPerGroup == 0 && u.push(w), p.push(w), w = w + S + x), e.virtualSize += S + x, C = S, E += 1 } } if (e.virtualSize = Math.max(e.virtualSize, a) + g, o && r && ("slide" === n.effect || "coverflow" === n.effect) && s.css({ width: `${e.virtualSize + n.spaceBetween}px` }), n.setWrapperSize && s.css({ [t("width")]: `${e.virtualSize + n.spaceBetween}px` }), T && e.grid.updateWrapperSize(S, u, t), !n.centeredSlides) { const t = []; for (let i = 0; i < u.length; i += 1) { let s = u[i]; n.roundLengths && (s = Math.floor(s)), u[i] <= e.virtualSize - a && t.push(s) } u = t, Math.floor(e.virtualSize - a) - Math.floor(u[u.length - 1]) > 1 && u.push(e.virtualSize - a) } if (0 === u.length && (u = [0]), 0 !== n.spaceBetween) { const i = e.isHorizontal() && o ? "marginLeft" : t("marginRight"); d.filter(((e, t) => !n.cssMode || t !== d.length - 1)).css({ [i]: `${x}px` }) } if (n.centeredSlides && n.centeredSlidesBounds) { let e = 0; f.forEach((t => { e += t + (n.spaceBetween ? n.spaceBetween : 0) })), e -= n.spaceBetween; const t = e - a; u = u.map((e => e < 0 ? -m : e > t ? t + g : e)) } if (n.centerInsufficientSlides) { let e = 0; if (f.forEach((t => { e += t + (n.spaceBetween ? n.spaceBetween : 0) })), e -= n.spaceBetween, e < a) { const t = (a - e) / 2; u.forEach(((e, i) => { u[i] = e - t })), p.forEach(((e, i) => { p[i] = e + t })) } } if (Object.assign(e, { slides: d, snapGrid: u, slidesGrid: p, slidesSizesGrid: f }), n.centeredSlides && n.cssMode && !n.centeredSlidesBounds) { b(e.wrapperEl, "--swiper-centered-offset-before", -u[0] + "px"), b(e.wrapperEl, "--swiper-centered-offset-after", e.size / 2 - f[f.length - 1] / 2 + "px"); const t = -e.snapGrid[0], i = -e.slidesGrid[0]; e.snapGrid = e.snapGrid.map((e => e + t)), e.slidesGrid = e.slidesGrid.map((e => e + i)) } if (h !== c && e.emit("slidesLengthChange"), u.length !== v && (e.params.watchOverflow && e.checkOverflow(), e.emit("snapGridLengthChange")), p.length !== y && e.emit("slidesGridLengthChange"), n.watchSlidesProgress && e.updateSlidesOffset(), !(l || n.cssMode || "slide" !== n.effect && "fade" !== n.effect)) { const t = `${n.containerModifierClass}backface-hidden`, i = e.$el.hasClass(t); h <= n.maxBackfaceHiddenSlides ? i || e.$el.addClass(t) : i && e.$el.removeClass(t) } }, updateAutoHeight: function (e) { const t = this, i = [], n = t.virtual && t.params.virtual.enabled; let s, a = 0; "number" == typeof e ? t.setTransition(e) : !0 === e && t.setTransition(t.params.speed); const o = e => n ? t.slides.filter((t => parseInt(t.getAttribute("data-swiper-slide-index"), 10) === e))[0] : t.slides.eq(e)[0]; if ("auto" !== t.params.slidesPerView && t.params.slidesPerView > 1) if (t.params.centeredSlides) (t.visibleSlides || p([])).each((e => { i.push(e) })); else for (s = 0; s < Math.ceil(t.params.slidesPerView); s += 1) { const e = t.activeIndex + s; if (e > t.slides.length && !n) break; i.push(o(e)) } else i.push(o(t.activeIndex)); for (s = 0; s < i.length; s += 1)if (void 0 !== i[s]) { const e = i[s].offsetHeight; a = e > a ? e : a } (a || 0 === a) && t.$wrapperEl.css("height", `${a}px`) }, updateSlidesOffset: function () { const e = this, t = e.slides; for (let i = 0; i < t.length; i += 1)t[i].swiperSlideOffset = e.isHorizontal() ? t[i].offsetLeft : t[i].offsetTop }, updateSlidesProgress: function (e = this && this.translate || 0) { const t = this, i = t.params, { slides: n, rtlTranslate: s, snapGrid: a } = t; if (0 === n.length) return; void 0 === n[0].swiperSlideOffset && t.updateSlidesOffset(); let o = -e; s && (o = e), n.removeClass(i.slideVisibleClass), t.visibleSlidesIndexes = [], t.visibleSlides = []; for (let e = 0; e < n.length; e += 1) { const r = n[e]; let l = r.swiperSlideOffset; i.cssMode && i.centeredSlides && (l -= n[0].swiperSlideOffset); const c = (o + (i.centeredSlides ? t.minTranslate() : 0) - l) / (r.swiperSlideSize + i.spaceBetween), d = (o - a[0] + (i.centeredSlides ? t.minTranslate() : 0) - l) / (r.swiperSlideSize + i.spaceBetween), h = -(o - l), u = h + t.slidesSizesGrid[e]; (h >= 0 && h < t.size - 1 || u > 1 && u <= t.size || h <= 0 && u >= t.size) && (t.visibleSlides.push(r), t.visibleSlidesIndexes.push(e), n.eq(e).addClass(i.slideVisibleClass)), r.progress = s ? -c : c, r.originalProgress = s ? -d : d } t.visibleSlides = p(t.visibleSlides) }, updateProgress: function (e) { const t = this; if (void 0 === e) { const i = t.rtlTranslate ? -1 : 1; e = t && t.translate && t.translate * i || 0 } const i = t.params, n = t.maxTranslate() - t.minTranslate(); let { progress: s, isBeginning: a, isEnd: o } = t; const r = a, l = o; 0 === n ? (s = 0, a = !0, o = !0) : (s = (e - t.minTranslate()) / n, a = s <= 0, o = s >= 1), Object.assign(t, { progress: s, isBeginning: a, isEnd: o }), (i.watchSlidesProgress || i.centeredSlides && i.autoHeight) && t.updateSlidesProgress(e), a && !r && t.emit("reachBeginning toEdge"), o && !l && t.emit("reachEnd toEdge"), (r && !a || l && !o) && t.emit("fromEdge"), t.emit("progress", s) }, updateSlidesClasses: function () { const e = this, { slides: t, params: i, $wrapperEl: n, activeIndex: s, realIndex: a } = e, o = e.virtual && i.virtual.enabled; let r; t.removeClass(`${i.slideActiveClass} ${i.slideNextClass} ${i.slidePrevClass} ${i.slideDuplicateActiveClass} ${i.slideDuplicateNextClass} ${i.slideDuplicatePrevClass}`), r = o ? e.$wrapperEl.find(`.${i.slideClass}[data-swiper-slide-index="${s}"]`) : t.eq(s), r.addClass(i.slideActiveClass), i.loop && (r.hasClass(i.slideDuplicateClass) ? n.children(`.${i.slideClass}:not(.${i.slideDuplicateClass})[data-swiper-slide-index="${a}"]`).addClass(i.slideDuplicateActiveClass) : n.children(`.${i.slideClass}.${i.slideDuplicateClass}[data-swiper-slide-index="${a}"]`).addClass(i.slideDuplicateActiveClass)); let l = r.nextAll(`.${i.slideClass}`).eq(0).addClass(i.slideNextClass); i.loop && 0 === l.length && (l = t.eq(0), l.addClass(i.slideNextClass)); let c = r.prevAll(`.${i.slideClass}`).eq(0).addClass(i.slidePrevClass); i.loop && 0 === c.length && (c = t.eq(-1), c.addClass(i.slidePrevClass)), i.loop && (l.hasClass(i.slideDuplicateClass) ? n.children(`.${i.slideClass}:not(.${i.slideDuplicateClass})[data-swiper-slide-index="${l.attr("data-swiper-slide-index")}"]`).addClass(i.slideDuplicateNextClass) : n.children(`.${i.slideClass}.${i.slideDuplicateClass}[data-swiper-slide-index="${l.attr("data-swiper-slide-index")}"]`).addClass(i.slideDuplicateNextClass), c.hasClass(i.slideDuplicateClass) ? n.children(`.${i.slideClass}:not(.${i.slideDuplicateClass})[data-swiper-slide-index="${c.attr("data-swiper-slide-index")}"]`).addClass(i.slideDuplicatePrevClass) : n.children(`.${i.slideClass}.${i.slideDuplicateClass}[data-swiper-slide-index="${c.attr("data-swiper-slide-index")}"]`).addClass(i.slideDuplicatePrevClass)), e.emitSlidesClasses() }, updateActiveIndex: function (e) { const t = this, i = t.rtlTranslate ? t.translate : -t.translate, { slidesGrid: n, snapGrid: s, params: a, activeIndex: o, realIndex: r, snapIndex: l } = t; let c, d = e; if (void 0 === d) { for (let e = 0; e < n.length; e += 1)void 0 !== n[e + 1] ? i >= n[e] && i < n[e + 1] - (n[e + 1] - n[e]) / 2 ? d = e : i >= n[e] && i < n[e + 1] && (d = e + 1) : i >= n[e] && (d = e); a.normalizeSlideIndex && (d < 0 || void 0 === d) && (d = 0) } if (s.indexOf(i) >= 0) c = s.indexOf(i); else { const e = Math.min(a.slidesPerGroupSkip, d); c = e + Math.floor((d - e) / a.slidesPerGroup) } if (c >= s.length && (c = s.length - 1), d === o) return void (c !== l && (t.snapIndex = c, t.emit("snapIndexChange"))); const h = parseInt(t.slides.eq(d).attr("data-swiper-slide-index") || d, 10); Object.assign(t, { snapIndex: c, realIndex: h, previousIndex: o, activeIndex: d }), t.emit("activeIndexChange"), t.emit("snapIndexChange"), r !== h && t.emit("realIndexChange"), (t.initialized || t.params.runCallbacksOnInit) && t.emit("slideChange") }, updateClickedSlide: function (e) { const t = this, i = t.params, n = p(e).closest(`.${i.slideClass}`)[0]; let s, a = !1; if (n) for (let e = 0; e < t.slides.length; e += 1)if (t.slides[e] === n) { a = !0, s = e; break } if (!n || !a) return t.clickedSlide = void 0, void (t.clickedIndex = void 0); t.clickedSlide = n, t.virtual && t.params.virtual.enabled ? t.clickedIndex = parseInt(p(n).attr("data-swiper-slide-index"), 10) : t.clickedIndex = s, i.slideToClickedSlide && void 0 !== t.clickedIndex && t.clickedIndex !== t.activeIndex && t.slideToClickedSlide() } }; var k = { getTranslate: function (e = (this.isHorizontal() ? "x" : "y")) { const { params: t, rtlTranslate: i, translate: n, $wrapperEl: s } = this; if (t.virtualTranslate) return i ? -n : n; if (t.cssMode) return n; let a = g(s[0], e); return i && (a = -a), a || 0 }, setTranslate: function (e, t) { const i = this, { rtlTranslate: n, params: s, $wrapperEl: a, wrapperEl: o, progress: r } = i; let l, c = 0, d = 0; i.isHorizontal() ? c = n ? -e : e : d = e, s.roundLengths && (c = Math.floor(c), d = Math.floor(d)), s.cssMode ? o[i.isHorizontal() ? "scrollLeft" : "scrollTop"] = i.isHorizontal() ? -c : -d : s.virtualTranslate || a.transform(`translate3d(${c}px, ${d}px, 0px)`), i.previousTranslate = i.translate, i.translate = i.isHorizontal() ? c : d; const h = i.maxTranslate() - i.minTranslate(); l = 0 === h ? 0 : (e - i.minTranslate()) / h, l !== r && i.updateProgress(e), i.emit("setTranslate", i.translate, t) }, minTranslate: function () { return -this.snapGrid[0] }, maxTranslate: function () { return -this.snapGrid[this.snapGrid.length - 1] }, translateTo: function (e = 0, t = this.params.speed, i = !0, n = !0, s) { const a = this, { params: o, wrapperEl: r } = a; if (a.animating && o.preventInteractionOnTransition) return !1; const l = a.minTranslate(), c = a.maxTranslate(); let d; if (d = n && e > l ? l : n && e < c ? c : e, a.updateProgress(d), o.cssMode) { const e = a.isHorizontal(); if (0 === t) r[e ? "scrollLeft" : "scrollTop"] = -d; else { if (!a.support.smoothScroll) return x({ swiper: a, targetPosition: -d, side: e ? "left" : "top" }), !0; r.scrollTo({ [e ? "left" : "top"]: -d, behavior: "smooth" }) } return !0 } return 0 === t ? (a.setTransition(0), a.setTranslate(d), i && (a.emit("beforeTransitionStart", t, s), a.emit("transitionEnd"))) : (a.setTransition(t), a.setTranslate(d), i && (a.emit("beforeTransitionStart", t, s), a.emit("transitionStart")), a.animating || (a.animating = !0, a.onTranslateToWrapperTransitionEnd || (a.onTranslateToWrapperTransitionEnd = function (e) { a && !a.destroyed && e.target === this && (a.$wrapperEl[0].removeEventListener("transitionend", a.onTranslateToWrapperTransitionEnd), a.$wrapperEl[0].removeEventListener("webkitTransitionEnd", a.onTranslateToWrapperTransitionEnd), a.onTranslateToWrapperTransitionEnd = null, delete a.onTranslateToWrapperTransitionEnd, i && a.emit("transitionEnd")) }), a.$wrapperEl[0].addEventListener("transitionend", a.onTranslateToWrapperTransitionEnd), a.$wrapperEl[0].addEventListener("webkitTransitionEnd", a.onTranslateToWrapperTransitionEnd))), !0 } }; function L({ swiper: e, runCallbacks: t, direction: i, step: n }) { const { activeIndex: s, previousIndex: a } = e; let o = i; if (o || (o = s > a ? "next" : s < a ? "prev" : "reset"), e.emit(`transition${n}`), t && s !== a) { if ("reset" === o) return void e.emit(`slideResetTransition${n}`); e.emit(`slideChangeTransition${n}`), "next" === o ? e.emit(`slideNextTransition${n}`) : e.emit(`slidePrevTransition${n}`) } } var A = { slideTo: function (e = 0, t = this.params.speed, i = !0, n, s) { if ("number" != typeof e && "string" != typeof e) throw new Error(`The 'index' argument cannot have type other than 'number' or 'string'. [${typeof e}] given.`); if ("string" == typeof e) { const t = parseInt(e, 10); if (!isFinite(t)) throw new Error(`The passed-in 'index' (string) couldn't be converted to 'number'. [${e}] given.`); e = t } const a = this; let o = e; o < 0 && (o = 0); const { params: r, snapGrid: l, slidesGrid: c, previousIndex: d, activeIndex: h, rtlTranslate: u, wrapperEl: p, enabled: f } = a; if (a.animating && r.preventInteractionOnTransition || !f && !n && !s) return !1; const m = Math.min(a.params.slidesPerGroupSkip, o); let g = m + Math.floor((o - m) / a.params.slidesPerGroup); g >= l.length && (g = l.length - 1); const v = -l[g]; if (r.normalizeSlideIndex) for (let e = 0; e < c.length; e += 1) { const t = -Math.floor(100 * v), i = Math.floor(100 * c[e]), n = Math.floor(100 * c[e + 1]); void 0 !== c[e + 1] ? t >= i && t < n - (n - i) / 2 ? o = e : t >= i && t < n && (o = e + 1) : t >= i && (o = e) } if (a.initialized && o !== h) { if (!a.allowSlideNext && v < a.translate && v < a.minTranslate()) return !1; if (!a.allowSlidePrev && v > a.translate && v > a.maxTranslate() && (h || 0) !== o) return !1 } let y; if (o !== (d || 0) && i && a.emit("beforeSlideChangeStart"), a.updateProgress(v), y = o > h ? "next" : o < h ? "prev" : "reset", u && -v === a.translate || !u && v === a.translate) return a.updateActiveIndex(o), r.autoHeight && a.updateAutoHeight(), a.updateSlidesClasses(), "slide" !== r.effect && a.setTranslate(v), "reset" !== y && (a.transitionStart(i, y), a.transitionEnd(i, y)), !1; if (r.cssMode) { const e = a.isHorizontal(), i = u ? v : -v; if (0 === t) { const t = a.virtual && a.params.virtual.enabled; t && (a.wrapperEl.style.scrollSnapType = "none", a._immediateVirtual = !0), p[e ? "scrollLeft" : "scrollTop"] = i, t && requestAnimationFrame((() => { a.wrapperEl.style.scrollSnapType = "", a._swiperImmediateVirtual = !1 })) } else { if (!a.support.smoothScroll) return x({ swiper: a, targetPosition: i, side: e ? "left" : "top" }), !0; p.scrollTo({ [e ? "left" : "top"]: i, behavior: "smooth" }) } return !0 } return a.setTransition(t), a.setTranslate(v), a.updateActiveIndex(o), a.updateSlidesClasses(), a.emit("beforeTransitionStart", t, n), a.transitionStart(i, y), 0 === t ? a.transitionEnd(i, y) : a.animating || (a.animating = !0, a.onSlideToWrapperTransitionEnd || (a.onSlideToWrapperTransitionEnd = function (e) { a && !a.destroyed && e.target === this && (a.$wrapperEl[0].removeEventListener("transitionend", a.onSlideToWrapperTransitionEnd), a.$wrapperEl[0].removeEventListener("webkitTransitionEnd", a.onSlideToWrapperTransitionEnd), a.onSlideToWrapperTransitionEnd = null, delete a.onSlideToWrapperTransitionEnd, a.transitionEnd(i, y)) }), a.$wrapperEl[0].addEventListener("transitionend", a.onSlideToWrapperTransitionEnd), a.$wrapperEl[0].addEventListener("webkitTransitionEnd", a.onSlideToWrapperTransitionEnd)), !0 }, slideToLoop: function (e = 0, t = this.params.speed, i = !0, n) { if ("string" == typeof e) { const t = parseInt(e, 10); if (!isFinite(t)) throw new Error(`The passed-in 'index' (string) couldn't be converted to 'number'. [${e}] given.`); e = t } const s = this; let a = e; return s.params.loop && (a += s.loopedSlides), s.slideTo(a, t, i, n) }, slideNext: function (e = this.params.speed, t = !0, i) { const n = this, { animating: s, enabled: a, params: o } = n; if (!a) return n; let r = o.slidesPerGroup; "auto" === o.slidesPerView && 1 === o.slidesPerGroup && o.slidesPerGroupAuto && (r = Math.max(n.slidesPerViewDynamic("current", !0), 1)); const l = n.activeIndex < o.slidesPerGroupSkip ? 1 : r; if (o.loop) { if (s && o.loopPreventsSlide) return !1; n.loopFix(), n._clientLeft = n.$wrapperEl[0].clientLeft } return o.rewind && n.isEnd ? n.slideTo(0, e, t, i) : n.slideTo(n.activeIndex + l, e, t, i) }, slidePrev: function (e = this.params.speed, t = !0, i) { const n = this, { params: s, animating: a, snapGrid: o, slidesGrid: r, rtlTranslate: l, enabled: c } = n; if (!c) return n; if (s.loop) { if (a && s.loopPreventsSlide) return !1; n.loopFix(), n._clientLeft = n.$wrapperEl[0].clientLeft } function d(e) { return e < 0 ? -Math.floor(Math.abs(e)) : Math.floor(e) } const h = d(l ? n.translate : -n.translate), u = o.map((e => d(e))); let p = o[u.indexOf(h) - 1]; if (void 0 === p && s.cssMode) { let e; o.forEach(((t, i) => { h >= t && (e = i) })), void 0 !== e && (p = o[e > 0 ? e - 1 : e]) } let f = 0; if (void 0 !== p && (f = r.indexOf(p), f < 0 && (f = n.activeIndex - 1), "auto" === s.slidesPerView && 1 === s.slidesPerGroup && s.slidesPerGroupAuto && (f = f - n.slidesPerViewDynamic("previous", !0) + 1, f = Math.max(f, 0))), s.rewind && n.isBeginning) { const s = n.params.virtual && n.params.virtual.enabled && n.virtual ? n.virtual.slides.length - 1 : n.slides.length - 1; return n.slideTo(s, e, t, i) } return n.slideTo(f, e, t, i) }, slideReset: function (e = this.params.speed, t = !0, i) { return this.slideTo(this.activeIndex, e, t, i) }, slideToClosest: function (e = this.params.speed, t = !0, i, n = .5) { const s = this; let a = s.activeIndex; const o = Math.min(s.params.slidesPerGroupSkip, a), r = o + Math.floor((a - o) / s.params.slidesPerGroup), l = s.rtlTranslate ? s.translate : -s.translate; if (l >= s.snapGrid[r]) { const e = s.snapGrid[r]; l - e > (s.snapGrid[r + 1] - e) * n && (a += s.params.slidesPerGroup) } else { const e = s.snapGrid[r - 1]; l - e <= (s.snapGrid[r] - e) * n && (a -= s.params.slidesPerGroup) } return a = Math.max(a, 0), a = Math.min(a, s.slidesGrid.length - 1), s.slideTo(a, e, t, i) }, slideToClickedSlide: function () { const e = this, { params: t, $wrapperEl: i } = e, n = "auto" === t.slidesPerView ? e.slidesPerViewDynamic() : t.slidesPerView; let s, a = e.clickedIndex; if (t.loop) { if (e.animating) return; s = parseInt(p(e.clickedSlide).attr("data-swiper-slide-index"), 10), t.centeredSlides ? a < e.loopedSlides - n / 2 || a > e.slides.length - e.loopedSlides + n / 2 ? (e.loopFix(), a = i.children(`.${t.slideClass}[data-swiper-slide-index="${s}"]:not(.${t.slideDuplicateClass})`).eq(0).index(), f((() => { e.slideTo(a) }))) : e.slideTo(a) : a > e.slides.length - n ? (e.loopFix(), a = i.children(`.${t.slideClass}[data-swiper-slide-index="${s}"]:not(.${t.slideDuplicateClass})`).eq(0).index(), f((() => { e.slideTo(a) }))) : e.slideTo(a) } else e.slideTo(a) } }; var z = { loopCreate: function () { const e = this, t = n(), { params: i, $wrapperEl: s } = e, a = s.children().length > 0 ? p(s.children()[0].parentNode) : s; a.children(`.${i.slideClass}.${i.slideDuplicateClass}`).remove(); let o = a.children(`.${i.slideClass}`); if (i.loopFillGroupWithBlank) { const e = i.slidesPerGroup - o.length % i.slidesPerGroup; if (e !== i.slidesPerGroup) { for (let n = 0; n < e; n += 1) { const e = p(t.createElement("div")).addClass(`${i.slideClass} ${i.slideBlankClass}`); a.append(e) } o = a.children(`.${i.slideClass}`) } } "auto" !== i.slidesPerView || i.loopedSlides || (i.loopedSlides = o.length), e.loopedSlides = Math.ceil(parseFloat(i.loopedSlides || i.slidesPerView, 10)), e.loopedSlides += i.loopAdditionalSlides, e.loopedSlides > o.length && e.params.loopedSlidesLimit && (e.loopedSlides = o.length); const r = [], l = []; o.each(((e, t) => { p(e).attr("data-swiper-slide-index", t) })); for (let t = 0; t < e.loopedSlides; t += 1) { const e = t - Math.floor(t / o.length) * o.length; l.push(o.eq(e)[0]), r.unshift(o.eq(o.length - e - 1)[0]) } for (let e = 0; e < l.length; e += 1)a.append(p(l[e].cloneNode(!0)).addClass(i.slideDuplicateClass)); for (let e = r.length - 1; e >= 0; e -= 1)a.prepend(p(r[e].cloneNode(!0)).addClass(i.slideDuplicateClass)) }, loopFix: function () { const e = this; e.emit("beforeLoopFix"); const { activeIndex: t, slides: i, loopedSlides: n, allowSlidePrev: s, allowSlideNext: a, snapGrid: o, rtlTranslate: r } = e; let l; e.allowSlidePrev = !0, e.allowSlideNext = !0; const c = -o[t] - e.getTranslate(); if (t < n) { l = i.length - 3 * n + t, l += n; e.slideTo(l, 0, !1, !0) && 0 !== c && e.setTranslate((r ? -e.translate : e.translate) - c) } else if (t >= i.length - n) { l = -i.length + t + n, l += n; e.slideTo(l, 0, !1, !0) && 0 !== c && e.setTranslate((r ? -e.translate : e.translate) - c) } e.allowSlidePrev = s, e.allowSlideNext = a, e.emit("loopFix") }, loopDestroy: function () { const { $wrapperEl: e, params: t, slides: i } = this; e.children(`.${t.slideClass}.${t.slideDuplicateClass},.${t.slideClass}.${t.slideBlankClass}`).remove(), i.removeAttr("data-swiper-slide-index") } }; function O(e) { const t = this, i = n(), s = a(), o = t.touchEventsData, { params: r, touches: l, enabled: c } = t; if (!c) return; if (t.animating && r.preventInteractionOnTransition) return; !t.animating && r.cssMode && r.loop && t.loopFix(); let d = e; d.originalEvent && (d = d.originalEvent); let h = p(d.target); if ("wrapper" === r.touchEventsTarget && !h.closest(t.wrapperEl).length) return; if (o.isTouchEvent = "touchstart" === d.type, !o.isTouchEvent && "which" in d && 3 === d.which) return; if (!o.isTouchEvent && "button" in d && d.button > 0) return; if (o.isTouched && o.isMoved) return; const u = !!r.noSwipingClass && "" !== r.noSwipingClass, f = e.composedPath ? e.composedPath() : e.path; u && d.target && d.target.shadowRoot && f && (h = p(f[0])); const g = r.noSwipingSelector ? r.noSwipingSelector : `.${r.noSwipingClass}`, v = !(!d.target || !d.target.shadowRoot); if (r.noSwiping && (v ? function (e, t = this) { return function t(i) { if (!i || i === n() || i === a()) return null; i.assignedSlot && (i = i.assignedSlot); const s = i.closest(e); return s || i.getRootNode ? s || t(i.getRootNode().host) : null }(t) }(g, h[0]) : h.closest(g)[0])) return void (t.allowClick = !0); if (r.swipeHandler && !h.closest(r.swipeHandler)[0]) return; l.currentX = "touchstart" === d.type ? d.targetTouches[0].pageX : d.pageX, l.currentY = "touchstart" === d.type ? d.targetTouches[0].pageY : d.pageY; const y = l.currentX, b = l.currentY, x = r.edgeSwipeDetection || r.iOSEdgeSwipeDetection, w = r.edgeSwipeThreshold || r.iOSEdgeSwipeThreshold; if (x && (y <= w || y >= s.innerWidth - w)) { if ("prevent" !== x) return; e.preventDefault() } if (Object.assign(o, { isTouched: !0, isMoved: !1, allowTouchCallbacks: !0, isScrolling: void 0, startMoving: void 0 }), l.startX = y, l.startY = b, o.touchStartTime = m(), t.allowClick = !0, t.updateSize(), t.swipeDirection = void 0, r.threshold > 0 && (o.allowThresholdMove = !1), "touchstart" !== d.type) { let e = !0; h.is(o.focusableElements) && (e = !1, "SELECT" === h[0].nodeName && (o.isTouched = !1)), i.activeElement && p(i.activeElement).is(o.focusableElements) && i.activeElement !== h[0] && i.activeElement.blur(); const n = e && t.allowTouchMove && r.touchStartPreventDefault; !r.touchStartForcePreventDefault && !n || h[0].isContentEditable || d.preventDefault() } t.params.freeMode && t.params.freeMode.enabled && t.freeMode && t.animating && !r.cssMode && t.freeMode.onTouchStart(), t.emit("touchStart", d) } function I(e) { const t = n(), i = this, s = i.touchEventsData, { params: a, touches: o, rtlTranslate: r, enabled: l } = i; if (!l) return; let c = e; if (c.originalEvent && (c = c.originalEvent), !s.isTouched) return void (s.startMoving && s.isScrolling && i.emit("touchMoveOpposite", c)); if (s.isTouchEvent && "touchmove" !== c.type) return; const d = "touchmove" === c.type && c.targetTouches && (c.targetTouches[0] || c.changedTouches[0]), h = "touchmove" === c.type ? d.pageX : c.pageX, u = "touchmove" === c.type ? d.pageY : c.pageY; if (c.preventedByNestedSwiper) return o.startX = h, void (o.startY = u); if (!i.allowTouchMove) return p(c.target).is(s.focusableElements) || (i.allowClick = !1), void (s.isTouched && (Object.assign(o, { startX: h, startY: u, currentX: h, currentY: u }), s.touchStartTime = m())); if (s.isTouchEvent && a.touchReleaseOnEdges && !a.loop) if (i.isVertical()) { if (u < o.startY && i.translate <= i.maxTranslate() || u > o.startY && i.translate >= i.minTranslate()) return s.isTouched = !1, void (s.isMoved = !1) } else if (h < o.startX && i.translate <= i.maxTranslate() || h > o.startX && i.translate >= i.minTranslate()) return; if (s.isTouchEvent && t.activeElement && c.target === t.activeElement && p(c.target).is(s.focusableElements)) return s.isMoved = !0, void (i.allowClick = !1); if (s.allowTouchCallbacks && i.emit("touchMove", c), c.targetTouches && c.targetTouches.length > 1) return; o.currentX = h, o.currentY = u; const f = o.currentX - o.startX, g = o.currentY - o.startY; if (i.params.threshold && Math.sqrt(f ** 2 + g ** 2) < i.params.threshold) return; if (void 0 === s.isScrolling) { let e; i.isHorizontal() && o.currentY === o.startY || i.isVertical() && o.currentX === o.startX ? s.isScrolling = !1 : f * f + g * g >= 25 && (e = 180 * Math.atan2(Math.abs(g), Math.abs(f)) / Math.PI, s.isScrolling = i.isHorizontal() ? e > a.touchAngle : 90 - e > a.touchAngle) } if (s.isScrolling && i.emit("touchMoveOpposite", c), void 0 === s.startMoving && (o.currentX === o.startX && o.currentY === o.startY || (s.startMoving = !0)), s.isScrolling) return void (s.isTouched = !1); if (!s.startMoving) return; i.allowClick = !1, !a.cssMode && c.cancelable && c.preventDefault(), a.touchMoveStopPropagation && !a.nested && c.stopPropagation(), s.isMoved || (a.loop && !a.cssMode && i.loopFix(), s.startTranslate = i.getTranslate(), i.setTransition(0), i.animating && i.$wrapperEl.trigger("webkitTransitionEnd transitionend"), s.allowMomentumBounce = !1, !a.grabCursor || !0 !== i.allowSlideNext && !0 !== i.allowSlidePrev || i.setGrabCursor(!0), i.emit("sliderFirstMove", c)), i.emit("sliderMove", c), s.isMoved = !0; let v = i.isHorizontal() ? f : g; o.diff = v, v *= a.touchRatio, r && (v = -v), i.swipeDirection = v > 0 ? "prev" : "next", s.currentTranslate = v + s.startTranslate; let y = !0, b = a.resistanceRatio; if (a.touchReleaseOnEdges && (b = 0), v > 0 && s.currentTranslate > i.minTranslate() ? (y = !1, a.resistance && (s.currentTranslate = i.minTranslate() - 1 + (-i.minTranslate() + s.startTranslate + v) ** b)) : v < 0 && s.currentTranslate < i.maxTranslate() && (y = !1, a.resistance && (s.currentTranslate = i.maxTranslate() + 1 - (i.maxTranslate() - s.startTranslate - v) ** b)), y && (c.preventedByNestedSwiper = !0), !i.allowSlideNext && "next" === i.swipeDirection && s.currentTranslate < s.startTranslate && (s.currentTranslate = s.startTranslate), !i.allowSlidePrev && "prev" === i.swipeDirection && s.currentTranslate > s.startTranslate && (s.currentTranslate = s.startTranslate), i.allowSlidePrev || i.allowSlideNext || (s.currentTranslate = s.startTranslate), a.threshold > 0) { if (!(Math.abs(v) > a.threshold || s.allowThresholdMove)) return void (s.currentTranslate = s.startTranslate); if (!s.allowThresholdMove) return s.allowThresholdMove = !0, o.startX = o.currentX, o.startY = o.currentY, s.currentTranslate = s.startTranslate, void (o.diff = i.isHorizontal() ? o.currentX - o.startX : o.currentY - o.startY) } a.followFinger && !a.cssMode && ((a.freeMode && a.freeMode.enabled && i.freeMode || a.watchSlidesProgress) && (i.updateActiveIndex(), i.updateSlidesClasses()), i.params.freeMode && a.freeMode.enabled && i.freeMode && i.freeMode.onTouchMove(), i.updateProgress(s.currentTranslate), i.setTranslate(s.currentTranslate)) } function D(e) { const t = this, i = t.touchEventsData, { params: n, touches: s, rtlTranslate: a, slidesGrid: o, enabled: r } = t; if (!r) return; let l = e; if (l.originalEvent && (l = l.originalEvent), i.allowTouchCallbacks && t.emit("touchEnd", l), i.allowTouchCallbacks = !1, !i.isTouched) return i.isMoved && n.grabCursor && t.setGrabCursor(!1), i.isMoved = !1, void (i.startMoving = !1); n.grabCursor && i.isMoved && i.isTouched && (!0 === t.allowSlideNext || !0 === t.allowSlidePrev) && t.setGrabCursor(!1); const c = m(), d = c - i.touchStartTime; if (t.allowClick) { const e = l.path || l.composedPath && l.composedPath(); t.updateClickedSlide(e && e[0] || l.target), t.emit("tap click", l), d < 300 && c - i.lastClickTime < 300 && t.emit("doubleTap doubleClick", l) } if (i.lastClickTime = m(), f((() => { t.destroyed || (t.allowClick = !0) })), !i.isTouched || !i.isMoved || !t.swipeDirection || 0 === s.diff || i.currentTranslate === i.startTranslate) return i.isTouched = !1, i.isMoved = !1, void (i.startMoving = !1); let h; if (i.isTouched = !1, i.isMoved = !1, i.startMoving = !1, h = n.followFinger ? a ? t.translate : -t.translate : -i.currentTranslate, n.cssMode) return; if (t.params.freeMode && n.freeMode.enabled) return void t.freeMode.onTouchEnd({ currentPos: h }); let u = 0, p = t.slidesSizesGrid[0]; for (let e = 0; e < o.length; e += e < n.slidesPerGroupSkip ? 1 : n.slidesPerGroup) { const t = e < n.slidesPerGroupSkip - 1 ? 1 : n.slidesPerGroup; void 0 !== o[e + t] ? h >= o[e] && h < o[e + t] && (u = e, p = o[e + t] - o[e]) : h >= o[e] && (u = e, p = o[o.length - 1] - o[o.length - 2]) } let g = null, v = null; n.rewind && (t.isBeginning ? v = t.params.virtual && t.params.virtual.enabled && t.virtual ? t.virtual.slides.length - 1 : t.slides.length - 1 : t.isEnd && (g = 0)); const y = (h - o[u]) / p, b = u < n.slidesPerGroupSkip - 1 ? 1 : n.slidesPerGroup; if (d > n.longSwipesMs) { if (!n.longSwipes) return void t.slideTo(t.activeIndex); "next" === t.swipeDirection && (y >= n.longSwipesRatio ? t.slideTo(n.rewind && t.isEnd ? g : u + b) : t.slideTo(u)), "prev" === t.swipeDirection && (y > 1 - n.longSwipesRatio ? t.slideTo(u + b) : null !== v && y < 0 && Math.abs(y) > n.longSwipesRatio ? t.slideTo(v) : t.slideTo(u)) } else { if (!n.shortSwipes) return void t.slideTo(t.activeIndex); t.navigation && (l.target === t.navigation.nextEl || l.target === t.navigation.prevEl) ? l.target === t.navigation.nextEl ? t.slideTo(u + b) : t.slideTo(u) : ("next" === t.swipeDirection && t.slideTo(null !== g ? g : u + b), "prev" === t.swipeDirection && t.slideTo(null !== v ? v : u)) } } function _() { const e = this, { params: t, el: i } = e; if (i && 0 === i.offsetWidth) return; t.breakpoints && e.setBreakpoint(); const { allowSlideNext: n, allowSlidePrev: s, snapGrid: a } = e; e.allowSlideNext = !0, e.allowSlidePrev = !0, e.updateSize(), e.updateSlides(), e.updateSlidesClasses(), ("auto" === t.slidesPerView || t.slidesPerView > 1) && e.isEnd && !e.isBeginning && !e.params.centeredSlides ? e.slideTo(e.slides.length - 1, 0, !1, !0) : e.slideTo(e.activeIndex, 0, !1, !0), e.autoplay && e.autoplay.running && e.autoplay.paused && e.autoplay.run(), e.allowSlidePrev = s, e.allowSlideNext = n, e.params.watchOverflow && a !== e.snapGrid && e.checkOverflow() } function N(e) { const t = this; t.enabled && (t.allowClick || (t.params.preventClicks && e.preventDefault(), t.params.preventClicksPropagation && t.animating && (e.stopPropagation(), e.stopImmediatePropagation()))) } function R() { const e = this, { wrapperEl: t, rtlTranslate: i, enabled: n } = e; if (!n) return; let s; e.previousTranslate = e.translate, e.isHorizontal() ? e.translate = -t.scrollLeft : e.translate = -t.scrollTop, 0 === e.translate && (e.translate = 0), e.updateActiveIndex(), e.updateSlidesClasses(); const a = e.maxTranslate() - e.minTranslate(); s = 0 === a ? 0 : (e.translate - e.minTranslate()) / a, s !== e.progress && e.updateProgress(i ? -e.translate : e.translate), e.emit("setTranslate", e.translate, !1) } let H = !1; function j() { } const F = (e, t) => { const i = n(), { params: s, touchEvents: a, el: o, wrapperEl: r, device: l, support: c } = e, d = !!s.nested, h = "on" === t ? "addEventListener" : "removeEventListener", u = t; if (c.touch) { const t = !("touchstart" !== a.start || !c.passiveListener || !s.passiveListeners) && { passive: !0, capture: !1 }; o[h](a.start, e.onTouchStart, t), o[h](a.move, e.onTouchMove, c.passiveListener ? { passive: !1, capture: d } : d), o[h](a.end, e.onTouchEnd, t), a.cancel && o[h](a.cancel, e.onTouchEnd, t) } else o[h](a.start, e.onTouchStart, !1), i[h](a.move, e.onTouchMove, d), i[h](a.end, e.onTouchEnd, !1); (s.preventClicks || s.preventClicksPropagation) && o[h]("click", e.onClick, !0), s.cssMode && r[h]("scroll", e.onScroll), s.updateOnWindowResize ? e[u](l.ios || l.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", _, !0) : e[u]("observerUpdate", _, !0) }; var q = { attachEvents: function () { const e = this, t = n(), { params: i, support: s } = e; e.onTouchStart = O.bind(e), e.onTouchMove = I.bind(e), e.onTouchEnd = D.bind(e), i.cssMode && (e.onScroll = R.bind(e)), e.onClick = N.bind(e), s.touch && !H && (t.addEventListener("touchstart", j), H = !0), F(e, "on") }, detachEvents: function () { F(this, "off") } }; const B = (e, t) => e.grid && t.grid && t.grid.rows > 1; var W = { setBreakpoint: function () { const e = this, { activeIndex: t, initialized: i, loopedSlides: n = 0, params: s, $el: a } = e, o = s.breakpoints; if (!o || o && 0 === Object.keys(o).length) return; const r = e.getBreakpoint(o, e.params.breakpointsBase, e.el); if (!r || e.currentBreakpoint === r) return; const l = (r in o ? o[r] : void 0) || e.originalParams, c = B(e, s), d = B(e, l), h = s.enabled; c && !d ? (a.removeClass(`${s.containerModifierClass}grid ${s.containerModifierClass}grid-column`), e.emitContainerClasses()) : !c && d && (a.addClass(`${s.containerModifierClass}grid`), (l.grid.fill && "column" === l.grid.fill || !l.grid.fill && "column" === s.grid.fill) && a.addClass(`${s.containerModifierClass}grid-column`), e.emitContainerClasses()), ["navigation", "pagination", "scrollbar"].forEach((t => { const i = s[t] && s[t].enabled, n = l[t] && l[t].enabled; i && !n && e[t].disable(), !i && n && e[t].enable() })); const u = l.direction && l.direction !== s.direction, p = s.loop && (l.slidesPerView !== s.slidesPerView || u); u && i && e.changeDirection(), y(e.params, l); const f = e.params.enabled; Object.assign(e, { allowTouchMove: e.params.allowTouchMove, allowSlideNext: e.params.allowSlideNext, allowSlidePrev: e.params.allowSlidePrev }), h && !f ? e.disable() : !h && f && e.enable(), e.currentBreakpoint = r, e.emit("_beforeBreakpoint", l), p && i && (e.loopDestroy(), e.loopCreate(), e.updateSlides(), e.slideTo(t - n + e.loopedSlides, 0, !1)), e.emit("breakpoint", l) }, getBreakpoint: function (e, t = "window", i) { if (!e || "container" === t && !i) return; let n = !1; const s = a(), o = "window" === t ? s.innerHeight : i.clientHeight, r = Object.keys(e).map((e => { if ("string" == typeof e && 0 === e.indexOf("@")) { const t = parseFloat(e.substr(1)); return { value: o * t, point: e } } return { value: e, point: e } })); r.sort(((e, t) => parseInt(e.value, 10) - parseInt(t.value, 10))); for (let e = 0; e < r.length; e += 1) { const { point: a, value: o } = r[e]; "window" === t ? s.matchMedia(`(min-width: ${o}px)`).matches && (n = a) : o <= i.clientWidth && (n = a) } return n || "max" } }; var X = { addClasses: function () { const e = this, { classNames: t, params: i, rtl: n, $el: s, device: a, support: o } = e, r = function (e, t) { const i = []; return e.forEach((e => { "object" == typeof e ? Object.keys(e).forEach((n => { e[n] && i.push(t + n) })) : "string" == typeof e && i.push(t + e) })), i }(["initialized", i.direction, { "pointer-events": !o.touch }, { "free-mode": e.params.freeMode && i.freeMode.enabled }, { autoheight: i.autoHeight }, { rtl: n }, { grid: i.grid && i.grid.rows > 1 }, { "grid-column": i.grid && i.grid.rows > 1 && "column" === i.grid.fill }, { android: a.android }, { ios: a.ios }, { "css-mode": i.cssMode }, { centered: i.cssMode && i.centeredSlides }, { "watch-progress": i.watchSlidesProgress }], i.containerModifierClass); t.push(...r), s.addClass([...t].join(" ")), e.emitContainerClasses() }, removeClasses: function () { const { $el: e, classNames: t } = this; e.removeClass(t.join(" ")), this.emitContainerClasses() } }; var Y = { init: !0, direction: "horizontal", touchEventsTarget: "wrapper", initialSlide: 0, speed: 300, cssMode: !1, updateOnWindowResize: !0, resizeObserver: !0, nested: !1, createElements: !1, enabled: !0, focusableElements: "input, select, option, textarea, button, video, label", width: null, height: null, preventInteractionOnTransition: !1, userAgent: null, url: null, edgeSwipeDetection: !1, edgeSwipeThreshold: 20, autoHeight: !1, setWrapperSize: !1, virtualTranslate: !1, effect: "slide", breakpoints: void 0, breakpointsBase: "window", spaceBetween: 0, slidesPerView: 1, slidesPerGroup: 1, slidesPerGroupSkip: 0, slidesPerGroupAuto: !1, centeredSlides: !1, centeredSlidesBounds: !1, slidesOffsetBefore: 0, slidesOffsetAfter: 0, normalizeSlideIndex: !0, centerInsufficientSlides: !1, watchOverflow: !0, roundLengths: !1, touchRatio: 1, touchAngle: 45, simulateTouch: !0, shortSwipes: !0, longSwipes: !0, longSwipesRatio: .5, longSwipesMs: 300, followFinger: !0, allowTouchMove: !0, threshold: 0, touchMoveStopPropagation: !1, touchStartPreventDefault: !0, touchStartForcePreventDefault: !1, touchReleaseOnEdges: !1, uniqueNavElements: !0, resistance: !0, resistanceRatio: .85, watchSlidesProgress: !1, grabCursor: !1, preventClicks: !0, preventClicksPropagation: !0, slideToClickedSlide: !1, preloadImages: !0, updateOnImagesReady: !0, loop: !1, loopAdditionalSlides: 0, loopedSlides: null, loopedSlidesLimit: !0, loopFillGroupWithBlank: !1, loopPreventsSlide: !0, rewind: !1, allowSlidePrev: !0, allowSlideNext: !0, swipeHandler: null, noSwiping: !0, noSwipingClass: "swiper-no-swiping", noSwipingSelector: null, passiveListeners: !0, maxBackfaceHiddenSlides: 10, containerModifierClass: "swiper-", slideClass: "swiper-slide", slideBlankClass: "swiper-slide-invisible-blank", slideActiveClass: "swiper-slide-active", slideDuplicateActiveClass: "swiper-slide-duplicate-active", slideVisibleClass: "swiper-slide-visible", slideDuplicateClass: "swiper-slide-duplicate", slideNextClass: "swiper-slide-next", slideDuplicateNextClass: "swiper-slide-duplicate-next", slidePrevClass: "swiper-slide-prev", slideDuplicatePrevClass: "swiper-slide-duplicate-prev", wrapperClass: "swiper-wrapper", runCallbacksOnInit: !0, _emitClasses: !1 }; function G(e, t) { return function (i = {}) { const n = Object.keys(i)[0], s = i[n]; "object" == typeof s && null !== s ? (["navigation", "pagination", "scrollbar"].indexOf(n) >= 0 && !0 === e[n] && (e[n] = { auto: !0 }), n in e && "enabled" in s ? (!0 === e[n] && (e[n] = { enabled: !0 }), "object" != typeof e[n] || "enabled" in e[n] || (e[n].enabled = !0), e[n] || (e[n] = { enabled: !1 }), y(t, i)) : y(t, i)) : y(t, i) } } const V = { eventsEmitter: M, update: P, translate: k, transition: { setTransition: function (e, t) { const i = this; i.params.cssMode || i.$wrapperEl.transition(e), i.emit("setTransition", e, t) }, transitionStart: function (e = !0, t) { const i = this, { params: n } = i; n.cssMode || (n.autoHeight && i.updateAutoHeight(), L({ swiper: i, runCallbacks: e, direction: t, step: "Start" })) }, transitionEnd: function (e = !0, t) { const i = this, { params: n } = i; i.animating = !1, n.cssMode || (i.setTransition(0), L({ swiper: i, runCallbacks: e, direction: t, step: "End" })) } }, slide: A, loop: z, grabCursor: { setGrabCursor: function (e) { const t = this; if (t.support.touch || !t.params.simulateTouch || t.params.watchOverflow && t.isLocked || t.params.cssMode) return; const i = "container" === t.params.touchEventsTarget ? t.el : t.wrapperEl; i.style.cursor = "move", i.style.cursor = e ? "grabbing" : "grab" }, unsetGrabCursor: function () { const e = this; e.support.touch || e.params.watchOverflow && e.isLocked || e.params.cssMode || (e["container" === e.params.touchEventsTarget ? "el" : "wrapperEl"].style.cursor = "") } }, events: q, breakpoints: W, checkOverflow: { checkOverflow: function () { const e = this, { isLocked: t, params: i } = e, { slidesOffsetBefore: n } = i; if (n) { const t = e.slides.length - 1, i = e.slidesGrid[t] + e.slidesSizesGrid[t] + 2 * n; e.isLocked = e.size > i } else e.isLocked = 1 === e.snapGrid.length; !0 === i.allowSlideNext && (e.allowSlideNext = !e.isLocked), !0 === i.allowSlidePrev && (e.allowSlidePrev = !e.isLocked), t && t !== e.isLocked && (e.isEnd = !1), t !== e.isLocked && e.emit(e.isLocked ? "lock" : "unlock") } }, classes: X, images: { loadImage: function (e, t, i, n, s, o) { const r = a(); let l; function c() { o && o() } p(e).parent("picture")[0] || e.complete && s ? c() : t ? (l = new r.Image, l.onload = c, l.onerror = c, n && (l.sizes = n), i && (l.srcset = i), t && (l.src = t)) : c() }, preloadImages: function () { const e = this; function t() { null != e && e && !e.destroyed && (void 0 !== e.imagesLoaded && (e.imagesLoaded += 1), e.imagesLoaded === e.imagesToLoad.length && (e.params.updateOnImagesReady && e.update(), e.emit("imagesReady"))) } e.imagesToLoad = e.$el.find("img"); for (let i = 0; i < e.imagesToLoad.length; i += 1) { const n = e.imagesToLoad[i]; e.loadImage(n, n.currentSrc || n.getAttribute("src"), n.srcset || n.getAttribute("srcset"), n.sizes || n.getAttribute("sizes"), !0, t) } } } }, U = {}; class Z { constructor(...e) { let t, i; if (1 === e.length && e[0].constructor && "Object" === Object.prototype.toString.call(e[0]).slice(8, -1) ? i = e[0] : [t, i] = e, i || (i = {}), i = y({}, i), t && !i.el && (i.el = t), i.el && p(i.el).length > 1) { const e = []; return p(i.el).each((t => { const n = y({}, i, { el: t }); e.push(new Z(n)) })), e } const n = this; n.__swiper__ = !0, n.support = T(), n.device = S({ userAgent: i.userAgent }), n.browser = $(), n.eventsListeners = {}, n.eventsAnyListeners = [], n.modules = [...n.__modules__], i.modules && Array.isArray(i.modules) && n.modules.push(...i.modules); const s = {}; n.modules.forEach((e => { e({ swiper: n, extendParams: G(i, s), on: n.on.bind(n), once: n.once.bind(n), off: n.off.bind(n), emit: n.emit.bind(n) }) })); const a = y({}, Y, s); return n.params = y({}, a, U, i), n.originalParams = y({}, n.params), n.passedParams = y({}, i), n.params && n.params.on && Object.keys(n.params.on).forEach((e => { n.on(e, n.params.on[e]) })), n.params && n.params.onAny && n.onAny(n.params.onAny), n.$ = p, Object.assign(n, { enabled: n.params.enabled, el: t, classNames: [], slides: p(), slidesGrid: [], snapGrid: [], slidesSizesGrid: [], isHorizontal() { return "horizontal" === n.params.direction }, isVertical() { return "vertical" === n.params.direction }, activeIndex: 0, realIndex: 0, isBeginning: !0, isEnd: !1, translate: 0, previousTranslate: 0, progress: 0, velocity: 0, animating: !1, allowSlideNext: n.params.allowSlideNext, allowSlidePrev: n.params.allowSlidePrev, touchEvents: function () { const e = ["touchstart", "touchmove", "touchend", "touchcancel"], t = ["pointerdown", "pointermove", "pointerup"]; return n.touchEventsTouch = { start: e[0], move: e[1], end: e[2], cancel: e[3] }, n.touchEventsDesktop = { start: t[0], move: t[1], end: t[2] }, n.support.touch || !n.params.simulateTouch ? n.touchEventsTouch : n.touchEventsDesktop }(), touchEventsData: { isTouched: void 0, isMoved: void 0, allowTouchCallbacks: void 0, touchStartTime: void 0, isScrolling: void 0, currentTranslate: void 0, startTranslate: void 0, allowThresholdMove: void 0, focusableElements: n.params.focusableElements, lastClickTime: m(), clickTimeout: void 0, velocities: [], allowMomentumBounce: void 0, isTouchEvent: void 0, startMoving: void 0 }, allowClick: !0, allowTouchMove: n.params.allowTouchMove, touches: { startX: 0, startY: 0, currentX: 0, currentY: 0, diff: 0 }, imagesToLoad: [], imagesLoaded: 0 }), n.emit("_swiper"), n.params.init && n.init(), n } enable() { const e = this; e.enabled || (e.enabled = !0, e.params.grabCursor && e.setGrabCursor(), e.emit("enable")) } disable() { const e = this; e.enabled && (e.enabled = !1, e.params.grabCursor && e.unsetGrabCursor(), e.emit("disable")) } setProgress(e, t) { const i = this; e = Math.min(Math.max(e, 0), 1); const n = i.minTranslate(), s = (i.maxTranslate() - n) * e + n; i.translateTo(s, void 0 === t ? 0 : t), i.updateActiveIndex(), i.updateSlidesClasses() } emitContainerClasses() { const e = this; if (!e.params._emitClasses || !e.el) return; const t = e.el.className.split(" ").filter((t => 0 === t.indexOf("swiper") || 0 === t.indexOf(e.params.containerModifierClass))); e.emit("_containerClasses", t.join(" ")) } getSlideClasses(e) { const t = this; return t.destroyed ? "" : e.className.split(" ").filter((e => 0 === e.indexOf("swiper-slide") || 0 === e.indexOf(t.params.slideClass))).join(" ") } emitSlidesClasses() { const e = this; if (!e.params._emitClasses || !e.el) return; const t = []; e.slides.each((i => { const n = e.getSlideClasses(i); t.push({ slideEl: i, classNames: n }), e.emit("_slideClass", i, n) })), e.emit("_slideClasses", t) } slidesPerViewDynamic(e = "current", t = !1) { const { params: i, slides: n, slidesGrid: s, slidesSizesGrid: a, size: o, activeIndex: r } = this; let l = 1; if (i.centeredSlides) { let e, t = n[r].swiperSlideSize; for (let i = r + 1; i < n.length; i += 1)n[i] && !e && (t += n[i].swiperSlideSize, l += 1, t > o && (e = !0)); for (let i = r - 1; i >= 0; i -= 1)n[i] && !e && (t += n[i].swiperSlideSize, l += 1, t > o && (e = !0)) } else if ("current" === e) for (let e = r + 1; e < n.length; e += 1) { (t ? s[e] + a[e] - s[r] < o : s[e] - s[r] < o) && (l += 1) } else for (let e = r - 1; e >= 0; e -= 1) { s[r] - s[e] < o && (l += 1) } return l } update() { const e = this; if (!e || e.destroyed) return; const { snapGrid: t, params: i } = e; function n() { const t = e.rtlTranslate ? -1 * e.translate : e.translate, i = Math.min(Math.max(t, e.maxTranslate()), e.minTranslate()); e.setTranslate(i), e.updateActiveIndex(), e.updateSlidesClasses() } let s; i.breakpoints && e.setBreakpoint(), e.updateSize(), e.updateSlides(), e.updateProgress(), e.updateSlidesClasses(), e.params.freeMode && e.params.freeMode.enabled ? (n(), e.params.autoHeight && e.updateAutoHeight()) : (s = ("auto" === e.params.slidesPerView || e.params.slidesPerView > 1) && e.isEnd && !e.params.centeredSlides ? e.slideTo(e.slides.length - 1, 0, !1, !0) : e.slideTo(e.activeIndex, 0, !1, !0), s || n()), i.watchOverflow && t !== e.snapGrid && e.checkOverflow(), e.emit("update") } changeDirection(e, t = !0) { const i = this, n = i.params.direction; return e || (e = "horizontal" === n ? "vertical" : "horizontal"), e === n || "horizontal" !== e && "vertical" !== e || (i.$el.removeClass(`${i.params.containerModifierClass}${n}`).addClass(`${i.params.containerModifierClass}${e}`), i.emitContainerClasses(), i.params.direction = e, i.slides.each((t => { "vertical" === e ? t.style.width = "" : t.style.height = "" })), i.emit("changeDirection"), t && i.update()), i } changeLanguageDirection(e) { const t = this; t.rtl && "rtl" === e || !t.rtl && "ltr" === e || (t.rtl = "rtl" === e, t.rtlTranslate = "horizontal" === t.params.direction && t.rtl, t.rtl ? (t.$el.addClass(`${t.params.containerModifierClass}rtl`), t.el.dir = "rtl") : (t.$el.removeClass(`${t.params.containerModifierClass}rtl`), t.el.dir = "ltr"), t.update()) } mount(e) { const t = this; if (t.mounted) return !0; const i = p(e || t.params.el); if (!(e = i[0])) return !1; e.swiper = t; const s = () => `.${(t.params.wrapperClass || "").trim().split(" ").join(".")}`; let a = (() => { if (e && e.shadowRoot && e.shadowRoot.querySelector) { const t = p(e.shadowRoot.querySelector(s())); return t.children = e => i.children(e), t } return i.children ? i.children(s()) : p(i).children(s()) })(); if (0 === a.length && t.params.createElements) { const e = n().createElement("div"); a = p(e), e.className = t.params.wrapperClass, i.append(e), i.children(`.${t.params.slideClass}`).each((e => { a.append(e) })) } return Object.assign(t, { $el: i, el: e, $wrapperEl: a, wrapperEl: a[0], mounted: !0, rtl: "rtl" === e.dir.toLowerCase() || "rtl" === i.css("direction"), rtlTranslate: "horizontal" === t.params.direction && ("rtl" === e.dir.toLowerCase() || "rtl" === i.css("direction")), wrongRTL: "-webkit-box" === a.css("display") }), !0 } init(e) { const t = this; if (t.initialized) return t; return !1 === t.mount(e) || (t.emit("beforeInit"), t.params.breakpoints && t.setBreakpoint(), t.addClasses(), t.params.loop && t.loopCreate(), t.updateSize(), t.updateSlides(), t.params.watchOverflow && t.checkOverflow(), t.params.grabCursor && t.enabled && t.setGrabCursor(), t.params.preloadImages && t.preloadImages(), t.params.loop ? t.slideTo(t.params.initialSlide + t.loopedSlides, 0, t.params.runCallbacksOnInit, !1, !0) : t.slideTo(t.params.initialSlide, 0, t.params.runCallbacksOnInit, !1, !0), t.attachEvents(), t.initialized = !0, t.emit("init"), t.emit("afterInit")), t } destroy(e = !0, t = !0) { const i = this, { params: n, $el: s, $wrapperEl: a, slides: o } = i; return void 0 === i.params || i.destroyed || (i.emit("beforeDestroy"), i.initialized = !1, i.detachEvents(), n.loop && i.loopDestroy(), t && (i.removeClasses(), s.removeAttr("style"), a.removeAttr("style"), o && o.length && o.removeClass([n.slideVisibleClass, n.slideActiveClass, n.slideNextClass, n.slidePrevClass].join(" ")).removeAttr("style").removeAttr("data-swiper-slide-index")), i.emit("destroy"), Object.keys(i.eventsListeners).forEach((e => { i.off(e) })), !1 !== e && (i.$el[0].swiper = null, function (e) { const t = e; Object.keys(t).forEach((e => { try { t[e] = null } catch (e) { } try { delete t[e] } catch (e) { } })) }(i)), i.destroyed = !0), null } static extendDefaults(e) { y(U, e) } static get extendedDefaults() { return U } static get defaults() { return Y } static installModule(e) { Z.prototype.__modules__ || (Z.prototype.__modules__ = []); const t = Z.prototype.__modules__; "function" == typeof e && t.indexOf(e) < 0 && t.push(e) } static use(e) { return Array.isArray(e) ? (e.forEach((e => Z.installModule(e))), Z) : (Z.installModule(e), Z) } } Object.keys(V).forEach((e => { Object.keys(V[e]).forEach((t => { Z.prototype[t] = V[e][t] })) })), Z.use([function ({ swiper: e, on: t, emit: i }) { const n = a(); let s = null, o = null; const r = () => { e && !e.destroyed && e.initialized && (i("beforeResize"), i("resize")) }, l = () => { e && !e.destroyed && e.initialized && i("orientationchange") }; t("init", (() => { e.params.resizeObserver && void 0 !== n.ResizeObserver ? e && !e.destroyed && e.initialized && (s = new ResizeObserver((t => { o = n.requestAnimationFrame((() => { const { width: i, height: n } = e; let s = i, a = n; t.forEach((({ contentBoxSize: t, contentRect: i, target: n }) => { n && n !== e.el || (s = i ? i.width : (t[0] || t).inlineSize, a = i ? i.height : (t[0] || t).blockSize) })), s === i && a === n || r() })) })), s.observe(e.el)) : (n.addEventListener("resize", r), n.addEventListener("orientationchange", l)) })), t("destroy", (() => { o && n.cancelAnimationFrame(o), s && s.unobserve && e.el && (s.unobserve(e.el), s = null), n.removeEventListener("resize", r), n.removeEventListener("orientationchange", l) })) }, function ({ swiper: e, extendParams: t, on: i, emit: n }) { const s = [], o = a(), r = (e, t = {}) => { const i = new (o.MutationObserver || o.WebkitMutationObserver)((e => { if (1 === e.length) return void n("observerUpdate", e[0]); const t = function () { n("observerUpdate", e[0]) }; o.requestAnimationFrame ? o.requestAnimationFrame(t) : o.setTimeout(t, 0) })); i.observe(e, { attributes: void 0 === t.attributes || t.attributes, childList: void 0 === t.childList || t.childList, characterData: void 0 === t.characterData || t.characterData }), s.push(i) }; t({ observer: !1, observeParents: !1, observeSlideChildren: !1 }), i("init", (() => { if (e.params.observer) { if (e.params.observeParents) { const t = e.$el.parents(); for (let e = 0; e < t.length; e += 1)r(t[e]) } r(e.$el[0], { childList: e.params.observeSlideChildren }), r(e.$wrapperEl[0], { attributes: !1 }) } })), i("destroy", (() => { s.forEach((e => { e.disconnect() })), s.splice(0, s.length) })) }]); var K = Z; function J(e, t, i, s) { const a = n(); return e.params.createElements && Object.keys(s).forEach((n => { if (!i[n] && !0 === i.auto) { let o = e.$el.children(`.${s[n]}`)[0]; o || (o = a.createElement("div"), o.className = s[n], e.$el.append(o)), i[n] = o, t[n] = o } })), i } function Q(e = "") { return `.${e.trim().replace(/([\.:!\/])/g, "\\$1").replace(/ /g, ".")}` } function ee(e) { const t = this, { $wrapperEl: i, params: n } = t; if (n.loop && t.loopDestroy(), "object" == typeof e && "length" in e) for (let t = 0; t < e.length; t += 1)e[t] && i.append(e[t]); else i.append(e); n.loop && t.loopCreate(), n.observer || t.update() } function te(e) { const t = this, { params: i, $wrapperEl: n, activeIndex: s } = t; i.loop && t.loopDestroy(); let a = s + 1; if ("object" == typeof e && "length" in e) { for (let t = 0; t < e.length; t += 1)e[t] && n.prepend(e[t]); a = s + e.length } else n.prepend(e); i.loop && t.loopCreate(), i.observer || t.update(), t.slideTo(a, 0, !1) } function ie(e, t) { const i = this, { $wrapperEl: n, params: s, activeIndex: a } = i; let o = a; s.loop && (o -= i.loopedSlides, i.loopDestroy(), i.slides = n.children(`.${s.slideClass}`)); const r = i.slides.length; if (e <= 0) return void i.prependSlide(t); if (e >= r) return void i.appendSlide(t); let l = o > e ? o + 1 : o; const c = []; for (let t = r - 1; t >= e; t -= 1) { const e = i.slides.eq(t); e.remove(), c.unshift(e) } if ("object" == typeof t && "length" in t) { for (let e = 0; e < t.length; e += 1)t[e] && n.append(t[e]); l = o > e ? o + t.length : o } else n.append(t); for (let e = 0; e < c.length; e += 1)n.append(c[e]); s.loop && i.loopCreate(), s.observer || i.update(), s.loop ? i.slideTo(l + i.loopedSlides, 0, !1) : i.slideTo(l, 0, !1) } function ne(e) { const t = this, { params: i, $wrapperEl: n, activeIndex: s } = t; let a = s; i.loop && (a -= t.loopedSlides, t.loopDestroy(), t.slides = n.children(`.${i.slideClass}`)); let o, r = a; if ("object" == typeof e && "length" in e) { for (let i = 0; i < e.length; i += 1)o = e[i], t.slides[o] && t.slides.eq(o).remove(), o < r && (r -= 1); r = Math.max(r, 0) } else o = e, t.slides[o] && t.slides.eq(o).remove(), o < r && (r -= 1), r = Math.max(r, 0); i.loop && t.loopCreate(), i.observer || t.update(), i.loop ? t.slideTo(r + t.loopedSlides, 0, !1) : t.slideTo(r, 0, !1) } function se() { const e = this, t = []; for (let i = 0; i < e.slides.length; i += 1)t.push(i); e.removeSlide(t) } function ae(e) { const { effect: t, swiper: i, on: n, setTranslate: s, setTransition: a, overwriteParams: o, perspective: r, recreateShadows: l, getEffectParams: c } = e; let d; n("beforeInit", (() => { if (i.params.effect !== t) return; i.classNames.push(`${i.params.containerModifierClass}${t}`), r && r() && i.classNames.push(`${i.params.containerModifierClass}3d`); const e = o ? o() : {}; Object.assign(i.params, e), Object.assign(i.originalParams, e) })), n("setTranslate", (() => { i.params.effect === t && s() })), n("setTransition", ((e, n) => { i.params.effect === t && a(n) })), n("transitionEnd", (() => { if (i.params.effect === t && l) { if (!c || !c().slideShadows) return; i.slides.each((e => { i.$(e).find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").remove() })), l() } })), n("virtualUpdate", (() => { i.params.effect === t && (i.slides.length || (d = !0), requestAnimationFrame((() => { d && i.slides && i.slides.length && (s(), d = !1) }))) })) } function oe(e, t) { return e.transformEl ? t.find(e.transformEl).css({ "backface-visibility": "hidden", "-webkit-backface-visibility": "hidden" }) : t } function re({ swiper: e, duration: t, transformEl: i, allSlides: n }) { const { slides: s, activeIndex: a, $wrapperEl: o } = e; if (e.params.virtualTranslate && 0 !== t) { let t, r = !1; t = n ? i ? s.find(i) : s : i ? s.eq(a).find(i) : s.eq(a), t.transitionEnd((() => { if (r) return; if (!e || e.destroyed) return; r = !0, e.animating = !1; const t = ["webkitTransitionEnd", "transitionend"]; for (let e = 0; e < t.length; e += 1)o.trigger(t[e]) })) } } function le(e, t, i) { const n = "swiper-slide-shadow" + (i ? `-${i}` : ""), s = e.transformEl ? t.find(e.transformEl) : t; let a = s.children(`.${n}`); return a.length || (a = p(`<div class="swiper-slide-shadow${i ? `-${i}` : ""}"></div>`), s.append(a)), a } const ce = [function ({ swiper: e, extendParams: t, on: i, emit: n }) { let s; function a(t, i) { const n = e.params.virtual; if (n.cache && e.virtual.cache[i]) return e.virtual.cache[i]; const s = n.renderSlide ? p(n.renderSlide.call(e, t, i)) : p(`<div class="${e.params.slideClass}" data-swiper-slide-index="${i}">${t}</div>`); return s.attr("data-swiper-slide-index") || s.attr("data-swiper-slide-index", i), n.cache && (e.virtual.cache[i] = s), s } function o(t) { const { slidesPerView: i, slidesPerGroup: s, centeredSlides: o } = e.params, { addSlidesBefore: r, addSlidesAfter: l } = e.params.virtual, { from: c, to: d, slides: h, slidesGrid: u, offset: p } = e.virtual; e.params.cssMode || e.updateActiveIndex(); const f = e.activeIndex || 0; let m, g, v; m = e.rtlTranslate ? "right" : e.isHorizontal() ? "left" : "top", o ? (g = Math.floor(i / 2) + s + l, v = Math.floor(i / 2) + s + r) : (g = i + (s - 1) + l, v = s + r); const y = Math.max((f || 0) - v, 0), b = Math.min((f || 0) + g, h.length - 1), x = (e.slidesGrid[y] || 0) - (e.slidesGrid[0] || 0); function w() { e.updateSlides(), e.updateProgress(), e.updateSlidesClasses(), e.lazy && e.params.lazy.enabled && e.lazy.load(), n("virtualUpdate") } if (Object.assign(e.virtual, { from: y, to: b, offset: x, slidesGrid: e.slidesGrid }), c === y && d === b && !t) return e.slidesGrid !== u && x !== p && e.slides.css(m, `${x}px`), e.updateProgress(), void n("virtualUpdate"); if (e.params.virtual.renderExternal) return e.params.virtual.renderExternal.call(e, { offset: x, from: y, to: b, slides: function () { const e = []; for (let t = y; t <= b; t += 1)e.push(h[t]); return e }() }), void (e.params.virtual.renderExternalUpdate ? w() : n("virtualUpdate")); const C = [], E = []; if (t) e.$wrapperEl.find(`.${e.params.slideClass}`).remove(); else for (let t = c; t <= d; t += 1)(t < y || t > b) && e.$wrapperEl.find(`.${e.params.slideClass}[data-swiper-slide-index="${t}"]`).remove(); for (let e = 0; e < h.length; e += 1)e >= y && e <= b && (void 0 === d || t ? E.push(e) : (e > d && E.push(e), e < c && C.push(e))); E.forEach((t => { e.$wrapperEl.append(a(h[t], t)) })), C.sort(((e, t) => t - e)).forEach((t => { e.$wrapperEl.prepend(a(h[t], t)) })), e.$wrapperEl.children(".swiper-slide").css(m, `${x}px`), w() } t({ virtual: { enabled: !1, slides: [], cache: !0, renderSlide: null, renderExternal: null, renderExternalUpdate: !0, addSlidesBefore: 0, addSlidesAfter: 0 } }), e.virtual = { cache: {}, from: void 0, to: void 0, slides: [], offset: 0, slidesGrid: [] }, i("beforeInit", (() => { e.params.virtual.enabled && (e.virtual.slides = e.params.virtual.slides, e.classNames.push(`${e.params.containerModifierClass}virtual`), e.params.watchSlidesProgress = !0, e.originalParams.watchSlidesProgress = !0, e.params.initialSlide || o()) })), i("setTranslate", (() => { e.params.virtual.enabled && (e.params.cssMode && !e._immediateVirtual ? (clearTimeout(s), s = setTimeout((() => { o() }), 100)) : o()) })), i("init update resize", (() => { e.params.virtual.enabled && e.params.cssMode && b(e.wrapperEl, "--swiper-virtual-size", `${e.virtualSize}px`) })), Object.assign(e.virtual, { appendSlide: function (t) { if ("object" == typeof t && "length" in t) for (let i = 0; i < t.length; i += 1)t[i] && e.virtual.slides.push(t[i]); else e.virtual.slides.push(t); o(!0) }, prependSlide: function (t) { const i = e.activeIndex; let n = i + 1, s = 1; if (Array.isArray(t)) { for (let i = 0; i < t.length; i += 1)t[i] && e.virtual.slides.unshift(t[i]); n = i + t.length, s = t.length } else e.virtual.slides.unshift(t); if (e.params.virtual.cache) { const t = e.virtual.cache, i = {}; Object.keys(t).forEach((e => { const n = t[e], a = n.attr("data-swiper-slide-index"); a && n.attr("data-swiper-slide-index", parseInt(a, 10) + s), i[parseInt(e, 10) + s] = n })), e.virtual.cache = i } o(!0), e.slideTo(n, 0) }, removeSlide: function (t) { if (null == t) return; let i = e.activeIndex; if (Array.isArray(t)) for (let n = t.length - 1; n >= 0; n -= 1)e.virtual.slides.splice(t[n], 1), e.params.virtual.cache && delete e.virtual.cache[t[n]], t[n] < i && (i -= 1), i = Math.max(i, 0); else e.virtual.slides.splice(t, 1), e.params.virtual.cache && delete e.virtual.cache[t], t < i && (i -= 1), i = Math.max(i, 0); o(!0), e.slideTo(i, 0) }, removeAllSlides: function () { e.virtual.slides = [], e.params.virtual.cache && (e.virtual.cache = {}), o(!0), e.slideTo(0, 0) }, update: o }) }, function ({ swiper: e, extendParams: t, on: i, emit: s }) { const o = n(), r = a(); function l(t) { if (!e.enabled) return; const { rtlTranslate: i } = e; let n = t; n.originalEvent && (n = n.originalEvent); const a = n.keyCode || n.charCode, l = e.params.keyboard.pageUpDown, c = l && 33 === a, d = l && 34 === a, h = 37 === a, u = 39 === a, p = 38 === a, f = 40 === a; if (!e.allowSlideNext && (e.isHorizontal() && u || e.isVertical() && f || d)) return !1; if (!e.allowSlidePrev && (e.isHorizontal() && h || e.isVertical() && p || c)) return !1; if (!(n.shiftKey || n.altKey || n.ctrlKey || n.metaKey || o.activeElement && o.activeElement.nodeName && ("input" === o.activeElement.nodeName.toLowerCase() || "textarea" === o.activeElement.nodeName.toLowerCase()))) { if (e.params.keyboard.onlyInViewport && (c || d || h || u || p || f)) { let t = !1; if (e.$el.parents(`.${e.params.slideClass}`).length > 0 && 0 === e.$el.parents(`.${e.params.slideActiveClass}`).length) return; const n = e.$el, s = n[0].clientWidth, a = n[0].clientHeight, o = r.innerWidth, l = r.innerHeight, c = e.$el.offset(); i && (c.left -= e.$el[0].scrollLeft); const d = [[c.left, c.top], [c.left + s, c.top], [c.left, c.top + a], [c.left + s, c.top + a]]; for (let e = 0; e < d.length; e += 1) { const i = d[e]; if (i[0] >= 0 && i[0] <= o && i[1] >= 0 && i[1] <= l) { if (0 === i[0] && 0 === i[1]) continue; t = !0 } } if (!t) return } e.isHorizontal() ? ((c || d || h || u) && (n.preventDefault ? n.preventDefault() : n.returnValue = !1), ((d || u) && !i || (c || h) && i) && e.slideNext(), ((c || h) && !i || (d || u) && i) && e.slidePrev()) : ((c || d || p || f) && (n.preventDefault ? n.preventDefault() : n.returnValue = !1), (d || f) && e.slideNext(), (c || p) && e.slidePrev()), s("keyPress", a) } } function c() { e.keyboard.enabled || (p(o).on("keydown", l), e.keyboard.enabled = !0) } function d() { e.keyboard.enabled && (p(o).off("keydown", l), e.keyboard.enabled = !1) } e.keyboard = { enabled: !1 }, t({ keyboard: { enabled: !1, onlyInViewport: !0, pageUpDown: !0 } }), i("init", (() => { e.params.keyboard.enabled && c() })), i("destroy", (() => { e.keyboard.enabled && d() })), Object.assign(e.keyboard, { enable: c, disable: d }) }, function ({ swiper: e, extendParams: t, on: i, emit: n }) { const s = a(); let o; t({ mousewheel: { enabled: !1, releaseOnEdges: !1, invert: !1, forceToAxis: !1, sensitivity: 1, eventsTarget: "container", thresholdDelta: null, thresholdTime: null } }), e.mousewheel = { enabled: !1 }; let r, l = m(); const c = []; function d() { e.enabled && (e.mouseEntered = !0) } function h() { e.enabled && (e.mouseEntered = !1) } function u(t) { return !(e.params.mousewheel.thresholdDelta && t.delta < e.params.mousewheel.thresholdDelta) && (!(e.params.mousewheel.thresholdTime && m() - l < e.params.mousewheel.thresholdTime) && (t.delta >= 6 && m() - l < 60 || (t.direction < 0 ? e.isEnd && !e.params.loop || e.animating || (e.slideNext(), n("scroll", t.raw)) : e.isBeginning && !e.params.loop || e.animating || (e.slidePrev(), n("scroll", t.raw)), l = (new s.Date).getTime(), !1))) } function g(t) { let i = t, s = !0; if (!e.enabled) return; const a = e.params.mousewheel; e.params.cssMode && i.preventDefault(); let l = e.$el; if ("container" !== e.params.mousewheel.eventsTarget && (l = p(e.params.mousewheel.eventsTarget)), !e.mouseEntered && !l[0].contains(i.target) && !a.releaseOnEdges) return !0; i.originalEvent && (i = i.originalEvent); let d = 0; const h = e.rtlTranslate ? -1 : 1, g = function (e) { let t = 0, i = 0, n = 0, s = 0; return "detail" in e && (i = e.detail), "wheelDelta" in e && (i = -e.wheelDelta / 120), "wheelDeltaY" in e && (i = -e.wheelDeltaY / 120), "wheelDeltaX" in e && (t = -e.wheelDeltaX / 120), "axis" in e && e.axis === e.HORIZONTAL_AXIS && (t = i, i = 0), n = 10 * t, s = 10 * i, "deltaY" in e && (s = e.deltaY), "deltaX" in e && (n = e.deltaX), e.shiftKey && !n && (n = s, s = 0), (n || s) && e.deltaMode && (1 === e.deltaMode ? (n *= 40, s *= 40) : (n *= 800, s *= 800)), n && !t && (t = n < 1 ? -1 : 1), s && !i && (i = s < 1 ? -1 : 1), { spinX: t, spinY: i, pixelX: n, pixelY: s } }(i); if (a.forceToAxis) if (e.isHorizontal()) { if (!(Math.abs(g.pixelX) > Math.abs(g.pixelY))) return !0; d = -g.pixelX * h } else { if (!(Math.abs(g.pixelY) > Math.abs(g.pixelX))) return !0; d = -g.pixelY } else d = Math.abs(g.pixelX) > Math.abs(g.pixelY) ? -g.pixelX * h : -g.pixelY; if (0 === d) return !0; a.invert && (d = -d); let v = e.getTranslate() + d * a.sensitivity; if (v >= e.minTranslate() && (v = e.minTranslate()), v <= e.maxTranslate() && (v = e.maxTranslate()), s = !!e.params.loop || !(v === e.minTranslate() || v === e.maxTranslate()), s && e.params.nested && i.stopPropagation(), e.params.freeMode && e.params.freeMode.enabled) { const t = { time: m(), delta: Math.abs(d), direction: Math.sign(d) }, s = r && t.time < r.time + 500 && t.delta <= r.delta && t.direction === r.direction; if (!s) { r = void 0, e.params.loop && e.loopFix(); let l = e.getTranslate() + d * a.sensitivity; const h = e.isBeginning, u = e.isEnd; if (l >= e.minTranslate() && (l = e.minTranslate()), l <= e.maxTranslate() && (l = e.maxTranslate()), e.setTransition(0), e.setTranslate(l), e.updateProgress(), e.updateActiveIndex(), e.updateSlidesClasses(), (!h && e.isBeginning || !u && e.isEnd) && e.updateSlidesClasses(), e.params.freeMode.sticky) { clearTimeout(o), o = void 0, c.length >= 15 && c.shift(); const i = c.length ? c[c.length - 1] : void 0, n = c[0]; if (c.push(t), i && (t.delta > i.delta || t.direction !== i.direction)) c.splice(0); else if (c.length >= 15 && t.time - n.time < 500 && n.delta - t.delta >= 1 && t.delta <= 6) { const i = d > 0 ? .8 : .2; r = t, c.splice(0), o = f((() => { e.slideToClosest(e.params.speed, !0, void 0, i) }), 0) } o || (o = f((() => { r = t, c.splice(0), e.slideToClosest(e.params.speed, !0, void 0, .5) }), 500)) } if (s || n("scroll", i), e.params.autoplay && e.params.autoplayDisableOnInteraction && e.autoplay.stop(), l === e.minTranslate() || l === e.maxTranslate()) return !0 } } else { const i = { time: m(), delta: Math.abs(d), direction: Math.sign(d), raw: t }; c.length >= 2 && c.shift(); const n = c.length ? c[c.length - 1] : void 0; if (c.push(i), n ? (i.direction !== n.direction || i.delta > n.delta || i.time > n.time + 150) && u(i) : u(i), function (t) { const i = e.params.mousewheel; if (t.direction < 0) { if (e.isEnd && !e.params.loop && i.releaseOnEdges) return !0 } else if (e.isBeginning && !e.params.loop && i.releaseOnEdges) return !0; return !1 }(i)) return !0 } return i.preventDefault ? i.preventDefault() : i.returnValue = !1, !1 } function v(t) { let i = e.$el; "container" !== e.params.mousewheel.eventsTarget && (i = p(e.params.mousewheel.eventsTarget)), i[t]("mouseenter", d), i[t]("mouseleave", h), i[t]("wheel", g) } function y() { return e.params.cssMode ? (e.wrapperEl.removeEventListener("wheel", g), !0) : !e.mousewheel.enabled && (v("on"), e.mousewheel.enabled = !0, !0) } function b() { return e.params.cssMode ? (e.wrapperEl.addEventListener(event, g), !0) : !!e.mousewheel.enabled && (v("off"), e.mousewheel.enabled = !1, !0) } i("init", (() => { !e.params.mousewheel.enabled && e.params.cssMode && b(), e.params.mousewheel.enabled && y() })), i("destroy", (() => { e.params.cssMode && y(), e.mousewheel.enabled && b() })), Object.assign(e.mousewheel, { enable: y, disable: b }) }, function ({ swiper: e, extendParams: t, on: i, emit: n }) { function s(t) { let i; return t && (i = p(t), e.params.uniqueNavElements && "string" == typeof t && i.length > 1 && 1 === e.$el.find(t).length && (i = e.$el.find(t))), i } function a(t, i) { const n = e.params.navigation; t && t.length > 0 && (t[i ? "addClass" : "removeClass"](n.disabledClass), t[0] && "BUTTON" === t[0].tagName && (t[0].disabled = i), e.params.watchOverflow && e.enabled && t[e.isLocked ? "addClass" : "removeClass"](n.lockClass)) } function o() { if (e.params.loop) return; const { $nextEl: t, $prevEl: i } = e.navigation; a(i, e.isBeginning && !e.params.rewind), a(t, e.isEnd && !e.params.rewind) } function r(t) { t.preventDefault(), (!e.isBeginning || e.params.loop || e.params.rewind) && (e.slidePrev(), n("navigationPrev")) } function l(t) { t.preventDefault(), (!e.isEnd || e.params.loop || e.params.rewind) && (e.slideNext(), n("navigationNext")) } function c() { const t = e.params.navigation; if (e.params.navigation = J(e, e.originalParams.navigation, e.params.navigation, { nextEl: "swiper-button-next", prevEl: "swiper-button-prev" }), !t.nextEl && !t.prevEl) return; const i = s(t.nextEl), n = s(t.prevEl); i && i.length > 0 && i.on("click", l), n && n.length > 0 && n.on("click", r), Object.assign(e.navigation, { $nextEl: i, nextEl: i && i[0], $prevEl: n, prevEl: n && n[0] }), e.enabled || (i && i.addClass(t.lockClass), n && n.addClass(t.lockClass)) } function d() { const { $nextEl: t, $prevEl: i } = e.navigation; t && t.length && (t.off("click", l), t.removeClass(e.params.navigation.disabledClass)), i && i.length && (i.off("click", r), i.removeClass(e.params.navigation.disabledClass)) } t({ navigation: { nextEl: null, prevEl: null, hideOnClick: !1, disabledClass: "swiper-button-disabled", hiddenClass: "swiper-button-hidden", lockClass: "swiper-button-lock", navigationDisabledClass: "swiper-navigation-disabled" } }), e.navigation = { nextEl: null, $nextEl: null, prevEl: null, $prevEl: null }, i("init", (() => { !1 === e.params.navigation.enabled ? h() : (c(), o()) })), i("toEdge fromEdge lock unlock", (() => { o() })), i("destroy", (() => { d() })), i("enable disable", (() => { const { $nextEl: t, $prevEl: i } = e.navigation; t && t[e.enabled ? "removeClass" : "addClass"](e.params.navigation.lockClass), i && i[e.enabled ? "removeClass" : "addClass"](e.params.navigation.lockClass) })), i("click", ((t, i) => { const { $nextEl: s, $prevEl: a } = e.navigation, o = i.target; if (e.params.navigation.hideOnClick && !p(o).is(a) && !p(o).is(s)) { if (e.pagination && e.params.pagination && e.params.pagination.clickable && (e.pagination.el === o || e.pagination.el.contains(o))) return; let t; s ? t = s.hasClass(e.params.navigation.hiddenClass) : a && (t = a.hasClass(e.params.navigation.hiddenClass)), n(!0 === t ? "navigationShow" : "navigationHide"), s && s.toggleClass(e.params.navigation.hiddenClass), a && a.toggleClass(e.params.navigation.hiddenClass) } })); const h = () => { e.$el.addClass(e.params.navigation.navigationDisabledClass), d() }; Object.assign(e.navigation, { enable: () => { e.$el.removeClass(e.params.navigation.navigationDisabledClass), c(), o() }, disable: h, update: o, init: c, destroy: d }) }, function ({ swiper: e, extendParams: t, on: i, emit: n }) { const s = "swiper-pagination"; let a; t({ pagination: { el: null, bulletElement: "span", clickable: !1, hideOnClick: !1, renderBullet: null, renderProgressbar: null, renderFraction: null, renderCustom: null, progressbarOpposite: !1, type: "bullets", dynamicBullets: !1, dynamicMainBullets: 1, formatFractionCurrent: e => e, formatFractionTotal: e => e, bulletClass: `${s}-bullet`, bulletActiveClass: `${s}-bullet-active`, modifierClass: `${s}-`, currentClass: `${s}-current`, totalClass: `${s}-total`, hiddenClass: `${s}-hidden`, progressbarFillClass: `${s}-progressbar-fill`, progressbarOppositeClass: `${s}-progressbar-opposite`, clickableClass: `${s}-clickable`, lockClass: `${s}-lock`, horizontalClass: `${s}-horizontal`, verticalClass: `${s}-vertical`, paginationDisabledClass: `${s}-disabled` } }), e.pagination = { el: null, $el: null, bullets: [] }; let o = 0; function r() { return !e.params.pagination.el || !e.pagination.el || !e.pagination.$el || 0 === e.pagination.$el.length } function l(t, i) { const { bulletActiveClass: n } = e.params.pagination; t[i]().addClass(`${n}-${i}`)[i]().addClass(`${n}-${i}-${i}`) } function c() { const t = e.rtl, i = e.params.pagination; if (r()) return; const s = e.virtual && e.params.virtual.enabled ? e.virtual.slides.length : e.slides.length, c = e.pagination.$el; let d; const h = e.params.loop ? Math.ceil((s - 2 * e.loopedSlides) / e.params.slidesPerGroup) : e.snapGrid.length; if (e.params.loop ? (d = Math.ceil((e.activeIndex - e.loopedSlides) / e.params.slidesPerGroup), d > s - 1 - 2 * e.loopedSlides && (d -= s - 2 * e.loopedSlides), d > h - 1 && (d -= h), d < 0 && "bullets" !== e.params.paginationType && (d = h + d)) : d = void 0 !== e.snapIndex ? e.snapIndex : e.activeIndex || 0, "bullets" === i.type && e.pagination.bullets && e.pagination.bullets.length > 0) { const n = e.pagination.bullets; let s, r, h; if (i.dynamicBullets && (a = n.eq(0)[e.isHorizontal() ? "outerWidth" : "outerHeight"](!0), c.css(e.isHorizontal() ? "width" : "height", a * (i.dynamicMainBullets + 4) + "px"), i.dynamicMainBullets > 1 && void 0 !== e.previousIndex && (o += d - (e.previousIndex - e.loopedSlides || 0), o > i.dynamicMainBullets - 1 ? o = i.dynamicMainBullets - 1 : o < 0 && (o = 0)), s = Math.max(d - o, 0), r = s + (Math.min(n.length, i.dynamicMainBullets) - 1), h = (r + s) / 2), n.removeClass(["", "-next", "-next-next", "-prev", "-prev-prev", "-main"].map((e => `${i.bulletActiveClass}${e}`)).join(" ")), c.length > 1) n.each((e => { const t = p(e), n = t.index(); n === d && t.addClass(i.bulletActiveClass), i.dynamicBullets && (n >= s && n <= r && t.addClass(`${i.bulletActiveClass}-main`), n === s && l(t, "prev"), n === r && l(t, "next")) })); else { const t = n.eq(d), a = t.index(); if (t.addClass(i.bulletActiveClass), i.dynamicBullets) { const t = n.eq(s), o = n.eq(r); for (let e = s; e <= r; e += 1)n.eq(e).addClass(`${i.bulletActiveClass}-main`); if (e.params.loop) if (a >= n.length) { for (let e = i.dynamicMainBullets; e >= 0; e -= 1)n.eq(n.length - e).addClass(`${i.bulletActiveClass}-main`); n.eq(n.length - i.dynamicMainBullets - 1).addClass(`${i.bulletActiveClass}-prev`) } else l(t, "prev"), l(o, "next"); else l(t, "prev"), l(o, "next") } } if (i.dynamicBullets) { const s = Math.min(n.length, i.dynamicMainBullets + 4), o = (a * s - a) / 2 - h * a, r = t ? "right" : "left"; n.css(e.isHorizontal() ? r : "top", `${o}px`) } } if ("fraction" === i.type && (c.find(Q(i.currentClass)).text(i.formatFractionCurrent(d + 1)), c.find(Q(i.totalClass)).text(i.formatFractionTotal(h))), "progressbar" === i.type) { let t; t = i.progressbarOpposite ? e.isHorizontal() ? "vertical" : "horizontal" : e.isHorizontal() ? "horizontal" : "vertical"; const n = (d + 1) / h; let s = 1, a = 1; "horizontal" === t ? s = n : a = n, c.find(Q(i.progressbarFillClass)).transform(`translate3d(0,0,0) scaleX(${s}) scaleY(${a})`).transition(e.params.speed) } "custom" === i.type && i.renderCustom ? (c.html(i.renderCustom(e, d + 1, h)), n("paginationRender", c[0])) : n("paginationUpdate", c[0]), e.params.watchOverflow && e.enabled && c[e.isLocked ? "addClass" : "removeClass"](i.lockClass) } function d() { const t = e.params.pagination; if (r()) return; const i = e.virtual && e.params.virtual.enabled ? e.virtual.slides.length : e.slides.length, s = e.pagination.$el; let a = ""; if ("bullets" === t.type) { let n = e.params.loop ? Math.ceil((i - 2 * e.loopedSlides) / e.params.slidesPerGroup) : e.snapGrid.length; e.params.freeMode && e.params.freeMode.enabled && !e.params.loop && n > i && (n = i); for (let i = 0; i < n; i += 1)t.renderBullet ? a += t.renderBullet.call(e, i, t.bulletClass) : a += `<${t.bulletElement} class="${t.bulletClass}"></${t.bulletElement}>`; s.html(a), e.pagination.bullets = s.find(Q(t.bulletClass)) } "fraction" === t.type && (a = t.renderFraction ? t.renderFraction.call(e, t.currentClass, t.totalClass) : `<span class="${t.currentClass}"></span> / <span class="${t.totalClass}"></span>`, s.html(a)), "progressbar" === t.type && (a = t.renderProgressbar ? t.renderProgressbar.call(e, t.progressbarFillClass) : `<span class="${t.progressbarFillClass}"></span>`, s.html(a)), "custom" !== t.type && n("paginationRender", e.pagination.$el[0]) } function h() { e.params.pagination = J(e, e.originalParams.pagination, e.params.pagination, { el: "swiper-pagination" }); const t = e.params.pagination; if (!t.el) return; let i = p(t.el); 0 !== i.length && (e.params.uniqueNavElements && "string" == typeof t.el && i.length > 1 && (i = e.$el.find(t.el), i.length > 1 && (i = i.filter((t => p(t).parents(".swiper")[0] === e.el)))), "bullets" === t.type && t.clickable && i.addClass(t.clickableClass), i.addClass(t.modifierClass + t.type), i.addClass(e.isHorizontal() ? t.horizontalClass : t.verticalClass), "bullets" === t.type && t.dynamicBullets && (i.addClass(`${t.modifierClass}${t.type}-dynamic`), o = 0, t.dynamicMainBullets < 1 && (t.dynamicMainBullets = 1)), "progressbar" === t.type && t.progressbarOpposite && i.addClass(t.progressbarOppositeClass), t.clickable && i.on("click", Q(t.bulletClass), (function (t) { t.preventDefault(); let i = p(this).index() * e.params.slidesPerGroup; e.params.loop && (i += e.loopedSlides), e.slideTo(i) })), Object.assign(e.pagination, { $el: i, el: i[0] }), e.enabled || i.addClass(t.lockClass)) } function u() { const t = e.params.pagination; if (r()) return; const i = e.pagination.$el; i.removeClass(t.hiddenClass), i.removeClass(t.modifierClass + t.type), i.removeClass(e.isHorizontal() ? t.horizontalClass : t.verticalClass), e.pagination.bullets && e.pagination.bullets.removeClass && e.pagination.bullets.removeClass(t.bulletActiveClass), t.clickable && i.off("click", Q(t.bulletClass)) } i("init", (() => { !1 === e.params.pagination.enabled ? f() : (h(), d(), c()) })), i("activeIndexChange", (() => { (e.params.loop || void 0 === e.snapIndex) && c() })), i("snapIndexChange", (() => { e.params.loop || c() })), i("slidesLengthChange", (() => { e.params.loop && (d(), c()) })), i("snapGridLengthChange", (() => { e.params.loop || (d(), c()) })), i("destroy", (() => { u() })), i("enable disable", (() => { const { $el: t } = e.pagination; t && t[e.enabled ? "removeClass" : "addClass"](e.params.pagination.lockClass) })), i("lock unlock", (() => { c() })), i("click", ((t, i) => { const s = i.target, { $el: a } = e.pagination; if (e.params.pagination.el && e.params.pagination.hideOnClick && a && a.length > 0 && !p(s).hasClass(e.params.pagination.bulletClass)) { if (e.navigation && (e.navigation.nextEl && s === e.navigation.nextEl || e.navigation.prevEl && s === e.navigation.prevEl)) return; const t = a.hasClass(e.params.pagination.hiddenClass); n(!0 === t ? "paginationShow" : "paginationHide"), a.toggleClass(e.params.pagination.hiddenClass) } })); const f = () => { e.$el.addClass(e.params.pagination.paginationDisabledClass), e.pagination.$el && e.pagination.$el.addClass(e.params.pagination.paginationDisabledClass), u() }; Object.assign(e.pagination, { enable: () => { e.$el.removeClass(e.params.pagination.paginationDisabledClass), e.pagination.$el && e.pagination.$el.removeClass(e.params.pagination.paginationDisabledClass), h(), d(), c() }, disable: f, render: d, update: c, init: h, destroy: u }) }, function ({ swiper: e, extendParams: t, on: i, emit: s }) { const a = n(); let o, r, l, c, d = !1, h = null, u = null; function m() { if (!e.params.scrollbar.el || !e.scrollbar.el) return; const { scrollbar: t, rtlTranslate: i, progress: n } = e, { $dragEl: s, $el: a } = t, o = e.params.scrollbar; let c = r, d = (l - r) * n; i ? (d = -d, d > 0 ? (c = r - d, d = 0) : -d + r > l && (c = l + d)) : d < 0 ? (c = r + d, d = 0) : d + r > l && (c = l - d), e.isHorizontal() ? (s.transform(`translate3d(${d}px, 0, 0)`), s[0].style.width = `${c}px`) : (s.transform(`translate3d(0px, ${d}px, 0)`), s[0].style.height = `${c}px`), o.hide && (clearTimeout(h), a[0].style.opacity = 1, h = setTimeout((() => { a[0].style.opacity = 0, a.transition(400) }), 1e3)) } function g() { if (!e.params.scrollbar.el || !e.scrollbar.el) return; const { scrollbar: t } = e, { $dragEl: i, $el: n } = t; i[0].style.width = "", i[0].style.height = "", l = e.isHorizontal() ? n[0].offsetWidth : n[0].offsetHeight, c = e.size / (e.virtualSize + e.params.slidesOffsetBefore - (e.params.centeredSlides ? e.snapGrid[0] : 0)), r = "auto" === e.params.scrollbar.dragSize ? l * c : parseInt(e.params.scrollbar.dragSize, 10), e.isHorizontal() ? i[0].style.width = `${r}px` : i[0].style.height = `${r}px`, n[0].style.display = c >= 1 ? "none" : "", e.params.scrollbar.hide && (n[0].style.opacity = 0), e.params.watchOverflow && e.enabled && t.$el[e.isLocked ? "addClass" : "removeClass"](e.params.scrollbar.lockClass) } function v(t) { return e.isHorizontal() ? "touchstart" === t.type || "touchmove" === t.type ? t.targetTouches[0].clientX : t.clientX : "touchstart" === t.type || "touchmove" === t.type ? t.targetTouches[0].clientY : t.clientY } function y(t) { const { scrollbar: i, rtlTranslate: n } = e, { $el: s } = i; let a; a = (v(t) - s.offset()[e.isHorizontal() ? "left" : "top"] - (null !== o ? o : r / 2)) / (l - r), a = Math.max(Math.min(a, 1), 0), n && (a = 1 - a); const c = e.minTranslate() + (e.maxTranslate() - e.minTranslate()) * a; e.updateProgress(c), e.setTranslate(c), e.updateActiveIndex(), e.updateSlidesClasses() } function b(t) { const i = e.params.scrollbar, { scrollbar: n, $wrapperEl: a } = e, { $el: r, $dragEl: l } = n; d = !0, o = t.target === l[0] || t.target === l ? v(t) - t.target.getBoundingClientRect()[e.isHorizontal() ? "left" : "top"] : null, t.preventDefault(), t.stopPropagation(), a.transition(100), l.transition(100), y(t), clearTimeout(u), r.transition(0), i.hide && r.css("opacity", 1), e.params.cssMode && e.$wrapperEl.css("scroll-snap-type", "none"), s("scrollbarDragStart", t) } function x(t) { const { scrollbar: i, $wrapperEl: n } = e, { $el: a, $dragEl: o } = i; d && (t.preventDefault ? t.preventDefault() : t.returnValue = !1, y(t), n.transition(0), a.transition(0), o.transition(0), s("scrollbarDragMove", t)) } function w(t) { const i = e.params.scrollbar, { scrollbar: n, $wrapperEl: a } = e, { $el: o } = n; d && (d = !1, e.params.cssMode && (e.$wrapperEl.css("scroll-snap-type", ""), a.transition("")), i.hide && (clearTimeout(u), u = f((() => { o.css("opacity", 0), o.transition(400) }), 1e3)), s("scrollbarDragEnd", t), i.snapOnRelease && e.slideToClosest()) } function C(t) { const { scrollbar: i, touchEventsTouch: n, touchEventsDesktop: s, params: o, support: r } = e, l = i.$el; if (!l) return; const c = l[0], d = !(!r.passiveListener || !o.passiveListeners) && { passive: !1, capture: !1 }, h = !(!r.passiveListener || !o.passiveListeners) && { passive: !0, capture: !1 }; if (!c) return; const u = "on" === t ? "addEventListener" : "removeEventListener"; r.touch ? (c[u](n.start, b, d), c[u](n.move, x, d), c[u](n.end, w, h)) : (c[u](s.start, b, d), a[u](s.move, x, d), a[u](s.end, w, h)) } function E() { const { scrollbar: t, $el: i } = e; e.params.scrollbar = J(e, e.originalParams.scrollbar, e.params.scrollbar, { el: "swiper-scrollbar" }); const n = e.params.scrollbar; if (!n.el) return; let s = p(n.el); e.params.uniqueNavElements && "string" == typeof n.el && s.length > 1 && 1 === i.find(n.el).length && (s = i.find(n.el)), s.addClass(e.isHorizontal() ? n.horizontalClass : n.verticalClass); let a = s.find(`.${e.params.scrollbar.dragClass}`); 0 === a.length && (a = p(`<div class="${e.params.scrollbar.dragClass}"></div>`), s.append(a)), Object.assign(t, { $el: s, el: s[0], $dragEl: a, dragEl: a[0] }), n.draggable && e.params.scrollbar.el && e.scrollbar.el && C("on"), s && s[e.enabled ? "removeClass" : "addClass"](e.params.scrollbar.lockClass) } function T() { const t = e.params.scrollbar, i = e.scrollbar.$el; i && i.removeClass(e.isHorizontal() ? t.horizontalClass : t.verticalClass), e.params.scrollbar.el && e.scrollbar.el && C("off") } t({ scrollbar: { el: null, dragSize: "auto", hide: !1, draggable: !1, snapOnRelease: !0, lockClass: "swiper-scrollbar-lock", dragClass: "swiper-scrollbar-drag", scrollbarDisabledClass: "swiper-scrollbar-disabled", horizontalClass: "swiper-scrollbar-horizontal", verticalClass: "swiper-scrollbar-vertical" } }), e.scrollbar = { el: null, dragEl: null, $el: null, $dragEl: null }, i("init", (() => { !1 === e.params.scrollbar.enabled ? S() : (E(), g(), m()) })), i("update resize observerUpdate lock unlock", (() => { g() })), i("setTranslate", (() => { m() })), i("setTransition", ((t, i) => { !function (t) { e.params.scrollbar.el && e.scrollbar.el && e.scrollbar.$dragEl.transition(t) }(i) })), i("enable disable", (() => { const { $el: t } = e.scrollbar; t && t[e.enabled ? "removeClass" : "addClass"](e.params.scrollbar.lockClass) })), i("destroy", (() => { T() })); const S = () => { e.$el.addClass(e.params.scrollbar.scrollbarDisabledClass), e.scrollbar.$el && e.scrollbar.$el.addClass(e.params.scrollbar.scrollbarDisabledClass), T() }; Object.assign(e.scrollbar, { enable: () => { e.$el.removeClass(e.params.scrollbar.scrollbarDisabledClass), e.scrollbar.$el && e.scrollbar.$el.removeClass(e.params.scrollbar.scrollbarDisabledClass), E(), g(), m() }, disable: S, updateSize: g, setTranslate: m, init: E, destroy: T }) }, function ({ swiper: e, extendParams: t, on: i }) { t({ parallax: { enabled: !1 } }); const n = (t, i) => { const { rtl: n } = e, s = p(t), a = n ? -1 : 1, o = s.attr("data-swiper-parallax") || "0"; let r = s.attr("data-swiper-parallax-x"), l = s.attr("data-swiper-parallax-y"); const c = s.attr("data-swiper-parallax-scale"), d = s.attr("data-swiper-parallax-opacity"); if (r || l ? (r = r || "0", l = l || "0") : e.isHorizontal() ? (r = o, l = "0") : (l = o, r = "0"), r = r.indexOf("%") >= 0 ? parseInt(r, 10) * i * a + "%" : r * i * a + "px", l = l.indexOf("%") >= 0 ? parseInt(l, 10) * i + "%" : l * i + "px", null != d) { const e = d - (d - 1) * (1 - Math.abs(i)); s[0].style.opacity = e } if (null == c) s.transform(`translate3d(${r}, ${l}, 0px)`); else { const e = c - (c - 1) * (1 - Math.abs(i)); s.transform(`translate3d(${r}, ${l}, 0px) scale(${e})`) } }, s = () => { const { $el: t, slides: i, progress: s, snapGrid: a } = e; t.children("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]").each((e => { n(e, s) })), i.each(((t, i) => { let o = t.progress; e.params.slidesPerGroup > 1 && "auto" !== e.params.slidesPerView && (o += Math.ceil(i / 2) - s * (a.length - 1)), o = Math.min(Math.max(o, -1), 1), p(t).find("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]").each((e => { n(e, o) })) })) }; i("beforeInit", (() => { e.params.parallax.enabled && (e.params.watchSlidesProgress = !0, e.originalParams.watchSlidesProgress = !0) })), i("init", (() => { e.params.parallax.enabled && s() })), i("setTranslate", (() => { e.params.parallax.enabled && s() })), i("setTransition", ((t, i) => { e.params.parallax.enabled && ((t = e.params.speed) => { const { $el: i } = e; i.find("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]").each((e => { const i = p(e); let n = parseInt(i.attr("data-swiper-parallax-duration"), 10) || t; 0 === t && (n = 0), i.transition(n) })) })(i) })) }, function ({ swiper: e, extendParams: t, on: i, emit: n }) { const s = a(); t({ zoom: { enabled: !1, maxRatio: 3, minRatio: 1, toggle: !0, containerClass: "swiper-zoom-container", zoomedSlideClass: "swiper-slide-zoomed" } }), e.zoom = { enabled: !1 }; let o, r, l, c = 1, d = !1; const h = { $slideEl: void 0, slideWidth: void 0, slideHeight: void 0, $imageEl: void 0, $imageWrapEl: void 0, maxRatio: 3 }, u = { isTouched: void 0, isMoved: void 0, currentX: void 0, currentY: void 0, minX: void 0, minY: void 0, maxX: void 0, maxY: void 0, width: void 0, height: void 0, startX: void 0, startY: void 0, touchesStart: {}, touchesCurrent: {} }, f = { x: void 0, y: void 0, prevPositionX: void 0, prevPositionY: void 0, prevTime: void 0 }; let m = 1; function v(e) { if (e.targetTouches.length < 2) return 1; const t = e.targetTouches[0].pageX, i = e.targetTouches[0].pageY, n = e.targetTouches[1].pageX, s = e.targetTouches[1].pageY; return Math.sqrt((n - t) ** 2 + (s - i) ** 2) } function y(t) { const i = e.support, n = e.params.zoom; if (r = !1, l = !1, !i.gestures) { if ("touchstart" !== t.type || "touchstart" === t.type && t.targetTouches.length < 2) return; r = !0, h.scaleStart = v(t) } h.$slideEl && h.$slideEl.length || (h.$slideEl = p(t.target).closest(`.${e.params.slideClass}`), 0 === h.$slideEl.length && (h.$slideEl = e.slides.eq(e.activeIndex)), h.$imageEl = h.$slideEl.find(`.${n.containerClass}`).eq(0).find("picture, img, svg, canvas, .swiper-zoom-target").eq(0), h.$imageWrapEl = h.$imageEl.parent(`.${n.containerClass}`), h.maxRatio = h.$imageWrapEl.attr("data-swiper-zoom") || n.maxRatio, 0 !== h.$imageWrapEl.length) ? (h.$imageEl && h.$imageEl.transition(0), d = !0) : h.$imageEl = void 0 } function b(t) { const i = e.support, n = e.params.zoom, s = e.zoom; if (!i.gestures) { if ("touchmove" !== t.type || "touchmove" === t.type && t.targetTouches.length < 2) return; l = !0, h.scaleMove = v(t) } h.$imageEl && 0 !== h.$imageEl.length ? (i.gestures ? s.scale = t.scale * c : s.scale = h.scaleMove / h.scaleStart * c, s.scale > h.maxRatio && (s.scale = h.maxRatio - 1 + (s.scale - h.maxRatio + 1) ** .5), s.scale < n.minRatio && (s.scale = n.minRatio + 1 - (n.minRatio - s.scale + 1) ** .5), h.$imageEl.transform(`translate3d(0,0,0) scale(${s.scale})`)) : "gesturechange" === t.type && y(t) } function x(t) { const i = e.device, n = e.support, s = e.params.zoom, a = e.zoom; if (!n.gestures) { if (!r || !l) return; if ("touchend" !== t.type || "touchend" === t.type && t.changedTouches.length < 2 && !i.android) return; r = !1, l = !1 } h.$imageEl && 0 !== h.$imageEl.length && (a.scale = Math.max(Math.min(a.scale, h.maxRatio), s.minRatio), h.$imageEl.transition(e.params.speed).transform(`translate3d(0,0,0) scale(${a.scale})`), c = a.scale, d = !1, 1 === a.scale && (h.$slideEl = void 0)) } function w(t) { const i = e.zoom; if (!h.$imageEl || 0 === h.$imageEl.length) return; if (e.allowClick = !1, !u.isTouched || !h.$slideEl) return; u.isMoved || (u.width = h.$imageEl[0].offsetWidth, u.height = h.$imageEl[0].offsetHeight, u.startX = g(h.$imageWrapEl[0], "x") || 0, u.startY = g(h.$imageWrapEl[0], "y") || 0, h.slideWidth = h.$slideEl[0].offsetWidth, h.slideHeight = h.$slideEl[0].offsetHeight, h.$imageWrapEl.transition(0)); const n = u.width * i.scale, s = u.height * i.scale; if (!(n < h.slideWidth && s < h.slideHeight)) { if (u.minX = Math.min(h.slideWidth / 2 - n / 2, 0), u.maxX = -u.minX, u.minY = Math.min(h.slideHeight / 2 - s / 2, 0), u.maxY = -u.minY, u.touchesCurrent.x = "touchmove" === t.type ? t.targetTouches[0].pageX : t.pageX, u.touchesCurrent.y = "touchmove" === t.type ? t.targetTouches[0].pageY : t.pageY, !u.isMoved && !d) { if (e.isHorizontal() && (Math.floor(u.minX) === Math.floor(u.startX) && u.touchesCurrent.x < u.touchesStart.x || Math.floor(u.maxX) === Math.floor(u.startX) && u.touchesCurrent.x > u.touchesStart.x)) return void (u.isTouched = !1); if (!e.isHorizontal() && (Math.floor(u.minY) === Math.floor(u.startY) && u.touchesCurrent.y < u.touchesStart.y || Math.floor(u.maxY) === Math.floor(u.startY) && u.touchesCurrent.y > u.touchesStart.y)) return void (u.isTouched = !1) } t.cancelable && t.preventDefault(), t.stopPropagation(), u.isMoved = !0, u.currentX = u.touchesCurrent.x - u.touchesStart.x + u.startX, u.currentY = u.touchesCurrent.y - u.touchesStart.y + u.startY, u.currentX < u.minX && (u.currentX = u.minX + 1 - (u.minX - u.currentX + 1) ** .8), u.currentX > u.maxX && (u.currentX = u.maxX - 1 + (u.currentX - u.maxX + 1) ** .8), u.currentY < u.minY && (u.currentY = u.minY + 1 - (u.minY - u.currentY + 1) ** .8), u.currentY > u.maxY && (u.currentY = u.maxY - 1 + (u.currentY - u.maxY + 1) ** .8), f.prevPositionX || (f.prevPositionX = u.touchesCurrent.x), f.prevPositionY || (f.prevPositionY = u.touchesCurrent.y), f.prevTime || (f.prevTime = Date.now()), f.x = (u.touchesCurrent.x - f.prevPositionX) / (Date.now() - f.prevTime) / 2, f.y = (u.touchesCurrent.y - f.prevPositionY) / (Date.now() - f.prevTime) / 2, Math.abs(u.touchesCurrent.x - f.prevPositionX) < 2 && (f.x = 0), Math.abs(u.touchesCurrent.y - f.prevPositionY) < 2 && (f.y = 0), f.prevPositionX = u.touchesCurrent.x, f.prevPositionY = u.touchesCurrent.y, f.prevTime = Date.now(), h.$imageWrapEl.transform(`translate3d(${u.currentX}px, ${u.currentY}px,0)`) } } function C() { const t = e.zoom; h.$slideEl && e.previousIndex !== e.activeIndex && (h.$imageEl && h.$imageEl.transform("translate3d(0,0,0) scale(1)"), h.$imageWrapEl && h.$imageWrapEl.transform("translate3d(0,0,0)"), t.scale = 1, c = 1, h.$slideEl = void 0, h.$imageEl = void 0, h.$imageWrapEl = void 0) } function E(t) { const i = e.zoom, n = e.params.zoom; if (h.$slideEl || (t && t.target && (h.$slideEl = p(t.target).closest(`.${e.params.slideClass}`)), h.$slideEl || (e.params.virtual && e.params.virtual.enabled && e.virtual ? h.$slideEl = e.$wrapperEl.children(`.${e.params.slideActiveClass}`) : h.$slideEl = e.slides.eq(e.activeIndex)), h.$imageEl = h.$slideEl.find(`.${n.containerClass}`).eq(0).find("picture, img, svg, canvas, .swiper-zoom-target").eq(0), h.$imageWrapEl = h.$imageEl.parent(`.${n.containerClass}`)), !h.$imageEl || 0 === h.$imageEl.length || !h.$imageWrapEl || 0 === h.$imageWrapEl.length) return; let a, o, r, l, d, f, m, g, v, y, b, x, w, C, E, T, S, $; e.params.cssMode && (e.wrapperEl.style.overflow = "hidden", e.wrapperEl.style.touchAction = "none"), h.$slideEl.addClass(`${n.zoomedSlideClass}`), void 0 === u.touchesStart.x && t ? (a = "touchend" === t.type ? t.changedTouches[0].pageX : t.pageX, o = "touchend" === t.type ? t.changedTouches[0].pageY : t.pageY) : (a = u.touchesStart.x, o = u.touchesStart.y), i.scale = h.$imageWrapEl.attr("data-swiper-zoom") || n.maxRatio, c = h.$imageWrapEl.attr("data-swiper-zoom") || n.maxRatio, t ? (S = h.$slideEl[0].offsetWidth, $ = h.$slideEl[0].offsetHeight, r = h.$slideEl.offset().left + s.scrollX, l = h.$slideEl.offset().top + s.scrollY, d = r + S / 2 - a, f = l + $ / 2 - o, v = h.$imageEl[0].offsetWidth, y = h.$imageEl[0].offsetHeight, b = v * i.scale, x = y * i.scale, w = Math.min(S / 2 - b / 2, 0), C = Math.min($ / 2 - x / 2, 0), E = -w, T = -C, m = d * i.scale, g = f * i.scale, m < w && (m = w), m > E && (m = E), g < C && (g = C), g > T && (g = T)) : (m = 0, g = 0), h.$imageWrapEl.transition(300).transform(`translate3d(${m}px, ${g}px,0)`), h.$imageEl.transition(300).transform(`translate3d(0,0,0) scale(${i.scale})`) } function T() { const t = e.zoom, i = e.params.zoom; h.$slideEl || (e.params.virtual && e.params.virtual.enabled && e.virtual ? h.$slideEl = e.$wrapperEl.children(`.${e.params.slideActiveClass}`) : h.$slideEl = e.slides.eq(e.activeIndex), h.$imageEl = h.$slideEl.find(`.${i.containerClass}`).eq(0).find("picture, img, svg, canvas, .swiper-zoom-target").eq(0), h.$imageWrapEl = h.$imageEl.parent(`.${i.containerClass}`)), h.$imageEl && 0 !== h.$imageEl.length && h.$imageWrapEl && 0 !== h.$imageWrapEl.length && (e.params.cssMode && (e.wrapperEl.style.overflow = "", e.wrapperEl.style.touchAction = ""), t.scale = 1, c = 1, h.$imageWrapEl.transition(300).transform("translate3d(0,0,0)"), h.$imageEl.transition(300).transform("translate3d(0,0,0) scale(1)"), h.$slideEl.removeClass(`${i.zoomedSlideClass}`), h.$slideEl = void 0) } function S(t) { const i = e.zoom; i.scale && 1 !== i.scale ? T() : E(t) } function $() { const t = e.support; return { passiveListener: !("touchstart" !== e.touchEvents.start || !t.passiveListener || !e.params.passiveListeners) && { passive: !0, capture: !1 }, activeListenerWithCapture: !t.passiveListener || { passive: !1, capture: !0 } } } function M() { return `.${e.params.slideClass}` } function P(t) { const { passiveListener: i } = $(), n = M(); e.$wrapperEl[t]("gesturestart", n, y, i), e.$wrapperEl[t]("gesturechange", n, b, i), e.$wrapperEl[t]("gestureend", n, x, i) } function k() { o || (o = !0, P("on")) } function L() { o && (o = !1, P("off")) } function A() { const t = e.zoom; if (t.enabled) return; t.enabled = !0; const i = e.support, { passiveListener: n, activeListenerWithCapture: s } = $(), a = M(); i.gestures ? (e.$wrapperEl.on(e.touchEvents.start, k, n), e.$wrapperEl.on(e.touchEvents.end, L, n)) : "touchstart" === e.touchEvents.start && (e.$wrapperEl.on(e.touchEvents.start, a, y, n), e.$wrapperEl.on(e.touchEvents.move, a, b, s), e.$wrapperEl.on(e.touchEvents.end, a, x, n), e.touchEvents.cancel && e.$wrapperEl.on(e.touchEvents.cancel, a, x, n)), e.$wrapperEl.on(e.touchEvents.move, `.${e.params.zoom.containerClass}`, w, s) } function z() { const t = e.zoom; if (!t.enabled) return; const i = e.support; t.enabled = !1; const { passiveListener: n, activeListenerWithCapture: s } = $(), a = M(); i.gestures ? (e.$wrapperEl.off(e.touchEvents.start, k, n), e.$wrapperEl.off(e.touchEvents.end, L, n)) : "touchstart" === e.touchEvents.start && (e.$wrapperEl.off(e.touchEvents.start, a, y, n), e.$wrapperEl.off(e.touchEvents.move, a, b, s), e.$wrapperEl.off(e.touchEvents.end, a, x, n), e.touchEvents.cancel && e.$wrapperEl.off(e.touchEvents.cancel, a, x, n)), e.$wrapperEl.off(e.touchEvents.move, `.${e.params.zoom.containerClass}`, w, s) } Object.defineProperty(e.zoom, "scale", { get() { return m }, set(e) { if (m !== e) { const t = h.$imageEl ? h.$imageEl[0] : void 0, i = h.$slideEl ? h.$slideEl[0] : void 0; n("zoomChange", e, t, i) } m = e } }), i("init", (() => { e.params.zoom.enabled && A() })), i("destroy", (() => { z() })), i("touchStart", ((t, i) => { e.zoom.enabled && function (t) { const i = e.device; h.$imageEl && 0 !== h.$imageEl.length && (u.isTouched || (i.android && t.cancelable && t.preventDefault(), u.isTouched = !0, u.touchesStart.x = "touchstart" === t.type ? t.targetTouches[0].pageX : t.pageX, u.touchesStart.y = "touchstart" === t.type ? t.targetTouches[0].pageY : t.pageY)) }(i) })), i("touchEnd", ((t, i) => { e.zoom.enabled && function () { const t = e.zoom; if (!h.$imageEl || 0 === h.$imageEl.length) return; if (!u.isTouched || !u.isMoved) return u.isTouched = !1, void (u.isMoved = !1); u.isTouched = !1, u.isMoved = !1; let i = 300, n = 300; const s = f.x * i, a = u.currentX + s, o = f.y * n, r = u.currentY + o; 0 !== f.x && (i = Math.abs((a - u.currentX) / f.x)), 0 !== f.y && (n = Math.abs((r - u.currentY) / f.y)); const l = Math.max(i, n); u.currentX = a, u.currentY = r; const c = u.width * t.scale, d = u.height * t.scale; u.minX = Math.min(h.slideWidth / 2 - c / 2, 0), u.maxX = -u.minX, u.minY = Math.min(h.slideHeight / 2 - d / 2, 0), u.maxY = -u.minY, u.currentX = Math.max(Math.min(u.currentX, u.maxX), u.minX), u.currentY = Math.max(Math.min(u.currentY, u.maxY), u.minY), h.$imageWrapEl.transition(l).transform(`translate3d(${u.currentX}px, ${u.currentY}px,0)`) }() })), i("doubleTap", ((t, i) => { !e.animating && e.params.zoom.enabled && e.zoom.enabled && e.params.zoom.toggle && S(i) })), i("transitionEnd", (() => { e.zoom.enabled && e.params.zoom.enabled && C() })), i("slideChange", (() => { e.zoom.enabled && e.params.zoom.enabled && e.params.cssMode && C() })), Object.assign(e.zoom, { enable: A, disable: z, in: E, out: T, toggle: S }) }, function ({ swiper: e, extendParams: t, on: i, emit: n }) { t({ lazy: { checkInView: !1, enabled: !1, loadPrevNext: !1, loadPrevNextAmount: 1, loadOnTransitionStart: !1, scrollingElement: "", elementClass: "swiper-lazy", loadingClass: "swiper-lazy-loading", loadedClass: "swiper-lazy-loaded", preloaderClass: "swiper-lazy-preloader" } }), e.lazy = {}; let s = !1, o = !1; function r(t, i = !0) { const s = e.params.lazy; if (void 0 === t) return; if (0 === e.slides.length) return; const a = e.virtual && e.params.virtual.enabled ? e.$wrapperEl.children(`.${e.params.slideClass}[data-swiper-slide-index="${t}"]`) : e.slides.eq(t), o = a.find(`.${s.elementClass}:not(.${s.loadedClass}):not(.${s.loadingClass})`); !a.hasClass(s.elementClass) || a.hasClass(s.loadedClass) || a.hasClass(s.loadingClass) || o.push(a[0]), 0 !== o.length && o.each((t => { const o = p(t); o.addClass(s.loadingClass); const l = o.attr("data-background"), c = o.attr("data-src"), d = o.attr("data-srcset"), h = o.attr("data-sizes"), u = o.parent("picture"); e.loadImage(o[0], c || l, d, h, !1, (() => { if (null != e && e && (!e || e.params) && !e.destroyed) { if (l ? (o.css("background-image", `url("${l}")`), o.removeAttr("data-background")) : (d && (o.attr("srcset", d), o.removeAttr("data-srcset")), h && (o.attr("sizes", h), o.removeAttr("data-sizes")), u.length && u.children("source").each((e => { const t = p(e); t.attr("data-srcset") && (t.attr("srcset", t.attr("data-srcset")), t.removeAttr("data-srcset")) })), c && (o.attr("src", c), o.removeAttr("data-src"))), o.addClass(s.loadedClass).removeClass(s.loadingClass), a.find(`.${s.preloaderClass}`).remove(), e.params.loop && i) { const t = a.attr("data-swiper-slide-index"); if (a.hasClass(e.params.slideDuplicateClass)) { r(e.$wrapperEl.children(`[data-swiper-slide-index="${t}"]:not(.${e.params.slideDuplicateClass})`).index(), !1) } else { r(e.$wrapperEl.children(`.${e.params.slideDuplicateClass}[data-swiper-slide-index="${t}"]`).index(), !1) } } n("lazyImageReady", a[0], o[0]), e.params.autoHeight && e.updateAutoHeight() } })), n("lazyImageLoad", a[0], o[0]) })) } function l() { const { $wrapperEl: t, params: i, slides: n, activeIndex: s } = e, a = e.virtual && i.virtual.enabled, l = i.lazy; let c = i.slidesPerView; function d(e) { if (a) { if (t.children(`.${i.slideClass}[data-swiper-slide-index="${e}"]`).length) return !0 } else if (n[e]) return !0; return !1 } function h(e) { return a ? p(e).attr("data-swiper-slide-index") : p(e).index() } if ("auto" === c && (c = 0), o || (o = !0), e.params.watchSlidesProgress) t.children(`.${i.slideVisibleClass}`).each((e => { r(a ? p(e).attr("data-swiper-slide-index") : p(e).index()) })); else if (c > 1) for (let e = s; e < s + c; e += 1)d(e) && r(e); else r(s); if (l.loadPrevNext) if (c > 1 || l.loadPrevNextAmount && l.loadPrevNextAmount > 1) { const e = l.loadPrevNextAmount, t = Math.ceil(c), i = Math.min(s + t + Math.max(e, t), n.length), a = Math.max(s - Math.max(t, e), 0); for (let e = s + t; e < i; e += 1)d(e) && r(e); for (let e = a; e < s; e += 1)d(e) && r(e) } else { const e = t.children(`.${i.slideNextClass}`); e.length > 0 && r(h(e)); const n = t.children(`.${i.slidePrevClass}`); n.length > 0 && r(h(n)) } } function c() { const t = a(); if (!e || e.destroyed) return; const i = e.params.lazy.scrollingElement ? p(e.params.lazy.scrollingElement) : p(t), n = i[0] === t, o = n ? t.innerWidth : i[0].offsetWidth, r = n ? t.innerHeight : i[0].offsetHeight, d = e.$el.offset(), { rtlTranslate: h } = e; let u = !1; h && (d.left -= e.$el[0].scrollLeft); const f = [[d.left, d.top], [d.left + e.width, d.top], [d.left, d.top + e.height], [d.left + e.width, d.top + e.height]]; for (let e = 0; e < f.length; e += 1) { const t = f[e]; if (t[0] >= 0 && t[0] <= o && t[1] >= 0 && t[1] <= r) { if (0 === t[0] && 0 === t[1]) continue; u = !0 } } const m = !("touchstart" !== e.touchEvents.start || !e.support.passiveListener || !e.params.passiveListeners) && { passive: !0, capture: !1 }; u ? (l(), i.off("scroll", c, m)) : s || (s = !0, i.on("scroll", c, m)) } i("beforeInit", (() => { e.params.lazy.enabled && e.params.preloadImages && (e.params.preloadImages = !1) })), i("init", (() => { e.params.lazy.enabled && (e.params.lazy.checkInView ? c() : l()) })), i("scroll", (() => { e.params.freeMode && e.params.freeMode.enabled && !e.params.freeMode.sticky && l() })), i("scrollbarDragMove resize _freeModeNoMomentumRelease", (() => { e.params.lazy.enabled && (e.params.lazy.checkInView ? c() : l()) })), i("transitionStart", (() => { e.params.lazy.enabled && (e.params.lazy.loadOnTransitionStart || !e.params.lazy.loadOnTransitionStart && !o) && (e.params.lazy.checkInView ? c() : l()) })), i("transitionEnd", (() => { e.params.lazy.enabled && !e.params.lazy.loadOnTransitionStart && (e.params.lazy.checkInView ? c() : l()) })), i("slideChange", (() => { const { lazy: t, cssMode: i, watchSlidesProgress: n, touchReleaseOnEdges: s, resistanceRatio: a } = e.params; t.enabled && (i || n && (s || 0 === a)) && l() })), i("destroy", (() => { e.$el && e.$el.find(`.${e.params.lazy.loadingClass}`).removeClass(e.params.lazy.loadingClass) })), Object.assign(e.lazy, { load: l, loadInSlide: r }) }, function ({ swiper: e, extendParams: t, on: i }) { function n(e, t) { const i = function () { let e, t, i; return (n, s) => { for (t = -1, e = n.length; e - t > 1;)i = e + t >> 1, n[i] <= s ? t = i : e = i; return e } }(); let n, s; return this.x = e, this.y = t, this.lastIndex = e.length - 1, this.interpolate = function (e) { return e ? (s = i(this.x, e), n = s - 1, (e - this.x[n]) * (this.y[s] - this.y[n]) / (this.x[s] - this.x[n]) + this.y[n]) : 0 }, this } function s() { e.controller.control && e.controller.spline && (e.controller.spline = void 0, delete e.controller.spline) } t({ controller: { control: void 0, inverse: !1, by: "slide" } }), e.controller = { control: void 0 }, i("beforeInit", (() => { e.controller.control = e.params.controller.control })), i("update", (() => { s() })), i("resize", (() => { s() })), i("observerUpdate", (() => { s() })), i("setTranslate", ((t, i, n) => { e.controller.control && e.controller.setTranslate(i, n) })), i("setTransition", ((t, i, n) => { e.controller.control && e.controller.setTransition(i, n) })), Object.assign(e.controller, { setTranslate: function (t, i) { const s = e.controller.control; let a, o; const r = e.constructor; function l(t) { const i = e.rtlTranslate ? -e.translate : e.translate; "slide" === e.params.controller.by && (!function (t) { e.controller.spline || (e.controller.spline = e.params.loop ? new n(e.slidesGrid, t.slidesGrid) : new n(e.snapGrid, t.snapGrid)) }(t), o = -e.controller.spline.interpolate(-i)), o && "container" !== e.params.controller.by || (a = (t.maxTranslate() - t.minTranslate()) / (e.maxTranslate() - e.minTranslate()), o = (i - e.minTranslate()) * a + t.minTranslate()), e.params.controller.inverse && (o = t.maxTranslate() - o), t.updateProgress(o), t.setTranslate(o, e), t.updateActiveIndex(), t.updateSlidesClasses() } if (Array.isArray(s)) for (let e = 0; e < s.length; e += 1)s[e] !== i && s[e] instanceof r && l(s[e]); else s instanceof r && i !== s && l(s) }, setTransition: function (t, i) { const n = e.constructor, s = e.controller.control; let a; function o(i) { i.setTransition(t, e), 0 !== t && (i.transitionStart(), i.params.autoHeight && f((() => { i.updateAutoHeight() })), i.$wrapperEl.transitionEnd((() => { s && (i.params.loop && "slide" === e.params.controller.by && i.loopFix(), i.transitionEnd()) }))) } if (Array.isArray(s)) for (a = 0; a < s.length; a += 1)s[a] !== i && s[a] instanceof n && o(s[a]); else s instanceof n && i !== s && o(s) } }) }, function ({ swiper: e, extendParams: t, on: i }) { t({ a11y: { enabled: !0, notificationClass: "swiper-notification", prevSlideMessage: "Previous slide", nextSlideMessage: "Next slide", firstSlideMessage: "This is the first slide", lastSlideMessage: "This is the last slide", paginationBulletMessage: "Go to slide {{index}}", slideLabelMessage: "{{index}} / {{slidesLength}}", containerMessage: null, containerRoleDescriptionMessage: null, itemRoleDescriptionMessage: null, slideRole: "group", id: null } }), e.a11y = { clicked: !1 }; let n = null; function s(e) { const t = n; 0 !== t.length && (t.html(""), t.html(e)) } function a(e) { e.attr("tabIndex", "0") } function o(e) { e.attr("tabIndex", "-1") } function r(e, t) { e.attr("role", t) } function l(e, t) { e.attr("aria-roledescription", t) } function c(e, t) { e.attr("aria-label", t) } function d(e) { e.attr("aria-disabled", !0) } function h(e) { e.attr("aria-disabled", !1) } function u(t) { if (13 !== t.keyCode && 32 !== t.keyCode) return; const i = e.params.a11y, n = p(t.target); e.navigation && e.navigation.$nextEl && n.is(e.navigation.$nextEl) && (e.isEnd && !e.params.loop || e.slideNext(), e.isEnd ? s(i.lastSlideMessage) : s(i.nextSlideMessage)), e.navigation && e.navigation.$prevEl && n.is(e.navigation.$prevEl) && (e.isBeginning && !e.params.loop || e.slidePrev(), e.isBeginning ? s(i.firstSlideMessage) : s(i.prevSlideMessage)), e.pagination && n.is(Q(e.params.pagination.bulletClass)) && n[0].click() } function f() { return e.pagination && e.pagination.bullets && e.pagination.bullets.length } function m() { return f() && e.params.pagination.clickable } const g = (e, t, i) => { a(e), "BUTTON" !== e[0].tagName && (r(e, "button"), e.on("keydown", u)), c(e, i), function (e, t) { e.attr("aria-controls", t) }(e, t) }, v = () => { e.a11y.clicked = !0 }, y = () => { requestAnimationFrame((() => { requestAnimationFrame((() => { e.destroyed || (e.a11y.clicked = !1) })) })) }, b = t => { if (e.a11y.clicked) return; const i = t.target.closest(`.${e.params.slideClass}`); if (!i || !e.slides.includes(i)) return; const n = e.slides.indexOf(i) === e.activeIndex, s = e.params.watchSlidesProgress && e.visibleSlides && e.visibleSlides.includes(i); n || s || t.sourceCapabilities && t.sourceCapabilities.firesTouchEvents || (e.isHorizontal() ? e.el.scrollLeft = 0 : e.el.scrollTop = 0, e.slideTo(e.slides.indexOf(i), 0)) }, x = () => { const t = e.params.a11y; t.itemRoleDescriptionMessage && l(p(e.slides), t.itemRoleDescriptionMessage), t.slideRole && r(p(e.slides), t.slideRole); const i = e.params.loop ? e.slides.filter((t => !t.classList.contains(e.params.slideDuplicateClass))).length : e.slides.length; t.slideLabelMessage && e.slides.each(((n, s) => { const a = p(n), o = e.params.loop ? parseInt(a.attr("data-swiper-slide-index"), 10) : s; c(a, t.slideLabelMessage.replace(/\{\{index\}\}/, o + 1).replace(/\{\{slidesLength\}\}/, i)) })) }, w = () => { const t = e.params.a11y; e.$el.append(n); const i = e.$el; t.containerRoleDescriptionMessage && l(i, t.containerRoleDescriptionMessage), t.containerMessage && c(i, t.containerMessage); const s = e.$wrapperEl, a = t.id || s.attr("id") || `swiper-wrapper-${function (e = 16) { return "x".repeat(e).replace(/x/g, (() => Math.round(16 * Math.random()).toString(16))) }(16)}`, o = e.params.autoplay && e.params.autoplay.enabled ? "off" : "polite"; var r; let d, h; r = a, s.attr("id", r), function (e, t) { e.attr("aria-live", t) }(s, o), x(), e.navigation && e.navigation.$nextEl && (d = e.navigation.$nextEl), e.navigation && e.navigation.$prevEl && (h = e.navigation.$prevEl), d && d.length && g(d, a, t.nextSlideMessage), h && h.length && g(h, a, t.prevSlideMessage), m() && e.pagination.$el.on("keydown", Q(e.params.pagination.bulletClass), u), e.$el.on("focus", b, !0), e.$el.on("pointerdown", v, !0), e.$el.on("pointerup", y, !0) }; i("beforeInit", (() => { n = p(`<span class="${e.params.a11y.notificationClass}" aria-live="assertive" aria-atomic="true"></span>`) })), i("afterInit", (() => { e.params.a11y.enabled && w() })), i("slidesLengthChange snapGridLengthChange slidesGridLengthChange", (() => { e.params.a11y.enabled && x() })), i("fromEdge toEdge afterInit lock unlock", (() => { e.params.a11y.enabled && function () { if (e.params.loop || e.params.rewind || !e.navigation) return; const { $nextEl: t, $prevEl: i } = e.navigation; i && i.length > 0 && (e.isBeginning ? (d(i), o(i)) : (h(i), a(i))), t && t.length > 0 && (e.isEnd ? (d(t), o(t)) : (h(t), a(t))) }() })), i("paginationUpdate", (() => { e.params.a11y.enabled && function () { const t = e.params.a11y; f() && e.pagination.bullets.each((i => { const n = p(i); e.params.pagination.clickable && (a(n), e.params.pagination.renderBullet || (r(n, "button"), c(n, t.paginationBulletMessage.replace(/\{\{index\}\}/, n.index() + 1)))), n.is(`.${e.params.pagination.bulletActiveClass}`) ? n.attr("aria-current", "true") : n.removeAttr("aria-current") })) }() })), i("destroy", (() => { e.params.a11y.enabled && function () { let t, i; n && n.length > 0 && n.remove(), e.navigation && e.navigation.$nextEl && (t = e.navigation.$nextEl), e.navigation && e.navigation.$prevEl && (i = e.navigation.$prevEl), t && t.off("keydown", u), i && i.off("keydown", u), m() && e.pagination.$el.off("keydown", Q(e.params.pagination.bulletClass), u), e.$el.off("focus", b, !0), e.$el.off("pointerdown", v, !0), e.$el.off("pointerup", y, !0) }() })) }, function ({ swiper: e, extendParams: t, on: i }) { t({ history: { enabled: !1, root: "", replaceState: !1, key: "slides", keepQuery: !1 } }); let n = !1, s = {}; const o = e => e.toString().replace(/\s+/g, "-").replace(/[^\w-]+/g, "").replace(/--+/g, "-").replace(/^-+/, "").replace(/-+$/, ""), r = e => { const t = a(); let i; i = e ? new URL(e) : t.location; const n = i.pathname.slice(1).split("/").filter((e => "" !== e)), s = n.length; return { key: n[s - 2], value: n[s - 1] } }, l = (t, i) => { const s = a(); if (!n || !e.params.history.enabled) return; let r; r = e.params.url ? new URL(e.params.url) : s.location; const l = e.slides.eq(i); let c = o(l.attr("data-history")); if (e.params.history.root.length > 0) { let i = e.params.history.root; "/" === i[i.length - 1] && (i = i.slice(0, i.length - 1)), c = `${i}/${t}/${c}` } else r.pathname.includes(t) || (c = `${t}/${c}`); e.params.history.keepQuery && (c += r.search); const d = s.history.state; d && d.value === c || (e.params.history.replaceState ? s.history.replaceState({ value: c }, null, c) : s.history.pushState({ value: c }, null, c)) }, c = (t, i, n) => { if (i) for (let s = 0, a = e.slides.length; s < a; s += 1) { const a = e.slides.eq(s); if (o(a.attr("data-history")) === i && !a.hasClass(e.params.slideDuplicateClass)) { const i = a.index(); e.slideTo(i, t, n) } } else e.slideTo(0, t, n) }, d = () => { s = r(e.params.url), c(e.params.speed, s.value, !1) }; i("init", (() => { e.params.history.enabled && (() => { const t = a(); if (e.params.history) { if (!t.history || !t.history.pushState) return e.params.history.enabled = !1, void (e.params.hashNavigation.enabled = !0); n = !0, s = r(e.params.url), (s.key || s.value) && (c(0, s.value, e.params.runCallbacksOnInit), e.params.history.replaceState || t.addEventListener("popstate", d)) } })() })), i("destroy", (() => { e.params.history.enabled && (() => { const t = a(); e.params.history.replaceState || t.removeEventListener("popstate", d) })() })), i("transitionEnd _freeModeNoMomentumRelease", (() => { n && l(e.params.history.key, e.activeIndex) })), i("slideChange", (() => { n && e.params.cssMode && l(e.params.history.key, e.activeIndex) })) }, function ({ swiper: e, extendParams: t, emit: i, on: s }) { let o = !1; const r = n(), l = a(); t({ hashNavigation: { enabled: !1, replaceState: !1, watchState: !1 } }); const c = () => { i("hashChange"); const t = r.location.hash.replace("#", ""); if (t !== e.slides.eq(e.activeIndex).attr("data-hash")) { const i = e.$wrapperEl.children(`.${e.params.slideClass}[data-hash="${t}"]`).index(); if (void 0 === i) return; e.slideTo(i) } }, d = () => { if (o && e.params.hashNavigation.enabled) if (e.params.hashNavigation.replaceState && l.history && l.history.replaceState) l.history.replaceState(null, null, `#${e.slides.eq(e.activeIndex).attr("data-hash")}` || ""), i("hashSet"); else { const t = e.slides.eq(e.activeIndex), n = t.attr("data-hash") || t.attr("data-history"); r.location.hash = n || "", i("hashSet") } }; s("init", (() => { e.params.hashNavigation.enabled && (() => { if (!e.params.hashNavigation.enabled || e.params.history && e.params.history.enabled) return; o = !0; const t = r.location.hash.replace("#", ""); if (t) { const i = 0; for (let n = 0, s = e.slides.length; n < s; n += 1) { const s = e.slides.eq(n); if ((s.attr("data-hash") || s.attr("data-history")) === t && !s.hasClass(e.params.slideDuplicateClass)) { const t = s.index(); e.slideTo(t, i, e.params.runCallbacksOnInit, !0) } } } e.params.hashNavigation.watchState && p(l).on("hashchange", c) })() })), s("destroy", (() => { e.params.hashNavigation.enabled && e.params.hashNavigation.watchState && p(l).off("hashchange", c) })), s("transitionEnd _freeModeNoMomentumRelease", (() => { o && d() })), s("slideChange", (() => { o && e.params.cssMode && d() })) }, function ({ swiper: e, extendParams: t, on: i, emit: s }) { let a; function o() { if (!e.size) return e.autoplay.running = !1, void (e.autoplay.paused = !1); const t = e.slides.eq(e.activeIndex); let i = e.params.autoplay.delay; t.attr("data-swiper-autoplay") && (i = t.attr("data-swiper-autoplay") || e.params.autoplay.delay), clearTimeout(a), a = f((() => { let t; e.params.autoplay.reverseDirection ? e.params.loop ? (e.loopFix(), t = e.slidePrev(e.params.speed, !0, !0), s("autoplay")) : e.isBeginning ? e.params.autoplay.stopOnLastSlide ? l() : (t = e.slideTo(e.slides.length - 1, e.params.speed, !0, !0), s("autoplay")) : (t = e.slidePrev(e.params.speed, !0, !0), s("autoplay")) : e.params.loop ? (e.loopFix(), t = e.slideNext(e.params.speed, !0, !0), s("autoplay")) : e.isEnd ? e.params.autoplay.stopOnLastSlide ? l() : (t = e.slideTo(0, e.params.speed, !0, !0), s("autoplay")) : (t = e.slideNext(e.params.speed, !0, !0), s("autoplay")), (e.params.cssMode && e.autoplay.running || !1 === t) && o() }), i) } function r() { return void 0 === a && (!e.autoplay.running && (e.autoplay.running = !0, s("autoplayStart"), o(), !0)) } function l() { return !!e.autoplay.running && (void 0 !== a && (a && (clearTimeout(a), a = void 0), e.autoplay.running = !1, s("autoplayStop"), !0)) } function c(t) { e.autoplay.running && (e.autoplay.paused || (a && clearTimeout(a), e.autoplay.paused = !0, 0 !== t && e.params.autoplay.waitForTransition ? ["transitionend", "webkitTransitionEnd"].forEach((t => { e.$wrapperEl[0].addEventListener(t, h) })) : (e.autoplay.paused = !1, o()))) } function d() { const t = n(); "hidden" === t.visibilityState && e.autoplay.running && c(), "visible" === t.visibilityState && e.autoplay.paused && (o(), e.autoplay.paused = !1) } function h(t) { e && !e.destroyed && e.$wrapperEl && t.target === e.$wrapperEl[0] && (["transitionend", "webkitTransitionEnd"].forEach((t => { e.$wrapperEl[0].removeEventListener(t, h) })), e.autoplay.paused = !1, e.autoplay.running ? o() : l()) } function u() { e.params.autoplay.disableOnInteraction ? l() : (s("autoplayPause"), c()), ["transitionend", "webkitTransitionEnd"].forEach((t => { e.$wrapperEl[0].removeEventListener(t, h) })) } function p() { e.params.autoplay.disableOnInteraction || (e.autoplay.paused = !1, s("autoplayResume"), o()) } e.autoplay = { running: !1, paused: !1 }, t({ autoplay: { enabled: !1, delay: 3e3, waitForTransition: !0, disableOnInteraction: !0, stopOnLastSlide: !1, reverseDirection: !1, pauseOnMouseEnter: !1 } }), i("init", (() => { if (e.params.autoplay.enabled) { r(); n().addEventListener("visibilitychange", d), e.params.autoplay.pauseOnMouseEnter && (e.$el.on("mouseenter", u), e.$el.on("mouseleave", p)) } })), i("beforeTransitionStart", ((t, i, n) => { e.autoplay.running && (n || !e.params.autoplay.disableOnInteraction ? e.autoplay.pause(i) : l()) })), i("sliderFirstMove", (() => { e.autoplay.running && (e.params.autoplay.disableOnInteraction ? l() : c()) })), i("touchEnd", (() => { e.params.cssMode && e.autoplay.paused && !e.params.autoplay.disableOnInteraction && o() })), i("destroy", (() => { e.$el.off("mouseenter", u), e.$el.off("mouseleave", p), e.autoplay.running && l(); n().removeEventListener("visibilitychange", d) })), Object.assign(e.autoplay, { pause: c, run: o, start: r, stop: l }) }, function ({ swiper: e, extendParams: t, on: i }) { t({ thumbs: { swiper: null, multipleActiveThumbs: !0, autoScrollOffset: 0, slideThumbActiveClass: "swiper-slide-thumb-active", thumbsContainerClass: "swiper-thumbs" } }); let n = !1, s = !1; function a() { const t = e.thumbs.swiper; if (!t || t.destroyed) return; const i = t.clickedIndex, n = t.clickedSlide; if (n && p(n).hasClass(e.params.thumbs.slideThumbActiveClass)) return; if (null == i) return; let s; if (s = t.params.loop ? parseInt(p(t.clickedSlide).attr("data-swiper-slide-index"), 10) : i, e.params.loop) { let t = e.activeIndex; e.slides.eq(t).hasClass(e.params.slideDuplicateClass) && (e.loopFix(), e._clientLeft = e.$wrapperEl[0].clientLeft, t = e.activeIndex); const i = e.slides.eq(t).prevAll(`[data-swiper-slide-index="${s}"]`).eq(0).index(), n = e.slides.eq(t).nextAll(`[data-swiper-slide-index="${s}"]`).eq(0).index(); s = void 0 === i ? n : void 0 === n ? i : n - t < t - i ? n : i } e.slideTo(s) } function o() { const { thumbs: t } = e.params; if (n) return !1; n = !0; const i = e.constructor; if (t.swiper instanceof i) e.thumbs.swiper = t.swiper, Object.assign(e.thumbs.swiper.originalParams, { watchSlidesProgress: !0, slideToClickedSlide: !1 }), Object.assign(e.thumbs.swiper.params, { watchSlidesProgress: !0, slideToClickedSlide: !1 }); else if (v(t.swiper)) { const n = Object.assign({}, t.swiper); Object.assign(n, { watchSlidesProgress: !0, slideToClickedSlide: !1 }), e.thumbs.swiper = new i(n), s = !0 } return e.thumbs.swiper.$el.addClass(e.params.thumbs.thumbsContainerClass), e.thumbs.swiper.on("tap", a), !0 } function r(t) { const i = e.thumbs.swiper; if (!i || i.destroyed) return; const n = "auto" === i.params.slidesPerView ? i.slidesPerViewDynamic() : i.params.slidesPerView; let s = 1; const a = e.params.thumbs.slideThumbActiveClass; if (e.params.slidesPerView > 1 && !e.params.centeredSlides && (s = e.params.slidesPerView), e.params.thumbs.multipleActiveThumbs || (s = 1), s = Math.floor(s), i.slides.removeClass(a), i.params.loop || i.params.virtual && i.params.virtual.enabled) for (let t = 0; t < s; t += 1)i.$wrapperEl.children(`[data-swiper-slide-index="${e.realIndex + t}"]`).addClass(a); else for (let t = 0; t < s; t += 1)i.slides.eq(e.realIndex + t).addClass(a); const o = e.params.thumbs.autoScrollOffset, r = o && !i.params.loop; if (e.realIndex !== i.realIndex || r) { let s, a, l = i.activeIndex; if (i.params.loop) { i.slides.eq(l).hasClass(i.params.slideDuplicateClass) && (i.loopFix(), i._clientLeft = i.$wrapperEl[0].clientLeft, l = i.activeIndex); const t = i.slides.eq(l).prevAll(`[data-swiper-slide-index="${e.realIndex}"]`).eq(0).index(), n = i.slides.eq(l).nextAll(`[data-swiper-slide-index="${e.realIndex}"]`).eq(0).index(); s = void 0 === t ? n : void 0 === n ? t : n - l == l - t ? i.params.slidesPerGroup > 1 ? n : l : n - l < l - t ? n : t, a = e.activeIndex > e.previousIndex ? "next" : "prev" } else s = e.realIndex, a = s > e.previousIndex ? "next" : "prev"; r && (s += "next" === a ? o : -1 * o), i.visibleSlidesIndexes && i.visibleSlidesIndexes.indexOf(s) < 0 && (i.params.centeredSlides ? s = s > l ? s - Math.floor(n / 2) + 1 : s + Math.floor(n / 2) - 1 : s > l && i.params.slidesPerGroup, i.slideTo(s, t ? 0 : void 0)) } } e.thumbs = { swiper: null }, i("beforeInit", (() => { const { thumbs: t } = e.params; t && t.swiper && (o(), r(!0)) })), i("slideChange update resize observerUpdate", (() => { r() })), i("setTransition", ((t, i) => { const n = e.thumbs.swiper; n && !n.destroyed && n.setTransition(i) })), i("beforeDestroy", (() => { const t = e.thumbs.swiper; t && !t.destroyed && s && t.destroy() })), Object.assign(e.thumbs, { init: o, update: r }) }, function ({ swiper: e, extendParams: t, emit: i, once: n }) { t({ freeMode: { enabled: !1, momentum: !0, momentumRatio: 1, momentumBounce: !0, momentumBounceRatio: 1, momentumVelocityRatio: 1, sticky: !1, minimumVelocity: .02 } }), Object.assign(e, { freeMode: { onTouchStart: function () { const t = e.getTranslate(); e.setTranslate(t), e.setTransition(0), e.touchEventsData.velocities.length = 0, e.freeMode.onTouchEnd({ currentPos: e.rtl ? e.translate : -e.translate }) }, onTouchMove: function () { const { touchEventsData: t, touches: i } = e; 0 === t.velocities.length && t.velocities.push({ position: i[e.isHorizontal() ? "startX" : "startY"], time: t.touchStartTime }), t.velocities.push({ position: i[e.isHorizontal() ? "currentX" : "currentY"], time: m() }) }, onTouchEnd: function ({ currentPos: t }) { const { params: s, $wrapperEl: a, rtlTranslate: o, snapGrid: r, touchEventsData: l } = e, c = m() - l.touchStartTime; if (t < -e.minTranslate()) e.slideTo(e.activeIndex); else if (t > -e.maxTranslate()) e.slides.length < r.length ? e.slideTo(r.length - 1) : e.slideTo(e.slides.length - 1); else { if (s.freeMode.momentum) { if (l.velocities.length > 1) { const t = l.velocities.pop(), i = l.velocities.pop(), n = t.position - i.position, a = t.time - i.time; e.velocity = n / a, e.velocity /= 2, Math.abs(e.velocity) < s.freeMode.minimumVelocity && (e.velocity = 0), (a > 150 || m() - t.time > 300) && (e.velocity = 0) } else e.velocity = 0; e.velocity *= s.freeMode.momentumVelocityRatio, l.velocities.length = 0; let t = 1e3 * s.freeMode.momentumRatio; const c = e.velocity * t; let d = e.translate + c; o && (d = -d); let h, u = !1; const p = 20 * Math.abs(e.velocity) * s.freeMode.momentumBounceRatio; let f; if (d < e.maxTranslate()) s.freeMode.momentumBounce ? (d + e.maxTranslate() < -p && (d = e.maxTranslate() - p), h = e.maxTranslate(), u = !0, l.allowMomentumBounce = !0) : d = e.maxTranslate(), s.loop && s.centeredSlides && (f = !0); else if (d > e.minTranslate()) s.freeMode.momentumBounce ? (d - e.minTranslate() > p && (d = e.minTranslate() + p), h = e.minTranslate(), u = !0, l.allowMomentumBounce = !0) : d = e.minTranslate(), s.loop && s.centeredSlides && (f = !0); else if (s.freeMode.sticky) { let t; for (let e = 0; e < r.length; e += 1)if (r[e] > -d) { t = e; break } d = Math.abs(r[t] - d) < Math.abs(r[t - 1] - d) || "next" === e.swipeDirection ? r[t] : r[t - 1], d = -d } if (f && n("transitionEnd", (() => { e.loopFix() })), 0 !== e.velocity) { if (t = o ? Math.abs((-d - e.translate) / e.velocity) : Math.abs((d - e.translate) / e.velocity), s.freeMode.sticky) { const i = Math.abs((o ? -d : d) - e.translate), n = e.slidesSizesGrid[e.activeIndex]; t = i < n ? s.speed : i < 2 * n ? 1.5 * s.speed : 2.5 * s.speed } } else if (s.freeMode.sticky) return void e.slideToClosest(); s.freeMode.momentumBounce && u ? (e.updateProgress(h), e.setTransition(t), e.setTranslate(d), e.transitionStart(!0, e.swipeDirection), e.animating = !0, a.transitionEnd((() => { e && !e.destroyed && l.allowMomentumBounce && (i("momentumBounce"), e.setTransition(s.speed), setTimeout((() => { e.setTranslate(h), a.transitionEnd((() => { e && !e.destroyed && e.transitionEnd() })) }), 0)) }))) : e.velocity ? (i("_freeModeNoMomentumRelease"), e.updateProgress(d), e.setTransition(t), e.setTranslate(d), e.transitionStart(!0, e.swipeDirection), e.animating || (e.animating = !0, a.transitionEnd((() => { e && !e.destroyed && e.transitionEnd() })))) : e.updateProgress(d), e.updateActiveIndex(), e.updateSlidesClasses() } else { if (s.freeMode.sticky) return void e.slideToClosest(); s.freeMode && i("_freeModeNoMomentumRelease") } (!s.freeMode.momentum || c >= s.longSwipesMs) && (e.updateProgress(), e.updateActiveIndex(), e.updateSlidesClasses()) } } } }) }, function ({ swiper: e, extendParams: t }) { let i, n, s; t({ grid: { rows: 1, fill: "column" } }), e.grid = { initSlides: t => { const { slidesPerView: a } = e.params, { rows: o, fill: r } = e.params.grid; n = i / o, s = Math.floor(t / o), i = Math.floor(t / o) === t / o ? t : Math.ceil(t / o) * o, "auto" !== a && "row" === r && (i = Math.max(i, a * o)) }, updateSlide: (t, a, o, r) => { const { slidesPerGroup: l, spaceBetween: c } = e.params, { rows: d, fill: h } = e.params.grid; let u, p, f; if ("row" === h && l > 1) { const e = Math.floor(t / (l * d)), n = t - d * l * e, s = 0 === e ? l : Math.min(Math.ceil((o - e * d * l) / d), l); f = Math.floor(n / s), p = n - f * s + e * l, u = p + f * i / d, a.css({ "-webkit-order": u, order: u }) } else "column" === h ? (p = Math.floor(t / d), f = t - p * d, (p > s || p === s && f === d - 1) && (f += 1, f >= d && (f = 0, p += 1))) : (f = Math.floor(t / n), p = t - f * n); a.css(r("margin-top"), 0 !== f ? c && `${c}px` : "") }, updateWrapperSize: (t, n, s) => { const { spaceBetween: a, centeredSlides: o, roundLengths: r } = e.params, { rows: l } = e.params.grid; if (e.virtualSize = (t + a) * i, e.virtualSize = Math.ceil(e.virtualSize / l) - a, e.$wrapperEl.css({ [s("width")]: `${e.virtualSize + a}px` }), o) { n.splice(0, n.length); const t = []; for (let i = 0; i < n.length; i += 1) { let s = n[i]; r && (s = Math.floor(s)), n[i] < e.virtualSize + n[0] && t.push(s) } n.push(...t) } } } }, function ({ swiper: e }) { Object.assign(e, { appendSlide: ee.bind(e), prependSlide: te.bind(e), addSlide: ie.bind(e), removeSlide: ne.bind(e), removeAllSlides: se.bind(e) }) }, function ({ swiper: e, extendParams: t, on: i }) { t({ fadeEffect: { crossFade: !1, transformEl: null } }), ae({ effect: "fade", swiper: e, on: i, setTranslate: () => { const { slides: t } = e, i = e.params.fadeEffect; for (let n = 0; n < t.length; n += 1) { const t = e.slides.eq(n); let s = -t[0].swiperSlideOffset; e.params.virtualTranslate || (s -= e.translate); let a = 0; e.isHorizontal() || (a = s, s = 0); const o = e.params.fadeEffect.crossFade ? Math.max(1 - Math.abs(t[0].progress), 0) : 1 + Math.min(Math.max(t[0].progress, -1), 0); oe(i, t).css({ opacity: o }).transform(`translate3d(${s}px, ${a}px, 0px)`) } }, setTransition: t => { const { transformEl: i } = e.params.fadeEffect; (i ? e.slides.find(i) : e.slides).transition(t), re({ swiper: e, duration: t, transformEl: i, allSlides: !0 }) }, overwriteParams: () => ({ slidesPerView: 1, slidesPerGroup: 1, watchSlidesProgress: !0, spaceBetween: 0, virtualTranslate: !e.params.cssMode }) }) }, function ({ swiper: e, extendParams: t, on: i }) { t({ cubeEffect: { slideShadows: !0, shadow: !0, shadowOffset: 20, shadowScale: .94 } }); const n = (e, t, i) => { let n = i ? e.find(".swiper-slide-shadow-left") : e.find(".swiper-slide-shadow-top"), s = i ? e.find(".swiper-slide-shadow-right") : e.find(".swiper-slide-shadow-bottom"); 0 === n.length && (n = p(`<div class="swiper-slide-shadow-${i ? "left" : "top"}"></div>`), e.append(n)), 0 === s.length && (s = p(`<div class="swiper-slide-shadow-${i ? "right" : "bottom"}"></div>`), e.append(s)), n.length && (n[0].style.opacity = Math.max(-t, 0)), s.length && (s[0].style.opacity = Math.max(t, 0)) }; ae({ effect: "cube", swiper: e, on: i, setTranslate: () => { const { $el: t, $wrapperEl: i, slides: s, width: a, height: o, rtlTranslate: r, size: l, browser: c } = e, d = e.params.cubeEffect, h = e.isHorizontal(), u = e.virtual && e.params.virtual.enabled; let f, m = 0; d.shadow && (h ? (f = i.find(".swiper-cube-shadow"), 0 === f.length && (f = p('<div class="swiper-cube-shadow"></div>'), i.append(f)), f.css({ height: `${a}px` })) : (f = t.find(".swiper-cube-shadow"), 0 === f.length && (f = p('<div class="swiper-cube-shadow"></div>'), t.append(f)))); for (let e = 0; e < s.length; e += 1) { const t = s.eq(e); let i = e; u && (i = parseInt(t.attr("data-swiper-slide-index"), 10)); let a = 90 * i, o = Math.floor(a / 360); r && (a = -a, o = Math.floor(-a / 360)); const c = Math.max(Math.min(t[0].progress, 1), -1); let p = 0, f = 0, g = 0; i % 4 == 0 ? (p = 4 * -o * l, g = 0) : (i - 1) % 4 == 0 ? (p = 0, g = 4 * -o * l) : (i - 2) % 4 == 0 ? (p = l + 4 * o * l, g = l) : (i - 3) % 4 == 0 && (p = -l, g = 3 * l + 4 * l * o), r && (p = -p), h || (f = p, p = 0); const v = `rotateX(${h ? 0 : -a}deg) rotateY(${h ? a : 0}deg) translate3d(${p}px, ${f}px, ${g}px)`; c <= 1 && c > -1 && (m = 90 * i + 90 * c, r && (m = 90 * -i - 90 * c)), t.transform(v), d.slideShadows && n(t, c, h) } if (i.css({ "-webkit-transform-origin": `50% 50% -${l / 2}px`, "transform-origin": `50% 50% -${l / 2}px` }), d.shadow) if (h) f.transform(`translate3d(0px, ${a / 2 + d.shadowOffset}px, ${-a / 2}px) rotateX(90deg) rotateZ(0deg) scale(${d.shadowScale})`); else { const e = Math.abs(m) - 90 * Math.floor(Math.abs(m) / 90), t = 1.5 - (Math.sin(2 * e * Math.PI / 360) / 2 + Math.cos(2 * e * Math.PI / 360) / 2), i = d.shadowScale, n = d.shadowScale / t, s = d.shadowOffset; f.transform(`scale3d(${i}, 1, ${n}) translate3d(0px, ${o / 2 + s}px, ${-o / 2 / n}px) rotateX(-90deg)`) } const g = c.isSafari || c.isWebView ? -l / 2 : 0; i.transform(`translate3d(0px,0,${g}px) rotateX(${e.isHorizontal() ? 0 : m}deg) rotateY(${e.isHorizontal() ? -m : 0}deg)`), i[0].style.setProperty("--swiper-cube-translate-z", `${g}px`) }, setTransition: t => { const { $el: i, slides: n } = e; n.transition(t).find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").transition(t), e.params.cubeEffect.shadow && !e.isHorizontal() && i.find(".swiper-cube-shadow").transition(t) }, recreateShadows: () => { const t = e.isHorizontal(); e.slides.each((e => { const i = Math.max(Math.min(e.progress, 1), -1); n(p(e), i, t) })) }, getEffectParams: () => e.params.cubeEffect, perspective: () => !0, overwriteParams: () => ({ slidesPerView: 1, slidesPerGroup: 1, watchSlidesProgress: !0, resistanceRatio: 0, spaceBetween: 0, centeredSlides: !1, virtualTranslate: !0 }) }) }, function ({ swiper: e, extendParams: t, on: i }) { t({ flipEffect: { slideShadows: !0, limitRotation: !0, transformEl: null } }); const n = (t, i, n) => { let s = e.isHorizontal() ? t.find(".swiper-slide-shadow-left") : t.find(".swiper-slide-shadow-top"), a = e.isHorizontal() ? t.find(".swiper-slide-shadow-right") : t.find(".swiper-slide-shadow-bottom"); 0 === s.length && (s = le(n, t, e.isHorizontal() ? "left" : "top")), 0 === a.length && (a = le(n, t, e.isHorizontal() ? "right" : "bottom")), s.length && (s[0].style.opacity = Math.max(-i, 0)), a.length && (a[0].style.opacity = Math.max(i, 0)) }; ae({ effect: "flip", swiper: e, on: i, setTranslate: () => { const { slides: t, rtlTranslate: i } = e, s = e.params.flipEffect; for (let a = 0; a < t.length; a += 1) { const o = t.eq(a); let r = o[0].progress; e.params.flipEffect.limitRotation && (r = Math.max(Math.min(o[0].progress, 1), -1)); const l = o[0].swiperSlideOffset; let c = -180 * r, d = 0, h = e.params.cssMode ? -l - e.translate : -l, u = 0; e.isHorizontal() ? i && (c = -c) : (u = h, h = 0, d = -c, c = 0), o[0].style.zIndex = -Math.abs(Math.round(r)) + t.length, s.slideShadows && n(o, r, s); const p = `translate3d(${h}px, ${u}px, 0px) rotateX(${d}deg) rotateY(${c}deg)`; oe(s, o).transform(p) } }, setTransition: t => { const { transformEl: i } = e.params.flipEffect; (i ? e.slides.find(i) : e.slides).transition(t).find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").transition(t), re({ swiper: e, duration: t, transformEl: i }) }, recreateShadows: () => { const t = e.params.flipEffect; e.slides.each((i => { const s = p(i); let a = s[0].progress; e.params.flipEffect.limitRotation && (a = Math.max(Math.min(i.progress, 1), -1)), n(s, a, t) })) }, getEffectParams: () => e.params.flipEffect, perspective: () => !0, overwriteParams: () => ({ slidesPerView: 1, slidesPerGroup: 1, watchSlidesProgress: !0, spaceBetween: 0, virtualTranslate: !e.params.cssMode }) }) }, function ({ swiper: e, extendParams: t, on: i }) { t({ coverflowEffect: { rotate: 50, stretch: 0, depth: 100, scale: 1, modifier: 1, slideShadows: !0, transformEl: null } }), ae({ effect: "coverflow", swiper: e, on: i, setTranslate: () => { const { width: t, height: i, slides: n, slidesSizesGrid: s } = e, a = e.params.coverflowEffect, o = e.isHorizontal(), r = e.translate, l = o ? t / 2 - r : i / 2 - r, c = o ? a.rotate : -a.rotate, d = a.depth; for (let e = 0, t = n.length; e < t; e += 1) { const t = n.eq(e), i = s[e], r = (l - t[0].swiperSlideOffset - i / 2) / i, h = "function" == typeof a.modifier ? a.modifier(r) : r * a.modifier; let u = o ? c * h : 0, p = o ? 0 : c * h, f = -d * Math.abs(h), m = a.stretch; "string" == typeof m && -1 !== m.indexOf("%") && (m = parseFloat(a.stretch) / 100 * i); let g = o ? 0 : m * h, v = o ? m * h : 0, y = 1 - (1 - a.scale) * Math.abs(h); Math.abs(v) < .001 && (v = 0), Math.abs(g) < .001 && (g = 0), Math.abs(f) < .001 && (f = 0), Math.abs(u) < .001 && (u = 0), Math.abs(p) < .001 && (p = 0), Math.abs(y) < .001 && (y = 0); const b = `translate3d(${v}px,${g}px,${f}px)  rotateX(${p}deg) rotateY(${u}deg) scale(${y})`; if (oe(a, t).transform(b), t[0].style.zIndex = 1 - Math.abs(Math.round(h)), a.slideShadows) { let e = o ? t.find(".swiper-slide-shadow-left") : t.find(".swiper-slide-shadow-top"), i = o ? t.find(".swiper-slide-shadow-right") : t.find(".swiper-slide-shadow-bottom"); 0 === e.length && (e = le(a, t, o ? "left" : "top")), 0 === i.length && (i = le(a, t, o ? "right" : "bottom")), e.length && (e[0].style.opacity = h > 0 ? h : 0), i.length && (i[0].style.opacity = -h > 0 ? -h : 0) } } }, setTransition: t => { const { transformEl: i } = e.params.coverflowEffect; (i ? e.slides.find(i) : e.slides).transition(t).find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").transition(t) }, perspective: () => !0, overwriteParams: () => ({ watchSlidesProgress: !0 }) }) }, function ({ swiper: e, extendParams: t, on: i }) { t({ creativeEffect: { transformEl: null, limitProgress: 1, shadowPerProgress: !1, progressMultiplier: 1, perspective: !0, prev: { translate: [0, 0, 0], rotate: [0, 0, 0], opacity: 1, scale: 1 }, next: { translate: [0, 0, 0], rotate: [0, 0, 0], opacity: 1, scale: 1 } } }); const n = e => "string" == typeof e ? e : `${e}px`; ae({ effect: "creative", swiper: e, on: i, setTranslate: () => { const { slides: t, $wrapperEl: i, slidesSizesGrid: s } = e, a = e.params.creativeEffect, { progressMultiplier: o } = a, r = e.params.centeredSlides; if (r) { const t = s[0] / 2 - e.params.slidesOffsetBefore || 0; i.transform(`translateX(calc(50% - ${t}px))`) } for (let i = 0; i < t.length; i += 1) { const s = t.eq(i), l = s[0].progress, c = Math.min(Math.max(s[0].progress, -a.limitProgress), a.limitProgress); let d = c; r || (d = Math.min(Math.max(s[0].originalProgress, -a.limitProgress), a.limitProgress)); const h = s[0].swiperSlideOffset, u = [e.params.cssMode ? -h - e.translate : -h, 0, 0], p = [0, 0, 0]; let f = !1; e.isHorizontal() || (u[1] = u[0], u[0] = 0); let m = { translate: [0, 0, 0], rotate: [0, 0, 0], scale: 1, opacity: 1 }; c < 0 ? (m = a.next, f = !0) : c > 0 && (m = a.prev, f = !0), u.forEach(((e, t) => { u[t] = `calc(${e}px + (${n(m.translate[t])} * ${Math.abs(c * o)}))` })), p.forEach(((e, t) => { p[t] = m.rotate[t] * Math.abs(c * o) })), s[0].style.zIndex = -Math.abs(Math.round(l)) + t.length; const g = u.join(", "), v = `rotateX(${p[0]}deg) rotateY(${p[1]}deg) rotateZ(${p[2]}deg)`, y = d < 0 ? `scale(${1 + (1 - m.scale) * d * o})` : `scale(${1 - (1 - m.scale) * d * o})`, b = d < 0 ? 1 + (1 - m.opacity) * d * o : 1 - (1 - m.opacity) * d * o, x = `translate3d(${g}) ${v} ${y}`; if (f && m.shadow || !f) { let e = s.children(".swiper-slide-shadow"); if (0 === e.length && m.shadow && (e = le(a, s)), e.length) { const t = a.shadowPerProgress ? c * (1 / a.limitProgress) : c; e[0].style.opacity = Math.min(Math.max(Math.abs(t), 0), 1) } } const w = oe(a, s); w.transform(x).css({ opacity: b }), m.origin && w.css("transform-origin", m.origin) } }, setTransition: t => { const { transformEl: i } = e.params.creativeEffect; (i ? e.slides.find(i) : e.slides).transition(t).find(".swiper-slide-shadow").transition(t), re({ swiper: e, duration: t, transformEl: i, allSlides: !0 }) }, perspective: () => e.params.creativeEffect.perspective, overwriteParams: () => ({ watchSlidesProgress: !0, virtualTranslate: !e.params.cssMode }) }) }, function ({ swiper: e, extendParams: t, on: i }) { t({ cardsEffect: { slideShadows: !0, transformEl: null, rotate: !0, perSlideRotate: 2, perSlideOffset: 8 } }), ae({ effect: "cards", swiper: e, on: i, setTranslate: () => { const { slides: t, activeIndex: i } = e, n = e.params.cardsEffect, { startTranslate: s, isTouched: a } = e.touchEventsData, o = e.translate; for (let r = 0; r < t.length; r += 1) { const l = t.eq(r), c = l[0].progress, d = Math.min(Math.max(c, -4), 4); let h = l[0].swiperSlideOffset; e.params.centeredSlides && !e.params.cssMode && e.$wrapperEl.transform(`translateX(${e.minTranslate()}px)`), e.params.centeredSlides && e.params.cssMode && (h -= t[0].swiperSlideOffset); let u = e.params.cssMode ? -h - e.translate : -h, p = 0; const f = -100 * Math.abs(d); let m = 1, g = -n.perSlideRotate * d, v = n.perSlideOffset - .75 * Math.abs(d); const y = e.virtual && e.params.virtual.enabled ? e.virtual.from + r : r, b = (y === i || y === i - 1) && d > 0 && d < 1 && (a || e.params.cssMode) && o < s, x = (y === i || y === i + 1) && d < 0 && d > -1 && (a || e.params.cssMode) && o > s; if (b || x) { const e = (1 - Math.abs((Math.abs(d) - .5) / .5)) ** .5; g += -28 * d * e, m += -.5 * e, v += 96 * e, p = -25 * e * Math.abs(d) + "%" } if (u = d < 0 ? `calc(${u}px + (${v * Math.abs(d)}%))` : d > 0 ? `calc(${u}px + (-${v * Math.abs(d)}%))` : `${u}px`, !e.isHorizontal()) { const e = p; p = u, u = e } const w = d < 0 ? "" + (1 + (1 - m) * d) : "" + (1 - (1 - m) * d), C = `\n        translate3d(${u}, ${p}, ${f}px)\n        rotateZ(${n.rotate ? g : 0}deg)\n        scale(${w})\n      `; if (n.slideShadows) { let e = l.find(".swiper-slide-shadow"); 0 === e.length && (e = le(n, l)), e.length && (e[0].style.opacity = Math.min(Math.max((Math.abs(d) - .5) / .5, 0), 1)) } l[0].style.zIndex = -Math.abs(Math.round(c)) + t.length; oe(n, l).transform(C) } }, setTransition: t => { const { transformEl: i } = e.params.cardsEffect; (i ? e.slides.find(i) : e.slides).transition(t).find(".swiper-slide-shadow").transition(t), re({ swiper: e, duration: t, transformEl: i }) }, perspective: () => !0, overwriteParams: () => ({ watchSlidesProgress: !0, virtualTranslate: !e.params.cssMode }) }) }]; K.use(ce), new K(".menu-nav-js", { autoplay: { delay: 5e3, disableOnInteraction: !1 }, pagination: { el: ".swiper-pagination", clickable: !0 } }), new K(".comments-js", { slidesPerView: 1, spaceBetween: 0, loop: !0, autoplay: { delay: 5e3, disableOnInteraction: !1 }, navigation: { nextEl: ".comments-next", prevEl: ".comments-prev" }, breakpoints: { 500: { slidesPerView: 2, spaceBetween: 10 }, 768: { slidesPerView: 3, spaceBetween: 10 }, 992: { slidesPerView: 4, spaceBetween: 10 }, 1300: { slidesPerView: 5, spaceBetween: 20 } } }), new K(".full-width-js", { effect: "fade", observer: !0, observeParents: !0, navigation: { nextEl: ".swiper-button-next", prevEl: ".swiper-button-prev" } }) }() }();